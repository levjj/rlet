/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(1);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2);\nmocha.setup(\"bdd\");\n__webpack_require__(10)\n__webpack_require__(176);\nif(false) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(function() {\n\t\tmocha.suite.suites.length = 0;\n\t\tvar stats = document.getElementById('mocha-stats');\n\t\tvar report = document.getElementById('mocha-report');\n\t\tstats.parentNode.removeChild(stats);\n\t\treport.parentNode.removeChild(report);\n\t});\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader!./test/index.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./test/index.js?./~/mocha-loader");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("if (! document.getElementById(\"mocha\")) { document.write(\"<div id=\\\"mocha\\\"></div>\"); }\r\n\r\n__webpack_require__(3);\r\n__webpack_require__(7);\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/web.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha-loader/web.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, {});\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tmodule.hot.accept(\"!!/home/cs/Projects/rlet/node_modules/mocha-loader/node_modules/css-loader/index.js!/home/cs/Projects/rlet/node_modules/mocha/mocha.css\", function() {\n\t\tvar newContent = require(\"!!/home/cs/Projects/rlet/node_modules/mocha-loader/node_modules/css-loader/index.js!/home/cs/Projects/rlet/node_modules/mocha/mocha.css\");\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\tupdate(newContent);\n\t});\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/~/style-loader!./~/mocha-loader/~/css-loader!./~/mocha/mocha.css\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha/mocha.css?./~/mocha-loader/~/style-loader!./~/mocha-loader/~/css-loader");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(5)();\nexports.push([module.id, \"@charset \\\"utf-8\\\";\\n\\nbody {\\n  margin:0;\\n}\\n\\n#mocha {\\n  font: 20px/1.5 \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  margin: 60px 50px;\\n}\\n\\n#mocha ul,\\n#mocha li {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n#mocha ul {\\n  list-style: none;\\n}\\n\\n#mocha h1,\\n#mocha h2 {\\n  margin: 0;\\n}\\n\\n#mocha h1 {\\n  margin-top: 15px;\\n  font-size: 1em;\\n  font-weight: 200;\\n}\\n\\n#mocha h1 a {\\n  text-decoration: none;\\n  color: inherit;\\n}\\n\\n#mocha h1 a:hover {\\n  text-decoration: underline;\\n}\\n\\n#mocha .suite .suite h1 {\\n  margin-top: 0;\\n  font-size: .8em;\\n}\\n\\n#mocha .hidden {\\n  display: none;\\n}\\n\\n#mocha h2 {\\n  font-size: 12px;\\n  font-weight: normal;\\n  cursor: pointer;\\n}\\n\\n#mocha .suite {\\n  margin-left: 15px;\\n}\\n\\n#mocha .test {\\n  margin-left: 15px;\\n  overflow: hidden;\\n}\\n\\n#mocha .test.pending:hover h2::after {\\n  content: '(pending)';\\n  font-family: arial, sans-serif;\\n}\\n\\n#mocha .test.pass.medium .duration {\\n  background: #c09853;\\n}\\n\\n#mocha .test.pass.slow .duration {\\n  background: #b94a48;\\n}\\n\\n#mocha .test.pass::before {\\n  content: '✓';\\n  font-size: 12px;\\n  display: block;\\n  float: left;\\n  margin-right: 5px;\\n  color: #00d6b2;\\n}\\n\\n#mocha .test.pass .duration {\\n  font-size: 9px;\\n  margin-left: 5px;\\n  padding: 2px 5px;\\n  color: #fff;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\\n  -webkit-border-radius: 5px;\\n  -moz-border-radius: 5px;\\n  -ms-border-radius: 5px;\\n  -o-border-radius: 5px;\\n  border-radius: 5px;\\n}\\n\\n#mocha .test.pass.fast .duration {\\n  display: none;\\n}\\n\\n#mocha .test.pending {\\n  color: #0b97c4;\\n}\\n\\n#mocha .test.pending::before {\\n  content: '◦';\\n  color: #0b97c4;\\n}\\n\\n#mocha .test.fail {\\n  color: #c00;\\n}\\n\\n#mocha .test.fail pre {\\n  color: black;\\n}\\n\\n#mocha .test.fail::before {\\n  content: '✖';\\n  font-size: 12px;\\n  display: block;\\n  float: left;\\n  margin-right: 5px;\\n  color: #c00;\\n}\\n\\n#mocha .test pre.error {\\n  color: #c00;\\n  max-height: 300px;\\n  overflow: auto;\\n}\\n\\n#mocha .test .html-error {\\n  overflow: auto;\\n  color: black;\\n  line-height: 1.5;\\n  display: block;\\n  float: left;\\n  clear: left;\\n  font: 12px/1.5 monaco, monospace;\\n  margin: 5px;\\n  padding: 15px;\\n  border: 1px solid #eee;\\n  max-width: 85%; /*(1)*/\\n  max-width: calc(100% - 42px); /*(2)*/\\n  max-height: 300px;\\n  word-wrap: break-word;\\n  border-bottom-color: #ddd;\\n  -webkit-border-radius: 3px;\\n  -webkit-box-shadow: 0 1px 3px #eee;\\n  -moz-border-radius: 3px;\\n  -moz-box-shadow: 0 1px 3px #eee;\\n  border-radius: 3px;\\n}\\n\\n#mocha .test .html-error pre.error {\\n  border: none;\\n  -webkit-border-radius: none;\\n  -webkit-box-shadow: none;\\n  -moz-border-radius: none;\\n  -moz-box-shadow: none;\\n  padding: 0;\\n  margin: 0;\\n  margin-top: 18px;\\n  max-height: none;\\n}\\n\\n/**\\n * (1): approximate for browsers not supporting calc\\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\\n *      ^^ seriously\\n */\\n#mocha .test pre {\\n  display: block;\\n  float: left;\\n  clear: left;\\n  font: 12px/1.5 monaco, monospace;\\n  margin: 5px;\\n  padding: 15px;\\n  border: 1px solid #eee;\\n  max-width: 85%; /*(1)*/\\n  max-width: calc(100% - 42px); /*(2)*/\\n  word-wrap: break-word;\\n  border-bottom-color: #ddd;\\n  -webkit-border-radius: 3px;\\n  -webkit-box-shadow: 0 1px 3px #eee;\\n  -moz-border-radius: 3px;\\n  -moz-box-shadow: 0 1px 3px #eee;\\n  border-radius: 3px;\\n}\\n\\n#mocha .test h2 {\\n  position: relative;\\n}\\n\\n#mocha .test a.replay {\\n  position: absolute;\\n  top: 3px;\\n  right: 0;\\n  text-decoration: none;\\n  vertical-align: middle;\\n  display: block;\\n  width: 15px;\\n  height: 15px;\\n  line-height: 15px;\\n  text-align: center;\\n  background: #eee;\\n  font-size: 15px;\\n  -moz-border-radius: 15px;\\n  border-radius: 15px;\\n  -webkit-transition: opacity 200ms;\\n  -moz-transition: opacity 200ms;\\n  transition: opacity 200ms;\\n  opacity: 0.3;\\n  color: #888;\\n}\\n\\n#mocha .test:hover a.replay {\\n  opacity: 1;\\n}\\n\\n#mocha-report.pass .test.fail {\\n  display: none;\\n}\\n\\n#mocha-report.fail .test.pass {\\n  display: none;\\n}\\n\\n#mocha-report.pending .test.pass,\\n#mocha-report.pending .test.fail {\\n  display: none;\\n}\\n#mocha-report.pending .test.pass.pending {\\n  display: block;\\n}\\n\\n#mocha-error {\\n  color: #c00;\\n  font-size: 1.5em;\\n  font-weight: 100;\\n  letter-spacing: 1px;\\n}\\n\\n#mocha-stats {\\n  position: fixed;\\n  top: 15px;\\n  right: 10px;\\n  font-size: 12px;\\n  margin: 0;\\n  color: #888;\\n  z-index: 1;\\n}\\n\\n#mocha-stats .progress {\\n  float: right;\\n  padding-top: 0;\\n}\\n\\n#mocha-stats em {\\n  color: black;\\n}\\n\\n#mocha-stats a {\\n  text-decoration: none;\\n  color: inherit;\\n}\\n\\n#mocha-stats a:hover {\\n  border-bottom: 1px solid #eee;\\n}\\n\\n#mocha-stats li {\\n  display: inline-block;\\n  margin: 0 5px;\\n  list-style: none;\\n  padding-top: 11px;\\n}\\n\\n#mocha-stats canvas {\\n  width: 40px;\\n  height: 40px;\\n}\\n\\n#mocha code .comment { color: #ddd; }\\n#mocha code .init { color: #2f6fad; }\\n#mocha code .string { color: #5890ad; }\\n#mocha code .keyword { color: #8a6343; }\\n#mocha code .number { color: #2f6fad; }\\n\\n@media screen and (max-device-width: 480px) {\\n  #mocha {\\n    margin: 60px 0px;\\n  }\\n\\n  #mocha #stats {\\n    position: absolute;\\n  }\\n}\\n\", \"\"]);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/~/css-loader!./~/mocha/mocha.css\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha/mocha.css?./~/mocha-loader/~/css-loader");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = function() {\r\n\tvar list = [];\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\treturn list;\r\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/~/css-loader/cssToString.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha-loader/~/css-loader/cssToString.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisIE9 = memoize(function() {\r\n\t\treturn /msie 9\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(false) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isIE9();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function () {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction replaceText(source, id, replacement) {\r\n\tvar boundaries = [\"/** >>\" + id + \" **/\", \"/** \" + id + \"<< **/\"];\r\n\tvar start = source.lastIndexOf(boundaries[0]);\r\n\tvar wrappedReplacement = replacement\r\n\t\t? (boundaries[0] + replacement + boundaries[1])\r\n\t\t: \"\";\r\n\tif (source.lastIndexOf(boundaries[0]) >= 0) {\r\n\t\tvar end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;\r\n\t\treturn source.slice(0, start) + wrappedReplacement + source.slice(end);\r\n\t} else {\r\n\t\treturn source + wrappedReplacement;\r\n\t}\r\n}\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap && typeof btoa === \"function\") {\r\n\t\ttry {\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t\tcss = \"@import url(\\\"data:text/css;base64,\" + btoa(css) + \"\\\")\";\r\n\t\t} catch(e) {}\r\n\t}\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/~/style-loader/addStyles.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha-loader/~/style-loader/addStyles.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(8)(__webpack_require__(9))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/script-loader!./~/mocha/mocha.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha/mocha.js?./~/script-loader");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript === \"function\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/script-loader/addScript.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/script-loader/addScript.js?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n(function (process){\\nmodule.exports = process.env.COV\\n  ? require('./lib-cov/mocha')\\n  : require('./lib/mocha');\\n\\n}).call(this,require('_process'))\\n},{\\\"./lib-cov/mocha\\\":undefined,\\\"./lib/mocha\\\":14,\\\"_process\\\":51}],2:[function(require,module,exports){\\n/* eslint-disable no-unused-vars */\\nmodule.exports = function(type) {\\n  return function() {};\\n};\\n\\n},{}],3:[function(require,module,exports){\\n/**\\n * Module exports.\\n */\\n\\nexports.EventEmitter = EventEmitter;\\n\\n/**\\n * Object#hasOwnProperty reference.\\n */\\nvar objToString = Object.prototype.toString;\\n\\n/**\\n * Check if a value is an array.\\n *\\n * @api private\\n * @param {*} val The value to test.\\n * @return {boolean} true if the value is a boolean, otherwise false.\\n */\\nfunction isArray(val) {\\n  return objToString.call(val) === '[object Array]';\\n}\\n\\n/**\\n * Event emitter constructor.\\n *\\n * @api public\\n */\\nfunction EventEmitter() {}\\n\\n/**\\n * Add a listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.on = function(name, fn) {\\n  if (!this.$events) {\\n    this.$events = {};\\n  }\\n\\n  if (!this.$events[name]) {\\n    this.$events[name] = fn;\\n  } else if (isArray(this.$events[name])) {\\n    this.$events[name].push(fn);\\n  } else {\\n    this.$events[name] = [this.$events[name], fn];\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\\n\\n/**\\n * Adds a volatile listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.once = function(name, fn) {\\n  var self = this;\\n\\n  function on() {\\n    self.removeListener(name, on);\\n    fn.apply(this, arguments);\\n  }\\n\\n  on.listener = fn;\\n  this.on(name, on);\\n\\n  return this;\\n};\\n\\n/**\\n * Remove a listener.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @param {Function} fn Event handler.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.removeListener = function(name, fn) {\\n  if (this.$events && this.$events[name]) {\\n    var list = this.$events[name];\\n\\n    if (isArray(list)) {\\n      var pos = -1;\\n\\n      for (var i = 0, l = list.length; i < l; i++) {\\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\\n          pos = i;\\n          break;\\n        }\\n      }\\n\\n      if (pos < 0) {\\n        return this;\\n      }\\n\\n      list.splice(pos, 1);\\n\\n      if (!list.length) {\\n        delete this.$events[name];\\n      }\\n    } else if (list === fn || (list.listener && list.listener === fn)) {\\n      delete this.$events[name];\\n    }\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Remove all listeners for an event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.removeAllListeners = function(name) {\\n  if (name === undefined) {\\n    this.$events = {};\\n    return this;\\n  }\\n\\n  if (this.$events && this.$events[name]) {\\n    this.$events[name] = null;\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Get all listeners for a given event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {EventEmitter} Emitter instance.\\n */\\nEventEmitter.prototype.listeners = function(name) {\\n  if (!this.$events) {\\n    this.$events = {};\\n  }\\n\\n  if (!this.$events[name]) {\\n    this.$events[name] = [];\\n  }\\n\\n  if (!isArray(this.$events[name])) {\\n    this.$events[name] = [this.$events[name]];\\n  }\\n\\n  return this.$events[name];\\n};\\n\\n/**\\n * Emit an event.\\n *\\n * @api public\\n * @param {string} name Event name.\\n * @return {boolean} true if at least one handler was invoked, else false.\\n */\\nEventEmitter.prototype.emit = function(name) {\\n  if (!this.$events) {\\n    return false;\\n  }\\n\\n  var handler = this.$events[name];\\n\\n  if (!handler) {\\n    return false;\\n  }\\n\\n  var args = Array.prototype.slice.call(arguments, 1);\\n\\n  if (typeof handler === 'function') {\\n    handler.apply(this, args);\\n  } else if (isArray(handler)) {\\n    var listeners = handler.slice();\\n\\n    for (var i = 0, l = listeners.length; i < l; i++) {\\n      listeners[i].apply(this, args);\\n    }\\n  } else {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n\\n},{}],4:[function(require,module,exports){\\n/**\\n * Expose `Progress`.\\n */\\n\\nmodule.exports = Progress;\\n\\n/**\\n * Initialize a new `Progress` indicator.\\n */\\nfunction Progress() {\\n  this.percent = 0;\\n  this.size(0);\\n  this.fontSize(11);\\n  this.font('helvetica, arial, sans-serif');\\n}\\n\\n/**\\n * Set progress size to `size`.\\n *\\n * @api public\\n * @param {number} size\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.size = function(size) {\\n  this._size = size;\\n  return this;\\n};\\n\\n/**\\n * Set text to `text`.\\n *\\n * @api public\\n * @param {string} text\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.text = function(text) {\\n  this._text = text;\\n  return this;\\n};\\n\\n/**\\n * Set font size to `size`.\\n *\\n * @api public\\n * @param {number} size\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.fontSize = function(size) {\\n  this._fontSize = size;\\n  return this;\\n};\\n\\n/**\\n * Set font to `family`.\\n *\\n * @param {string} family\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.font = function(family) {\\n  this._font = family;\\n  return this;\\n};\\n\\n/**\\n * Update percentage to `n`.\\n *\\n * @param {number} n\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.update = function(n) {\\n  this.percent = n;\\n  return this;\\n};\\n\\n/**\\n * Draw on `ctx`.\\n *\\n * @param {CanvasRenderingContext2d} ctx\\n * @return {Progress} Progress instance.\\n */\\nProgress.prototype.draw = function(ctx) {\\n  try {\\n    var percent = Math.min(this.percent, 100);\\n    var size = this._size;\\n    var half = size / 2;\\n    var x = half;\\n    var y = half;\\n    var rad = half - 1;\\n    var fontSize = this._fontSize;\\n\\n    ctx.font = fontSize + 'px ' + this._font;\\n\\n    var angle = Math.PI * 2 * (percent / 100);\\n    ctx.clearRect(0, 0, size, size);\\n\\n    // outer circle\\n    ctx.strokeStyle = '#9f9f9f';\\n    ctx.beginPath();\\n    ctx.arc(x, y, rad, 0, angle, false);\\n    ctx.stroke();\\n\\n    // inner circle\\n    ctx.strokeStyle = '#eee';\\n    ctx.beginPath();\\n    ctx.arc(x, y, rad - 1, 0, angle, true);\\n    ctx.stroke();\\n\\n    // text\\n    var text = this._text || (percent | 0) + '%';\\n    var w = ctx.measureText(text).width;\\n\\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\\n  } catch (err) {\\n    // don't fail if we can't render progress\\n  }\\n  return this;\\n};\\n\\n},{}],5:[function(require,module,exports){\\n(function (global){\\nexports.isatty = function isatty() {\\n  return true;\\n};\\n\\nexports.getWindowSize = function getWindowSize() {\\n  if ('innerHeight' in global) {\\n    return [global.innerHeight, global.innerWidth];\\n  }\\n  // In a Web Worker, the DOM Window is not available.\\n  return [640, 480];\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{}],6:[function(require,module,exports){\\n/**\\n * Expose `Context`.\\n */\\n\\nmodule.exports = Context;\\n\\n/**\\n * Initialize a new `Context`.\\n *\\n * @api private\\n */\\nfunction Context() {}\\n\\n/**\\n * Set or get the context `Runnable` to `runnable`.\\n *\\n * @api private\\n * @param {Runnable} runnable\\n * @return {Context}\\n */\\nContext.prototype.runnable = function(runnable) {\\n  if (!arguments.length) {\\n    return this._runnable;\\n  }\\n  this.test = this._runnable = runnable;\\n  return this;\\n};\\n\\n/**\\n * Set test timeout `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {Context} self\\n */\\nContext.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this.runnable().timeout();\\n  }\\n  this.runnable().timeout(ms);\\n  return this;\\n};\\n\\n/**\\n * Set test timeout `enabled`.\\n *\\n * @api private\\n * @param {boolean} enabled\\n * @return {Context} self\\n */\\nContext.prototype.enableTimeouts = function(enabled) {\\n  this.runnable().enableTimeouts(enabled);\\n  return this;\\n};\\n\\n/**\\n * Set test slowness threshold `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {Context} self\\n */\\nContext.prototype.slow = function(ms) {\\n  this.runnable().slow(ms);\\n  return this;\\n};\\n\\n/**\\n * Mark a test as skipped.\\n *\\n * @api private\\n * @return {Context} self\\n */\\nContext.prototype.skip = function() {\\n  this.runnable().skip();\\n  return this;\\n};\\n\\n/**\\n * Inspect the context void of `._runnable`.\\n *\\n * @api private\\n * @return {string}\\n */\\nContext.prototype.inspect = function() {\\n  return JSON.stringify(this, function(key, val) {\\n    return key === 'runnable' || key === 'test' ? undefined : val;\\n  }, 2);\\n};\\n\\n},{}],7:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Runnable = require('./runnable');\\nvar inherits = require('./utils').inherits;\\n\\n/**\\n * Expose `Hook`.\\n */\\n\\nmodule.exports = Hook;\\n\\n/**\\n * Initialize a new `Hook` with the given `title` and callback `fn`.\\n *\\n * @param {String} title\\n * @param {Function} fn\\n * @api private\\n */\\nfunction Hook(title, fn) {\\n  Runnable.call(this, title, fn);\\n  this.type = 'hook';\\n}\\n\\n/**\\n * Inherit from `Runnable.prototype`.\\n */\\ninherits(Hook, Runnable);\\n\\n/**\\n * Get or set the test `err`.\\n *\\n * @param {Error} err\\n * @return {Error}\\n * @api public\\n */\\nHook.prototype.error = function(err) {\\n  if (!arguments.length) {\\n    err = this._error;\\n    this._error = null;\\n    return err;\\n  }\\n\\n  this._error = err;\\n};\\n\\n},{\\\"./runnable\\\":35,\\\"./utils\\\":39}],8:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * BDD-style interface:\\n *\\n *      describe('Array', function() {\\n *        describe('#indexOf()', function() {\\n *          it('should return -1 when not present', function() {\\n *            // ...\\n *          });\\n *\\n *          it('should return the index when present', function() {\\n *            // ...\\n *          });\\n *        });\\n *      });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.before = common.before;\\n    context.after = common.after;\\n    context.beforeEach = common.beforeEach;\\n    context.afterEach = common.afterEach;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title`\\n     * and callback `fn` containing nested suites\\n     * and/or tests.\\n     */\\n\\n    context.describe = context.context = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n      return suite;\\n    };\\n\\n    /**\\n     * Pending describe.\\n     */\\n\\n    context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.pending = true;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n    };\\n\\n    /**\\n     * Exclusive suite.\\n     */\\n\\n    context.describe.only = function(title, fn) {\\n      var suite = context.describe(title, fn);\\n      mocha.grep(suite.fullTitle());\\n      return suite;\\n    };\\n\\n    /**\\n     * Describe a specification or test-case\\n     * with the given `title` and callback `fn`\\n     * acting as a thunk.\\n     */\\n\\n    context.it = context.specify = function(title, fn) {\\n      var suite = suites[0];\\n      if (suite.pending) {\\n        fn = null;\\n      }\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suite.addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.it.only = function(title, fn) {\\n      var test = context.it(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n      return test;\\n    };\\n\\n    /**\\n     * Pending test case.\\n     */\\n\\n    context.xit = context.xspecify = context.it.skip = function(title) {\\n      context.it(title);\\n    };\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":68}],9:[function(require,module,exports){\\n'use strict';\\n\\n/**\\n * Functions common to more than one interface.\\n *\\n * @param {Suite[]} suites\\n * @param {Context} context\\n * @return {Object} An object containing common functions.\\n */\\nmodule.exports = function(suites, context) {\\n  return {\\n    /**\\n     * This is only present if flag --delay is passed into Mocha. It triggers\\n     * root suite execution.\\n     *\\n     * @param {Suite} suite The root wuite.\\n     * @return {Function} A function which runs the root suite\\n     */\\n    runWithSuite: function runWithSuite(suite) {\\n      return function run() {\\n        suite.run();\\n      };\\n    },\\n\\n    /**\\n     * Execute before running tests.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    before: function(name, fn) {\\n      suites[0].beforeAll(name, fn);\\n    },\\n\\n    /**\\n     * Execute after running tests.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    after: function(name, fn) {\\n      suites[0].afterAll(name, fn);\\n    },\\n\\n    /**\\n     * Execute before each test case.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    beforeEach: function(name, fn) {\\n      suites[0].beforeEach(name, fn);\\n    },\\n\\n    /**\\n     * Execute after each test case.\\n     *\\n     * @param {string} name\\n     * @param {Function} fn\\n     */\\n    afterEach: function(name, fn) {\\n      suites[0].afterEach(name, fn);\\n    },\\n\\n    test: {\\n      /**\\n       * Pending test case.\\n       *\\n       * @param {string} title\\n       */\\n      skip: function(title) {\\n        context.test(title);\\n      }\\n    }\\n  };\\n};\\n\\n},{}],10:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\n\\n/**\\n * TDD-style interface:\\n *\\n *     exports.Array = {\\n *       '#indexOf()': {\\n *         'should return -1 when the value is not present': function() {\\n *\\n *         },\\n *\\n *         'should return the correct index when the value is present': function() {\\n *\\n *         }\\n *       }\\n *     };\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('require', visit);\\n\\n  function visit(obj, file) {\\n    var suite;\\n    for (var key in obj) {\\n      if (typeof obj[key] === 'function') {\\n        var fn = obj[key];\\n        switch (key) {\\n          case 'before':\\n            suites[0].beforeAll(fn);\\n            break;\\n          case 'after':\\n            suites[0].afterAll(fn);\\n            break;\\n          case 'beforeEach':\\n            suites[0].beforeEach(fn);\\n            break;\\n          case 'afterEach':\\n            suites[0].afterEach(fn);\\n            break;\\n          default:\\n            var test = new Test(key, fn);\\n            test.file = file;\\n            suites[0].addTest(test);\\n        }\\n      } else {\\n        suite = Suite.create(suites[0], key);\\n        suites.unshift(suite);\\n        visit(obj[key]);\\n        suites.shift();\\n      }\\n    }\\n  }\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38}],11:[function(require,module,exports){\\nexports.bdd = require('./bdd');\\nexports.tdd = require('./tdd');\\nexports.qunit = require('./qunit');\\nexports.exports = require('./exports');\\n\\n},{\\\"./bdd\\\":8,\\\"./exports\\\":10,\\\"./qunit\\\":12,\\\"./tdd\\\":13}],12:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * QUnit-style interface:\\n *\\n *     suite('Array');\\n *\\n *     test('#length', function() {\\n *       var arr = [1,2,3];\\n *       ok(arr.length == 3);\\n *     });\\n *\\n *     test('#indexOf()', function() {\\n *       var arr = [1,2,3];\\n *       ok(arr.indexOf(1) == 0);\\n *       ok(arr.indexOf(2) == 1);\\n *       ok(arr.indexOf(3) == 2);\\n *     });\\n *\\n *     suite('String');\\n *\\n *     test('#length', function() {\\n *       ok('foo'.length == 3);\\n *     });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.before = common.before;\\n    context.after = common.after;\\n    context.beforeEach = common.beforeEach;\\n    context.afterEach = common.afterEach;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title`.\\n     */\\n\\n    context.suite = function(title) {\\n      if (suites.length > 1) {\\n        suites.shift();\\n      }\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      return suite;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.suite.only = function(title, fn) {\\n      var suite = context.suite(title, fn);\\n      mocha.grep(suite.fullTitle());\\n    };\\n\\n    /**\\n     * Describe a specification or test-case\\n     * with the given `title` and callback `fn`\\n     * acting as a thunk.\\n     */\\n\\n    context.test = function(title, fn) {\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suites[0].addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.test.only = function(title, fn) {\\n      var test = context.test(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n    };\\n\\n    context.test.skip = common.test.skip;\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":68}],13:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Suite = require('../suite');\\nvar Test = require('../test');\\nvar escapeRe = require('escape-string-regexp');\\n\\n/**\\n * TDD-style interface:\\n *\\n *      suite('Array', function() {\\n *        suite('#indexOf()', function() {\\n *          suiteSetup(function() {\\n *\\n *          });\\n *\\n *          test('should return -1 when not present', function() {\\n *\\n *          });\\n *\\n *          test('should return the index when present', function() {\\n *\\n *          });\\n *\\n *          suiteTeardown(function() {\\n *\\n *          });\\n *        });\\n *      });\\n *\\n * @param {Suite} suite Root suite.\\n */\\nmodule.exports = function(suite) {\\n  var suites = [suite];\\n\\n  suite.on('pre-require', function(context, file, mocha) {\\n    var common = require('./common')(suites, context);\\n\\n    context.setup = common.beforeEach;\\n    context.teardown = common.afterEach;\\n    context.suiteSetup = common.before;\\n    context.suiteTeardown = common.after;\\n    context.run = mocha.options.delay && common.runWithSuite(suite);\\n\\n    /**\\n     * Describe a \\\"suite\\\" with the given `title` and callback `fn` containing\\n     * nested suites and/or tests.\\n     */\\n    context.suite = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.file = file;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n      return suite;\\n    };\\n\\n    /**\\n     * Pending suite.\\n     */\\n    context.suite.skip = function(title, fn) {\\n      var suite = Suite.create(suites[0], title);\\n      suite.pending = true;\\n      suites.unshift(suite);\\n      fn.call(suite);\\n      suites.shift();\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n    context.suite.only = function(title, fn) {\\n      var suite = context.suite(title, fn);\\n      mocha.grep(suite.fullTitle());\\n    };\\n\\n    /**\\n     * Describe a specification or test-case with the given `title` and\\n     * callback `fn` acting as a thunk.\\n     */\\n    context.test = function(title, fn) {\\n      var suite = suites[0];\\n      if (suite.pending) {\\n        fn = null;\\n      }\\n      var test = new Test(title, fn);\\n      test.file = file;\\n      suite.addTest(test);\\n      return test;\\n    };\\n\\n    /**\\n     * Exclusive test-case.\\n     */\\n\\n    context.test.only = function(title, fn) {\\n      var test = context.test(title, fn);\\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\\n      mocha.grep(new RegExp(reString));\\n    };\\n\\n    context.test.skip = common.test.skip;\\n  });\\n};\\n\\n},{\\\"../suite\\\":37,\\\"../test\\\":38,\\\"./common\\\":9,\\\"escape-string-regexp\\\":68}],14:[function(require,module,exports){\\n(function (process,global,__dirname){\\n/*!\\n * mocha\\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\\n * MIT Licensed\\n */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar escapeRe = require('escape-string-regexp');\\nvar path = require('path');\\nvar reporters = require('./reporters');\\nvar utils = require('./utils');\\n\\n/**\\n * Expose `Mocha`.\\n */\\n\\nexports = module.exports = Mocha;\\n\\n/**\\n * To require local UIs and reporters when running in node.\\n */\\n\\nif (!process.browser) {\\n  var cwd = process.cwd();\\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\\n}\\n\\n/**\\n * Expose internals.\\n */\\n\\nexports.utils = utils;\\nexports.interfaces = require('./interfaces');\\nexports.reporters = reporters;\\nexports.Runnable = require('./runnable');\\nexports.Context = require('./context');\\nexports.Runner = require('./runner');\\nexports.Suite = require('./suite');\\nexports.Hook = require('./hook');\\nexports.Test = require('./test');\\n\\n/**\\n * Return image `name` path.\\n *\\n * @api private\\n * @param {string} name\\n * @return {string}\\n */\\nfunction image(name) {\\n  return path.join(__dirname, '../images', name + '.png');\\n}\\n\\n/**\\n * Set up mocha with `options`.\\n *\\n * Options:\\n *\\n *   - `ui` name \\\"bdd\\\", \\\"tdd\\\", \\\"exports\\\" etc\\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\\n *   - `globals` array of accepted globals\\n *   - `timeout` timeout in milliseconds\\n *   - `bail` bail on the first test failure\\n *   - `slow` milliseconds to wait before considering a test slow\\n *   - `ignoreLeaks` ignore global leaks\\n *   - `fullTrace` display the full stack-trace on failing\\n *   - `grep` string or regexp to filter tests with\\n *\\n * @param {Object} options\\n * @api public\\n */\\nfunction Mocha(options) {\\n  options = options || {};\\n  this.files = [];\\n  this.options = options;\\n  if (options.grep) {\\n    this.grep(new RegExp(options.grep));\\n  }\\n  if (options.fgrep) {\\n    this.grep(options.fgrep);\\n  }\\n  this.suite = new exports.Suite('', new exports.Context());\\n  this.ui(options.ui);\\n  this.bail(options.bail);\\n  this.reporter(options.reporter, options.reporterOptions);\\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\\n    this.timeout(options.timeout);\\n  }\\n  this.useColors(options.useColors);\\n  if (options.enableTimeouts !== null) {\\n    this.enableTimeouts(options.enableTimeouts);\\n  }\\n  if (options.slow) {\\n    this.slow(options.slow);\\n  }\\n\\n  this.suite.on('pre-require', function(context) {\\n    exports.afterEach = context.afterEach || context.teardown;\\n    exports.after = context.after || context.suiteTeardown;\\n    exports.beforeEach = context.beforeEach || context.setup;\\n    exports.before = context.before || context.suiteSetup;\\n    exports.describe = context.describe || context.suite;\\n    exports.it = context.it || context.test;\\n    exports.setup = context.setup || context.beforeEach;\\n    exports.suiteSetup = context.suiteSetup || context.before;\\n    exports.suiteTeardown = context.suiteTeardown || context.after;\\n    exports.suite = context.suite || context.describe;\\n    exports.teardown = context.teardown || context.afterEach;\\n    exports.test = context.test || context.it;\\n    exports.run = context.run;\\n  });\\n}\\n\\n/**\\n * Enable or disable bailing on the first failure.\\n *\\n * @api public\\n * @param {boolean} [bail]\\n */\\nMocha.prototype.bail = function(bail) {\\n  if (!arguments.length) {\\n    bail = true;\\n  }\\n  this.suite.bail(bail);\\n  return this;\\n};\\n\\n/**\\n * Add test `file`.\\n *\\n * @api public\\n * @param {string} file\\n */\\nMocha.prototype.addFile = function(file) {\\n  this.files.push(file);\\n  return this;\\n};\\n\\n/**\\n * Set reporter to `reporter`, defaults to \\\"spec\\\".\\n *\\n * @param {String|Function} reporter name or constructor\\n * @param {Object} reporterOptions optional options\\n * @api public\\n * @param {string|Function} reporter name or constructor\\n * @param {Object} reporterOptions optional options\\n */\\nMocha.prototype.reporter = function(reporter, reporterOptions) {\\n  if (typeof reporter === 'function') {\\n    this._reporter = reporter;\\n  } else {\\n    reporter = reporter || 'spec';\\n    var _reporter;\\n    // Try to load a built-in reporter.\\n    if (reporters[reporter]) {\\n      _reporter = reporters[reporter];\\n    }\\n    // Try to load reporters from process.cwd() and node_modules\\n    if (!_reporter) {\\n      try {\\n        _reporter = require(reporter);\\n      } catch (err) {\\n        err.message.indexOf('Cannot find module') !== -1\\n          ? console.warn('\\\"' + reporter + '\\\" reporter not found')\\n          : console.warn('\\\"' + reporter + '\\\" reporter blew up with error:\\\\n' + err.stack);\\n      }\\n    }\\n    if (!_reporter && reporter === 'teamcity') {\\n      console.warn('The Teamcity reporter was moved to a package named '\\n        + 'mocha-teamcity-reporter '\\n        + '(https://npmjs.org/package/mocha-teamcity-reporter).');\\n    }\\n    if (!_reporter) {\\n      throw new Error('invalid reporter \\\"' + reporter + '\\\"');\\n    }\\n    this._reporter = _reporter;\\n  }\\n  this.options.reporterOptions = reporterOptions;\\n  return this;\\n};\\n\\n/**\\n * Set test UI `name`, defaults to \\\"bdd\\\".\\n *\\n * @api public\\n * @param {string} bdd\\n */\\nMocha.prototype.ui = function(name) {\\n  name = name || 'bdd';\\n  this._ui = exports.interfaces[name];\\n  if (!this._ui) {\\n    try {\\n      this._ui = require(name);\\n    } catch (err) {\\n      throw new Error('invalid interface \\\"' + name + '\\\"');\\n    }\\n  }\\n  this._ui = this._ui(this.suite);\\n  return this;\\n};\\n\\n/**\\n * Load registered files.\\n *\\n * @api private\\n */\\nMocha.prototype.loadFiles = function(fn) {\\n  var self = this;\\n  var suite = this.suite;\\n  var pending = this.files.length;\\n  this.files.forEach(function(file) {\\n    file = path.resolve(file);\\n    suite.emit('pre-require', global, file, self);\\n    suite.emit('require', require(file), file, self);\\n    suite.emit('post-require', global, file, self);\\n    --pending || (fn && fn());\\n  });\\n};\\n\\n/**\\n * Enable growl support.\\n *\\n * @api private\\n */\\nMocha.prototype._growl = function(runner, reporter) {\\n  var notify = require('growl');\\n\\n  runner.on('end', function() {\\n    var stats = reporter.stats;\\n    if (stats.failures) {\\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\\n    } else {\\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\\n        name: 'mocha',\\n        title: 'Passed',\\n        image: image('ok')\\n      });\\n    }\\n  });\\n};\\n\\n/**\\n * Add regexp to grep, if `re` is a string it is escaped.\\n *\\n * @param {RegExp|String} re\\n * @return {Mocha}\\n * @api public\\n * @param {RegExp|string} re\\n * @return {Mocha}\\n */\\nMocha.prototype.grep = function(re) {\\n  this.options.grep = typeof re === 'string' ? new RegExp(escapeRe(re)) : re;\\n  return this;\\n};\\n\\n/**\\n * Invert `.grep()` matches.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.invert = function() {\\n  this.options.invert = true;\\n  return this;\\n};\\n\\n/**\\n * Ignore global leaks.\\n *\\n * @param {Boolean} ignore\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} ignore\\n * @return {Mocha}\\n */\\nMocha.prototype.ignoreLeaks = function(ignore) {\\n  this.options.ignoreLeaks = Boolean(ignore);\\n  return this;\\n};\\n\\n/**\\n * Enable global leak checking.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.checkLeaks = function() {\\n  this.options.ignoreLeaks = false;\\n  return this;\\n};\\n\\n/**\\n * Display long stack-trace on failing\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.fullTrace = function() {\\n  this.options.fullStackTrace = true;\\n  return this;\\n};\\n\\n/**\\n * Enable growl support.\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.growl = function() {\\n  this.options.growl = true;\\n  return this;\\n};\\n\\n/**\\n * Ignore `globals` array or string.\\n *\\n * @param {Array|String} globals\\n * @return {Mocha}\\n * @api public\\n * @param {Array|string} globals\\n * @return {Mocha}\\n */\\nMocha.prototype.globals = function(globals) {\\n  this.options.globals = (this.options.globals || []).concat(globals);\\n  return this;\\n};\\n\\n/**\\n * Emit color output.\\n *\\n * @param {Boolean} colors\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} colors\\n * @return {Mocha}\\n */\\nMocha.prototype.useColors = function(colors) {\\n  if (colors !== undefined) {\\n    this.options.useColors = colors;\\n  }\\n  return this;\\n};\\n\\n/**\\n * Use inline diffs rather than +/-.\\n *\\n * @param {Boolean} inlineDiffs\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} inlineDiffs\\n * @return {Mocha}\\n */\\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\\n  return this;\\n};\\n\\n/**\\n * Set the timeout in milliseconds.\\n *\\n * @param {Number} timeout\\n * @return {Mocha}\\n * @api public\\n * @param {number} timeout\\n * @return {Mocha}\\n */\\nMocha.prototype.timeout = function(timeout) {\\n  this.suite.timeout(timeout);\\n  return this;\\n};\\n\\n/**\\n * Set slowness threshold in milliseconds.\\n *\\n * @param {Number} slow\\n * @return {Mocha}\\n * @api public\\n * @param {number} slow\\n * @return {Mocha}\\n */\\nMocha.prototype.slow = function(slow) {\\n  this.suite.slow(slow);\\n  return this;\\n};\\n\\n/**\\n * Enable timeouts.\\n *\\n * @param {Boolean} enabled\\n * @return {Mocha}\\n * @api public\\n * @param {boolean} enabled\\n * @return {Mocha}\\n */\\nMocha.prototype.enableTimeouts = function(enabled) {\\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\\n  return this;\\n};\\n\\n/**\\n * Makes all tests async (accepting a callback)\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.asyncOnly = function() {\\n  this.options.asyncOnly = true;\\n  return this;\\n};\\n\\n/**\\n * Disable syntax highlighting (in browser).\\n *\\n * @api public\\n */\\nMocha.prototype.noHighlighting = function() {\\n  this.options.noHighlighting = true;\\n  return this;\\n};\\n\\n/**\\n * Enable uncaught errors to propagate (in browser).\\n *\\n * @return {Mocha}\\n * @api public\\n */\\nMocha.prototype.allowUncaught = function() {\\n  this.options.allowUncaught = true;\\n  return this;\\n};\\n\\n/**\\n * Delay root suite execution.\\n * @returns {Mocha}\\n */\\nMocha.prototype.delay = function delay() {\\n  this.options.delay = true;\\n  return this;\\n};\\n\\n/**\\n * Run tests and invoke `fn()` when complete.\\n *\\n * @api public\\n * @param {Function} fn\\n * @return {Runner}\\n */\\nMocha.prototype.run = function(fn) {\\n  if (this.files.length) {\\n    this.loadFiles();\\n  }\\n  var suite = this.suite;\\n  var options = this.options;\\n  options.files = this.files;\\n  var runner = new exports.Runner(suite, options.delay);\\n  var reporter = new this._reporter(runner, options);\\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\\n  runner.fullStackTrace = options.fullStackTrace;\\n  runner.asyncOnly = options.asyncOnly;\\n  runner.allowUncaught = options.allowUncaught;\\n  if (options.grep) {\\n    runner.grep(options.grep, options.invert);\\n  }\\n  if (options.globals) {\\n    runner.globals(options.globals);\\n  }\\n  if (options.growl) {\\n    this._growl(runner, reporter);\\n  }\\n  if (options.useColors !== undefined) {\\n    exports.reporters.Base.useColors = options.useColors;\\n  }\\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\\n\\n  function done(failures) {\\n    if (reporter.done) {\\n      reporter.done(failures, fn);\\n    } else {\\n      fn && fn(failures);\\n    }\\n  }\\n\\n  return runner.run(done);\\n};\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {},\\\"/lib\\\")\\n},{\\\"./context\\\":6,\\\"./hook\\\":7,\\\"./interfaces\\\":11,\\\"./reporters\\\":22,\\\"./runnable\\\":35,\\\"./runner\\\":36,\\\"./suite\\\":37,\\\"./test\\\":38,\\\"./utils\\\":39,\\\"_process\\\":51,\\\"escape-string-regexp\\\":68,\\\"growl\\\":69,\\\"path\\\":41}],15:[function(require,module,exports){\\n/**\\n * Helpers.\\n */\\n\\nvar s = 1000;\\nvar m = s * 60;\\nvar h = m * 60;\\nvar d = h * 24;\\nvar y = d * 365.25;\\n\\n/**\\n * Parse or format the given `val`.\\n *\\n * Options:\\n *\\n *  - `long` verbose formatting [false]\\n *\\n * @api public\\n * @param {string|number} val\\n * @param {Object} options\\n * @return {string|number}\\n */\\nmodule.exports = function(val, options) {\\n  options = options || {};\\n  if (typeof val === 'string') {\\n    return parse(val);\\n  }\\n  // https://github.com/mochajs/mocha/pull/1035\\n  return options['long'] ? longFormat(val) : shortFormat(val);\\n};\\n\\n/**\\n * Parse the given `str` and return milliseconds.\\n *\\n * @api private\\n * @param {string} str\\n * @return {number}\\n */\\nfunction parse(str) {\\n  var match = (/^((?:\\\\d+)?\\\\.?\\\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\\n  if (!match) {\\n    return;\\n  }\\n  var n = parseFloat(match[1]);\\n  var type = (match[2] || 'ms').toLowerCase();\\n  switch (type) {\\n    case 'years':\\n    case 'year':\\n    case 'y':\\n      return n * y;\\n    case 'days':\\n    case 'day':\\n    case 'd':\\n      return n * d;\\n    case 'hours':\\n    case 'hour':\\n    case 'h':\\n      return n * h;\\n    case 'minutes':\\n    case 'minute':\\n    case 'm':\\n      return n * m;\\n    case 'seconds':\\n    case 'second':\\n    case 's':\\n      return n * s;\\n    case 'ms':\\n      return n;\\n    default:\\n      // No default case\\n  }\\n}\\n\\n/**\\n * Short format for `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {string}\\n */\\nfunction shortFormat(ms) {\\n  if (ms >= d) {\\n    return Math.round(ms / d) + 'd';\\n  }\\n  if (ms >= h) {\\n    return Math.round(ms / h) + 'h';\\n  }\\n  if (ms >= m) {\\n    return Math.round(ms / m) + 'm';\\n  }\\n  if (ms >= s) {\\n    return Math.round(ms / s) + 's';\\n  }\\n  return ms + 'ms';\\n}\\n\\n/**\\n * Long format for `ms`.\\n *\\n * @api private\\n * @param {number} ms\\n * @return {string}\\n */\\nfunction longFormat(ms) {\\n  return plural(ms, d, 'day')\\n    || plural(ms, h, 'hour')\\n    || plural(ms, m, 'minute')\\n    || plural(ms, s, 'second')\\n    || ms + ' ms';\\n}\\n\\n/**\\n * Pluralization helper.\\n *\\n * @api private\\n * @param {number} ms\\n * @param {number} n\\n * @param {string} name\\n */\\nfunction plural(ms, n, name) {\\n  if (ms < n) {\\n    return;\\n  }\\n  if (ms < n * 1.5) {\\n    return Math.floor(ms / n) + ' ' + name;\\n  }\\n  return Math.ceil(ms / n) + ' ' + name + 's';\\n}\\n\\n},{}],16:[function(require,module,exports){\\n\\n/**\\n * Expose `Pending`.\\n */\\n\\nmodule.exports = Pending;\\n\\n/**\\n * Initialize a new `Pending` error with the given message.\\n *\\n * @param {string} message\\n */\\nfunction Pending(message) {\\n  this.message = message;\\n}\\n\\n},{}],17:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar tty = require('tty');\\nvar diff = require('diff');\\nvar ms = require('../ms');\\nvar utils = require('../utils');\\nvar supportsColor = process.browser ? null : require('supports-color');\\n\\n/**\\n * Expose `Base`.\\n */\\n\\nexports = module.exports = Base;\\n\\n/**\\n * Save timer references to avoid Sinon interfering.\\n * See: https://github.com/mochajs/mocha/issues/237\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Check if both stdio streams are associated with a tty.\\n */\\n\\nvar isatty = tty.isatty(1) && tty.isatty(2);\\n\\n/**\\n * Enable coloring by default, except in the browser interface.\\n */\\n\\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\\n\\n/**\\n * Inline diffs instead of +/-\\n */\\n\\nexports.inlineDiffs = false;\\n\\n/**\\n * Default color map.\\n */\\n\\nexports.colors = {\\n  pass: 90,\\n  fail: 31,\\n  'bright pass': 92,\\n  'bright fail': 91,\\n  'bright yellow': 93,\\n  pending: 36,\\n  suite: 0,\\n  'error title': 0,\\n  'error message': 31,\\n  'error stack': 90,\\n  checkmark: 32,\\n  fast: 90,\\n  medium: 33,\\n  slow: 31,\\n  green: 32,\\n  light: 90,\\n  'diff gutter': 90,\\n  'diff added': 32,\\n  'diff removed': 31\\n};\\n\\n/**\\n * Default symbol map.\\n */\\n\\nexports.symbols = {\\n  ok: '✓',\\n  err: '✖',\\n  dot: '․'\\n};\\n\\n// With node.js on Windows: use symbols available in terminal default fonts\\nif (process.platform === 'win32') {\\n  exports.symbols.ok = '\\\\u221A';\\n  exports.symbols.err = '\\\\u00D7';\\n  exports.symbols.dot = '.';\\n}\\n\\n/**\\n * Color `str` with the given `type`,\\n * allowing colors to be disabled,\\n * as well as user-defined color\\n * schemes.\\n *\\n * @param {string} type\\n * @param {string} str\\n * @return {string}\\n * @api private\\n */\\nvar color = exports.color = function(type, str) {\\n  if (!exports.useColors) {\\n    return String(str);\\n  }\\n  return '\\\\u001b[' + exports.colors[type] + 'm' + str + '\\\\u001b[0m';\\n};\\n\\n/**\\n * Expose term window size, with some defaults for when stderr is not a tty.\\n */\\n\\nexports.window = {\\n  width: 75\\n};\\n\\nif (isatty) {\\n  exports.window.width = process.stdout.getWindowSize\\n      ? process.stdout.getWindowSize(1)[0]\\n      : tty.getWindowSize()[1];\\n}\\n\\n/**\\n * Expose some basic cursor interactions that are common among reporters.\\n */\\n\\nexports.cursor = {\\n  hide: function() {\\n    isatty && process.stdout.write('\\\\u001b[?25l');\\n  },\\n\\n  show: function() {\\n    isatty && process.stdout.write('\\\\u001b[?25h');\\n  },\\n\\n  deleteLine: function() {\\n    isatty && process.stdout.write('\\\\u001b[2K');\\n  },\\n\\n  beginningOfLine: function() {\\n    isatty && process.stdout.write('\\\\u001b[0G');\\n  },\\n\\n  CR: function() {\\n    if (isatty) {\\n      exports.cursor.deleteLine();\\n      exports.cursor.beginningOfLine();\\n    } else {\\n      process.stdout.write('\\\\r');\\n    }\\n  }\\n};\\n\\n/**\\n * Outut the given `failures` as a list.\\n *\\n * @param {Array} failures\\n * @api public\\n */\\n\\nexports.list = function(failures) {\\n  console.log();\\n  failures.forEach(function(test, i) {\\n    // format\\n    var fmt = color('error title', '  %s) %s:\\\\n')\\n      + color('error message', '     %s')\\n      + color('error stack', '\\\\n%s\\\\n');\\n\\n    // msg\\n    var msg;\\n    var err = test.err;\\n    var message;\\n    if (err.message) {\\n      message = err.message;\\n    } else if (typeof err.inspect === 'function') {\\n      message = err.inspect() + '';\\n    } else {\\n      message = '';\\n    }\\n    var stack = err.stack || message;\\n    var index = stack.indexOf(message);\\n    var actual = err.actual;\\n    var expected = err.expected;\\n    var escape = true;\\n\\n    if (index === -1) {\\n      msg = message;\\n    } else {\\n      index += message.length;\\n      msg = stack.slice(0, index);\\n      // remove msg from stack\\n      stack = stack.slice(index + 1);\\n    }\\n\\n    // uncaught\\n    if (err.uncaught) {\\n      msg = 'Uncaught ' + msg;\\n    }\\n    // explicitly show diff\\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\\n      escape = false;\\n      if (!(utils.isString(actual) && utils.isString(expected))) {\\n        err.actual = actual = utils.stringify(actual);\\n        err.expected = expected = utils.stringify(expected);\\n      }\\n\\n      fmt = color('error title', '  %s) %s:\\\\n%s') + color('error stack', '\\\\n%s\\\\n');\\n      var match = message.match(/^([^:]+): expected/);\\n      msg = '\\\\n      ' + color('error message', match ? match[1] : msg);\\n\\n      if (exports.inlineDiffs) {\\n        msg += inlineDiff(err, escape);\\n      } else {\\n        msg += unifiedDiff(err, escape);\\n      }\\n    }\\n\\n    // indent stack trace\\n    stack = stack.replace(/^/gm, '  ');\\n\\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\\n  });\\n};\\n\\n/**\\n * Initialize a new `Base` reporter.\\n *\\n * All other reporters generally\\n * inherit from this reporter, providing\\n * stats such as test duration, number\\n * of tests passed / failed etc.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\n\\nfunction Base(runner) {\\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\\n  var failures = this.failures = [];\\n\\n  if (!runner) {\\n    return;\\n  }\\n  this.runner = runner;\\n\\n  runner.stats = stats;\\n\\n  runner.on('start', function() {\\n    stats.start = new Date();\\n  });\\n\\n  runner.on('suite', function(suite) {\\n    stats.suites = stats.suites || 0;\\n    suite.root || stats.suites++;\\n  });\\n\\n  runner.on('test end', function() {\\n    stats.tests = stats.tests || 0;\\n    stats.tests++;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    stats.passes = stats.passes || 0;\\n\\n    if (test.duration > test.slow()) {\\n      test.speed = 'slow';\\n    } else if (test.duration > test.slow() / 2) {\\n      test.speed = 'medium';\\n    } else {\\n      test.speed = 'fast';\\n    }\\n\\n    stats.passes++;\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    stats.failures = stats.failures || 0;\\n    stats.failures++;\\n    test.err = err;\\n    failures.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    stats.end = new Date();\\n    stats.duration = new Date() - stats.start;\\n  });\\n\\n  runner.on('pending', function() {\\n    stats.pending++;\\n  });\\n}\\n\\n/**\\n * Output common epilogue used by many of\\n * the bundled reporters.\\n *\\n * @api public\\n */\\nBase.prototype.epilogue = function() {\\n  var stats = this.stats;\\n  var fmt;\\n\\n  console.log();\\n\\n  // passes\\n  fmt = color('bright pass', ' ')\\n    + color('green', ' %d passing')\\n    + color('light', ' (%s)');\\n\\n  console.log(fmt,\\n    stats.passes || 0,\\n    ms(stats.duration));\\n\\n  // pending\\n  if (stats.pending) {\\n    fmt = color('pending', ' ')\\n      + color('pending', ' %d pending');\\n\\n    console.log(fmt, stats.pending);\\n  }\\n\\n  // failures\\n  if (stats.failures) {\\n    fmt = color('fail', '  %d failing');\\n\\n    console.log(fmt, stats.failures);\\n\\n    Base.list(this.failures);\\n    console.log();\\n  }\\n\\n  console.log();\\n};\\n\\n/**\\n * Pad the given `str` to `len`.\\n *\\n * @api private\\n * @param {string} str\\n * @param {string} len\\n * @return {string}\\n */\\nfunction pad(str, len) {\\n  str = String(str);\\n  return Array(len - str.length + 1).join(' ') + str;\\n}\\n\\n/**\\n * Returns an inline diff between 2 strings with coloured ANSI output\\n *\\n * @api private\\n * @param {Error} err with actual/expected\\n * @param {boolean} escape\\n * @return {string} Diff\\n */\\nfunction inlineDiff(err, escape) {\\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\\n\\n  // linenos\\n  var lines = msg.split('\\\\n');\\n  if (lines.length > 4) {\\n    var width = String(lines.length).length;\\n    msg = lines.map(function(str, i) {\\n      return pad(++i, width) + ' |' + ' ' + str;\\n    }).join('\\\\n');\\n  }\\n\\n  // legend\\n  msg = '\\\\n'\\n    + color('diff removed', 'actual')\\n    + ' '\\n    + color('diff added', 'expected')\\n    + '\\\\n\\\\n'\\n    + msg\\n    + '\\\\n';\\n\\n  // indent\\n  msg = msg.replace(/^/gm, '      ');\\n  return msg;\\n}\\n\\n/**\\n * Returns a unified diff between two strings.\\n *\\n * @api private\\n * @param {Error} err with actual/expected\\n * @param {boolean} escape\\n * @return {string} The diff.\\n */\\nfunction unifiedDiff(err, escape) {\\n  var indent = '      ';\\n  function cleanUp(line) {\\n    if (escape) {\\n      line = escapeInvisibles(line);\\n    }\\n    if (line[0] === '+') {\\n      return indent + colorLines('diff added', line);\\n    }\\n    if (line[0] === '-') {\\n      return indent + colorLines('diff removed', line);\\n    }\\n    if (line.match(/\\\\@\\\\@/)) {\\n      return null;\\n    }\\n    if (line.match(/\\\\\\\\ No newline/)) {\\n      return null;\\n    }\\n    return indent + line;\\n  }\\n  function notBlank(line) {\\n    return typeof line !== 'undefined' && line !== null;\\n  }\\n  var msg = diff.createPatch('string', err.actual, err.expected);\\n  var lines = msg.split('\\\\n').splice(4);\\n  return '\\\\n      '\\n    + colorLines('diff added', '+ expected') + ' '\\n    + colorLines('diff removed', '- actual')\\n    + '\\\\n\\\\n'\\n    + lines.map(cleanUp).filter(notBlank).join('\\\\n');\\n}\\n\\n/**\\n * Return a character diff for `err`.\\n *\\n * @api private\\n * @param {Error} err\\n * @param {string} type\\n * @param {boolean} escape\\n * @return {string}\\n */\\nfunction errorDiff(err, type, escape) {\\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\\n  return diff['diff' + type](actual, expected).map(function(str) {\\n    if (str.added) {\\n      return colorLines('diff added', str.value);\\n    }\\n    if (str.removed) {\\n      return colorLines('diff removed', str.value);\\n    }\\n    return str.value;\\n  }).join('');\\n}\\n\\n/**\\n * Returns a string with all invisible characters in plain text\\n *\\n * @api private\\n * @param {string} line\\n * @return {string}\\n */\\nfunction escapeInvisibles(line) {\\n  return line.replace(/\\\\t/g, '<tab>')\\n    .replace(/\\\\r/g, '<CR>')\\n    .replace(/\\\\n/g, '<LF>\\\\n');\\n}\\n\\n/**\\n * Color lines for `str`, using the color `name`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {string} str\\n * @return {string}\\n */\\nfunction colorLines(name, str) {\\n  return str.split('\\\\n').map(function(str) {\\n    return color(name, str);\\n  }).join('\\\\n');\\n}\\n\\n/**\\n * Object#toString reference.\\n */\\nvar objToString = Object.prototype.toString;\\n\\n/**\\n * Check that a / b have the same type.\\n *\\n * @api private\\n * @param {Object} a\\n * @param {Object} b\\n * @return {boolean}\\n */\\nfunction sameType(a, b) {\\n  return objToString.call(a) === objToString.call(b);\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../ms\\\":15,\\\"../utils\\\":39,\\\"_process\\\":51,\\\"diff\\\":67,\\\"supports-color\\\":41,\\\"tty\\\":5}],18:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\n\\n/**\\n * Expose `Doc`.\\n */\\n\\nexports = module.exports = Doc;\\n\\n/**\\n * Initialize a new `Doc` reporter.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\nfunction Doc(runner) {\\n  Base.call(this, runner);\\n\\n  var indents = 2;\\n\\n  function indent() {\\n    return Array(indents).join('  ');\\n  }\\n\\n  runner.on('suite', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    ++indents;\\n    console.log('%s<section class=\\\"suite\\\">', indent());\\n    ++indents;\\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\\n    console.log('%s<dl>', indent());\\n  });\\n\\n  runner.on('suite end', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    console.log('%s</dl>', indent());\\n    --indents;\\n    console.log('%s</section>', indent());\\n    --indents;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\\n    var code = utils.escape(utils.clean(test.fn.toString()));\\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    console.log('%s  <dt class=\\\"error\\\">%s</dt>', indent(), utils.escape(test.title));\\n    var code = utils.escape(utils.clean(test.fn.toString()));\\n    console.log('%s  <dd class=\\\"error\\\"><pre><code>%s</code></pre></dd>', indent(), code);\\n    console.log('%s  <dd class=\\\"error\\\">%s</dd>', indent(), utils.escape(err));\\n  });\\n}\\n\\n},{\\\"../utils\\\":39,\\\"./base\\\":17}],19:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\n\\n/**\\n * Expose `Dot`.\\n */\\n\\nexports = module.exports = Dot;\\n\\n/**\\n * Initialize a new `Dot` matrix test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Dot(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var n = -1;\\n\\n  runner.on('start', function() {\\n    process.stdout.write('\\\\n');\\n  });\\n\\n  runner.on('pending', function() {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    process.stdout.write(color('pending', Base.symbols.dot));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    if (test.speed === 'slow') {\\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\\n    } else {\\n      process.stdout.write(color(test.speed, Base.symbols.dot));\\n    }\\n  });\\n\\n  runner.on('fail', function() {\\n    if (++n % width === 0) {\\n      process.stdout.write('\\\\n  ');\\n    }\\n    process.stdout.write(color('fail', Base.symbols.dot));\\n  });\\n\\n  runner.on('end', function() {\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Dot, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],20:[function(require,module,exports){\\n(function (process,__dirname){\\n/**\\n * Module dependencies.\\n */\\n\\nvar JSONCov = require('./json-cov');\\nvar readFileSync = require('fs').readFileSync;\\nvar join = require('path').join;\\n\\n/**\\n * Expose `HTMLCov`.\\n */\\n\\nexports = module.exports = HTMLCov;\\n\\n/**\\n * Initialize a new `JsCoverage` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction HTMLCov(runner) {\\n  var jade = require('jade');\\n  var file = join(__dirname, '/templates/coverage.jade');\\n  var str = readFileSync(file, 'utf8');\\n  var fn = jade.compile(str, { filename: file });\\n  var self = this;\\n\\n  JSONCov.call(this, runner, false);\\n\\n  runner.on('end', function() {\\n    process.stdout.write(fn({\\n      cov: self.cov,\\n      coverageClass: coverageClass\\n    }));\\n  });\\n}\\n\\n/**\\n * Return coverage class for a given coverage percentage.\\n *\\n * @api private\\n * @param {number} coveragePctg\\n * @return {string}\\n */\\nfunction coverageClass(coveragePctg) {\\n  if (coveragePctg >= 75) {\\n    return 'high';\\n  }\\n  if (coveragePctg >= 50) {\\n    return 'medium';\\n  }\\n  if (coveragePctg >= 25) {\\n    return 'low';\\n  }\\n  return 'terrible';\\n}\\n\\n}).call(this,require('_process'),\\\"/lib/reporters\\\")\\n},{\\\"./json-cov\\\":23,\\\"_process\\\":51,\\\"fs\\\":41,\\\"jade\\\":41,\\\"path\\\":41}],21:[function(require,module,exports){\\n(function (global){\\n/* eslint-env browser */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\nvar Progress = require('../browser/progress');\\nvar escapeRe = require('escape-string-regexp');\\nvar escape = utils.escape;\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Expose `HTML`.\\n */\\n\\nexports = module.exports = HTML;\\n\\n/**\\n * Stats template.\\n */\\n\\nvar statsTemplate = '<ul id=\\\"mocha-stats\\\">'\\n  + '<li class=\\\"progress\\\"><canvas width=\\\"40\\\" height=\\\"40\\\"></canvas></li>'\\n  + '<li class=\\\"passes\\\"><a href=\\\"javascript:void(0);\\\">passes:</a> <em>0</em></li>'\\n  + '<li class=\\\"failures\\\"><a href=\\\"javascript:void(0);\\\">failures:</a> <em>0</em></li>'\\n  + '<li class=\\\"duration\\\">duration: <em>0</em>s</li>'\\n  + '</ul>';\\n\\n/**\\n * Initialize a new `HTML` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction HTML(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var stats = this.stats;\\n  var stat = fragment(statsTemplate);\\n  var items = stat.getElementsByTagName('li');\\n  var passes = items[1].getElementsByTagName('em')[0];\\n  var passesLink = items[1].getElementsByTagName('a')[0];\\n  var failures = items[2].getElementsByTagName('em')[0];\\n  var failuresLink = items[2].getElementsByTagName('a')[0];\\n  var duration = items[3].getElementsByTagName('em')[0];\\n  var canvas = stat.getElementsByTagName('canvas')[0];\\n  var report = fragment('<ul id=\\\"mocha-report\\\"></ul>');\\n  var stack = [report];\\n  var progress;\\n  var ctx;\\n  var root = document.getElementById('mocha');\\n\\n  if (canvas.getContext) {\\n    var ratio = window.devicePixelRatio || 1;\\n    canvas.style.width = canvas.width;\\n    canvas.style.height = canvas.height;\\n    canvas.width *= ratio;\\n    canvas.height *= ratio;\\n    ctx = canvas.getContext('2d');\\n    ctx.scale(ratio, ratio);\\n    progress = new Progress();\\n  }\\n\\n  if (!root) {\\n    return error('#mocha div missing, add it to your document');\\n  }\\n\\n  // pass toggle\\n  on(passesLink, 'click', function() {\\n    unhide();\\n    var name = (/pass/).test(report.className) ? '' : ' pass';\\n    report.className = report.className.replace(/fail|pass/g, '') + name;\\n    if (report.className.trim()) {\\n      hideSuitesWithout('test pass');\\n    }\\n  });\\n\\n  // failure toggle\\n  on(failuresLink, 'click', function() {\\n    unhide();\\n    var name = (/fail/).test(report.className) ? '' : ' fail';\\n    report.className = report.className.replace(/fail|pass/g, '') + name;\\n    if (report.className.trim()) {\\n      hideSuitesWithout('test fail');\\n    }\\n  });\\n\\n  root.appendChild(stat);\\n  root.appendChild(report);\\n\\n  if (progress) {\\n    progress.size(40);\\n  }\\n\\n  runner.on('suite', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n\\n    // suite\\n    var url = self.suiteURL(suite);\\n    var el = fragment('<li class=\\\"suite\\\"><h1><a href=\\\"%s\\\">%s</a></h1></li>', url, escape(suite.title));\\n\\n    // container\\n    stack[0].appendChild(el);\\n    stack.unshift(document.createElement('ul'));\\n    el.appendChild(stack[0]);\\n  });\\n\\n  runner.on('suite end', function(suite) {\\n    if (suite.root) {\\n      return;\\n    }\\n    stack.shift();\\n  });\\n\\n  runner.on('fail', function(test) {\\n    if (test.type === 'hook') {\\n      runner.emit('test end', test);\\n    }\\n  });\\n\\n  runner.on('test end', function(test) {\\n    // TODO: add to stats\\n    var percent = stats.tests / this.total * 100 | 0;\\n    if (progress) {\\n      progress.update(percent).draw(ctx);\\n    }\\n\\n    // update stats\\n    var ms = new Date() - stats.start;\\n    text(passes, stats.passes);\\n    text(failures, stats.failures);\\n    text(duration, (ms / 1000).toFixed(2));\\n\\n    // test\\n    var el;\\n    if (test.state === 'passed') {\\n      var url = self.testURL(test);\\n      el = fragment('<li class=\\\"test pass %e\\\"><h2>%e<span class=\\\"duration\\\">%ems</span> <a href=\\\"%s\\\" class=\\\"replay\\\">‣</a></h2></li>', test.speed, test.title, test.duration, url);\\n    } else if (test.pending) {\\n      el = fragment('<li class=\\\"test pass pending\\\"><h2>%e</h2></li>', test.title);\\n    } else {\\n      el = fragment('<li class=\\\"test fail\\\"><h2>%e <a href=\\\"%e\\\" class=\\\"replay\\\">‣</a></h2></li>', test.title, self.testURL(test));\\n      var stackString; // Note: Includes leading newline\\n      var message = test.err.toString();\\n\\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\\n      // check for the result of the stringifying.\\n      if (message === '[object Error]') {\\n        message = test.err.message;\\n      }\\n\\n      if (test.err.stack) {\\n        var indexOfMessage = test.err.stack.indexOf(test.err.message);\\n        if (indexOfMessage === -1) {\\n          stackString = test.err.stack;\\n        } else {\\n          stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\\n        }\\n      } else if (test.err.sourceURL && test.err.line !== undefined) {\\n        // Safari doesn't give you a stack. Let's at least provide a source line.\\n        stackString = '\\\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\\n      }\\n\\n      stackString = stackString || '';\\n\\n      if (test.err.htmlMessage && stackString) {\\n        el.appendChild(fragment('<div class=\\\"html-error\\\">%s\\\\n<pre class=\\\"error\\\">%e</pre></div>', test.err.htmlMessage, stackString));\\n      } else if (test.err.htmlMessage) {\\n        el.appendChild(fragment('<div class=\\\"html-error\\\">%s</div>', test.err.htmlMessage));\\n      } else {\\n        el.appendChild(fragment('<pre class=\\\"error\\\">%e%e</pre>', message, stackString));\\n      }\\n    }\\n\\n    // toggle code\\n    // TODO: defer\\n    if (!test.pending) {\\n      var h2 = el.getElementsByTagName('h2')[0];\\n\\n      on(h2, 'click', function() {\\n        pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\\n      });\\n\\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\\n      el.appendChild(pre);\\n      pre.style.display = 'none';\\n    }\\n\\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\\n    if (stack[0]) {\\n      stack[0].appendChild(el);\\n    }\\n  });\\n}\\n\\n/**\\n * Makes a URL, preserving querystring (\\\"search\\\") parameters.\\n *\\n * @param {string} s\\n * @return {string} A new URL.\\n */\\nfunction makeUrl(s) {\\n  var search = window.location.search;\\n\\n  // Remove previous grep query parameter if present\\n  if (search) {\\n    search = search.replace(/[?&]grep=[^&\\\\s]*/g, '').replace(/^&/, '?');\\n  }\\n\\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\\n}\\n\\n/**\\n * Provide suite URL.\\n *\\n * @param {Object} [suite]\\n */\\nHTML.prototype.suiteURL = function(suite) {\\n  return makeUrl(suite.fullTitle());\\n};\\n\\n/**\\n * Provide test URL.\\n *\\n * @param {Object} [test]\\n */\\nHTML.prototype.testURL = function(test) {\\n  return makeUrl(test.fullTitle());\\n};\\n\\n/**\\n * Display error `msg`.\\n *\\n * @param {string} msg\\n */\\nfunction error(msg) {\\n  document.body.appendChild(fragment('<div id=\\\"mocha-error\\\">%s</div>', msg));\\n}\\n\\n/**\\n * Return a DOM fragment from `html`.\\n *\\n * @param {string} html\\n */\\nfunction fragment(html) {\\n  var args = arguments;\\n  var div = document.createElement('div');\\n  var i = 1;\\n\\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\\n    switch (type) {\\n      case 's': return String(args[i++]);\\n      case 'e': return escape(args[i++]);\\n      // no default\\n    }\\n  });\\n\\n  return div.firstChild;\\n}\\n\\n/**\\n * Check for suites that do not have elements\\n * with `classname`, and hide them.\\n *\\n * @param {text} classname\\n */\\nfunction hideSuitesWithout(classname) {\\n  var suites = document.getElementsByClassName('suite');\\n  for (var i = 0; i < suites.length; i++) {\\n    var els = suites[i].getElementsByClassName(classname);\\n    if (!els.length) {\\n      suites[i].className += ' hidden';\\n    }\\n  }\\n}\\n\\n/**\\n * Unhide .hidden suites.\\n */\\nfunction unhide() {\\n  var els = document.getElementsByClassName('suite hidden');\\n  for (var i = 0; i < els.length; ++i) {\\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\\n  }\\n}\\n\\n/**\\n * Set an element's text contents.\\n *\\n * @param {HTMLElement} el\\n * @param {string} contents\\n */\\nfunction text(el, contents) {\\n  if (el.textContent) {\\n    el.textContent = contents;\\n  } else {\\n    el.innerText = contents;\\n  }\\n}\\n\\n/**\\n * Listen on `event` with callback `fn`.\\n */\\nfunction on(el, event, fn) {\\n  if (el.addEventListener) {\\n    el.addEventListener(event, fn, false);\\n  } else {\\n    el.attachEvent('on' + event, fn);\\n  }\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../browser/progress\\\":4,\\\"../utils\\\":39,\\\"./base\\\":17,\\\"escape-string-regexp\\\":68}],22:[function(require,module,exports){\\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\\nexports.Base = exports.base = require('./base');\\nexports.Dot = exports.dot = require('./dot');\\nexports.Doc = exports.doc = require('./doc');\\nexports.TAP = exports.tap = require('./tap');\\nexports.JSON = exports.json = require('./json');\\nexports.HTML = exports.html = require('./html');\\nexports.List = exports.list = require('./list');\\nexports.Min = exports.min = require('./min');\\nexports.Spec = exports.spec = require('./spec');\\nexports.Nyan = exports.nyan = require('./nyan');\\nexports.XUnit = exports.xunit = require('./xunit');\\nexports.Markdown = exports.markdown = require('./markdown');\\nexports.Progress = exports.progress = require('./progress');\\nexports.Landing = exports.landing = require('./landing');\\nexports.JSONCov = exports['json-cov'] = require('./json-cov');\\nexports.HTMLCov = exports['html-cov'] = require('./html-cov');\\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\\n\\n},{\\\"./base\\\":17,\\\"./doc\\\":18,\\\"./dot\\\":19,\\\"./html\\\":21,\\\"./html-cov\\\":20,\\\"./json\\\":25,\\\"./json-cov\\\":23,\\\"./json-stream\\\":24,\\\"./landing\\\":26,\\\"./list\\\":27,\\\"./markdown\\\":28,\\\"./min\\\":29,\\\"./nyan\\\":30,\\\"./progress\\\":31,\\\"./spec\\\":32,\\\"./tap\\\":33,\\\"./xunit\\\":34}],23:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `JSONCov`.\\n */\\n\\nexports = module.exports = JSONCov;\\n\\n/**\\n * Initialize a new `JsCoverage` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n * @param {boolean} output\\n */\\nfunction JSONCov(runner, output) {\\n  Base.call(this, runner);\\n\\n  output = arguments.length === 1 || output;\\n  var self = this;\\n  var tests = [];\\n  var failures = [];\\n  var passes = [];\\n\\n  runner.on('test end', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    failures.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    var cov = global._$jscoverage || {};\\n    var result = self.cov = map(cov);\\n    result.stats = self.stats;\\n    result.tests = tests.map(clean);\\n    result.failures = failures.map(clean);\\n    result.passes = passes.map(clean);\\n    if (!output) {\\n      return;\\n    }\\n    process.stdout.write(JSON.stringify(result, null, 2));\\n  });\\n}\\n\\n/**\\n * Map jscoverage data to a JSON structure\\n * suitable for reporting.\\n *\\n * @api private\\n * @param {Object} cov\\n * @return {Object}\\n */\\n\\nfunction map(cov) {\\n  var ret = {\\n    instrumentation: 'node-jscoverage',\\n    sloc: 0,\\n    hits: 0,\\n    misses: 0,\\n    coverage: 0,\\n    files: []\\n  };\\n\\n  for (var filename in cov) {\\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\\n      var data = coverage(filename, cov[filename]);\\n      ret.files.push(data);\\n      ret.hits += data.hits;\\n      ret.misses += data.misses;\\n      ret.sloc += data.sloc;\\n    }\\n  }\\n\\n  ret.files.sort(function(a, b) {\\n    return a.filename.localeCompare(b.filename);\\n  });\\n\\n  if (ret.sloc > 0) {\\n    ret.coverage = (ret.hits / ret.sloc) * 100;\\n  }\\n\\n  return ret;\\n}\\n\\n/**\\n * Map jscoverage data for a single source file\\n * to a JSON structure suitable for reporting.\\n *\\n * @api private\\n * @param {string} filename name of the source file\\n * @param {Object} data jscoverage coverage data\\n * @return {Object}\\n */\\nfunction coverage(filename, data) {\\n  var ret = {\\n    filename: filename,\\n    coverage: 0,\\n    hits: 0,\\n    misses: 0,\\n    sloc: 0,\\n    source: {}\\n  };\\n\\n  data.source.forEach(function(line, num) {\\n    num++;\\n\\n    if (data[num] === 0) {\\n      ret.misses++;\\n      ret.sloc++;\\n    } else if (data[num] !== undefined) {\\n      ret.hits++;\\n      ret.sloc++;\\n    }\\n\\n    ret.source[num] = {\\n      source: line,\\n      coverage: data[num] === undefined ? '' : data[num]\\n    };\\n  });\\n\\n  ret.coverage = ret.hits / ret.sloc * 100;\\n\\n  return ret;\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    duration: test.duration,\\n    fullTitle: test.fullTitle(),\\n    title: test.title\\n  };\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./base\\\":17,\\\"_process\\\":51}],24:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `List`.\\n */\\n\\nexports = module.exports = List;\\n\\n/**\\n * Initialize a new `List` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction List(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var total = runner.total;\\n\\n  runner.on('start', function() {\\n    console.log(JSON.stringify(['start', { total: total }]));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    console.log(JSON.stringify(['pass', clean(test)]));\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    test = clean(test);\\n    test.err = err.message;\\n    test.stack = err.stack || null;\\n    console.log(JSON.stringify(['fail', test]));\\n  });\\n\\n  runner.on('end', function() {\\n    process.stdout.write(JSON.stringify(['end', self.stats]));\\n  });\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    title: test.title,\\n    fullTitle: test.fullTitle(),\\n    duration: test.duration\\n  };\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./base\\\":17,\\\"_process\\\":51}],25:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `JSON`.\\n */\\n\\nexports = module.exports = JSONReporter;\\n\\n/**\\n * Initialize a new `JSON` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction JSONReporter(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var tests = [];\\n  var pending = [];\\n  var failures = [];\\n  var passes = [];\\n\\n  runner.on('test end', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    failures.push(test);\\n  });\\n\\n  runner.on('pending', function(test) {\\n    pending.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    var obj = {\\n      stats: self.stats,\\n      tests: tests.map(clean),\\n      pending: pending.map(clean),\\n      failures: failures.map(clean),\\n      passes: passes.map(clean)\\n    };\\n\\n    runner.testResults = obj;\\n\\n    process.stdout.write(JSON.stringify(obj, null, 2));\\n  });\\n}\\n\\n/**\\n * Return a plain-object representation of `test`\\n * free of cyclic properties etc.\\n *\\n * @api private\\n * @param {Object} test\\n * @return {Object}\\n */\\nfunction clean(test) {\\n  return {\\n    title: test.title,\\n    fullTitle: test.fullTitle(),\\n    duration: test.duration,\\n    err: errorJSON(test.err || {})\\n  };\\n}\\n\\n/**\\n * Transform `error` into a JSON object.\\n *\\n * @api private\\n * @param {Error} err\\n * @return {Object}\\n */\\nfunction errorJSON(err) {\\n  var res = {};\\n  Object.getOwnPropertyNames(err).forEach(function(key) {\\n    res[key] = err[key];\\n  }, err);\\n  return res;\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./base\\\":17,\\\"_process\\\":51}],26:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar cursor = Base.cursor;\\nvar color = Base.color;\\n\\n/**\\n * Expose `Landing`.\\n */\\n\\nexports = module.exports = Landing;\\n\\n/**\\n * Airplane color.\\n */\\n\\nBase.colors.plane = 0;\\n\\n/**\\n * Airplane crash color.\\n */\\n\\nBase.colors['plane crash'] = 31;\\n\\n/**\\n * Runway color.\\n */\\n\\nBase.colors.runway = 90;\\n\\n/**\\n * Initialize a new `Landing` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Landing(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var total = runner.total;\\n  var stream = process.stdout;\\n  var plane = color('plane', '✈');\\n  var crashed = -1;\\n  var n = 0;\\n\\n  function runway() {\\n    var buf = Array(width).join('-');\\n    return '  ' + color('runway', buf);\\n  }\\n\\n  runner.on('start', function() {\\n    stream.write('\\\\n\\\\n\\\\n  ');\\n    cursor.hide();\\n  });\\n\\n  runner.on('test end', function(test) {\\n    // check if the plane crashed\\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\\n\\n    // show the crash\\n    if (test.state === 'failed') {\\n      plane = color('plane crash', '✈');\\n      crashed = col;\\n    }\\n\\n    // render landing strip\\n    stream.write('\\\\u001b[' + (width + 1) + 'D\\\\u001b[2A');\\n    stream.write(runway());\\n    stream.write('\\\\n  ');\\n    stream.write(color('runway', Array(col).join('⋅')));\\n    stream.write(plane);\\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\\\n'));\\n    stream.write(runway());\\n    stream.write('\\\\u001b[0m');\\n  });\\n\\n  runner.on('end', function() {\\n    cursor.show();\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Landing, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],27:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `List`.\\n */\\n\\nexports = module.exports = List;\\n\\n/**\\n * Initialize a new `List` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction List(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var n = 0;\\n\\n  runner.on('start', function() {\\n    console.log();\\n  });\\n\\n  runner.on('test', function(test) {\\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\\n  });\\n\\n  runner.on('pending', function(test) {\\n    var fmt = color('checkmark', '  -')\\n      + color('pending', ' %s');\\n    console.log(fmt, test.fullTitle());\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var fmt = color('checkmark', '  ' + Base.symbols.dot)\\n      + color('pass', ' %s: ')\\n      + color(test.speed, '%dms');\\n    cursor.CR();\\n    console.log(fmt, test.fullTitle(), test.duration);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    cursor.CR();\\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\\n  });\\n\\n  runner.on('end', self.epilogue.bind(self));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(List, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],28:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\n\\n/**\\n * Constants\\n */\\n\\nvar SUITE_PREFIX = '$';\\n\\n/**\\n * Expose `Markdown`.\\n */\\n\\nexports = module.exports = Markdown;\\n\\n/**\\n * Initialize a new `Markdown` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Markdown(runner) {\\n  Base.call(this, runner);\\n\\n  var level = 0;\\n  var buf = '';\\n\\n  function title(str) {\\n    return Array(level).join('#') + ' ' + str;\\n  }\\n\\n  function mapTOC(suite, obj) {\\n    var ret = obj;\\n    var key = SUITE_PREFIX + suite.title;\\n\\n    obj = obj[key] = obj[key] || { suite: suite };\\n    suite.suites.forEach(function(suite) {\\n      mapTOC(suite, obj);\\n    });\\n\\n    return ret;\\n  }\\n\\n  function stringifyTOC(obj, level) {\\n    ++level;\\n    var buf = '';\\n    var link;\\n    for (var key in obj) {\\n      if (key === 'suite') {\\n        continue;\\n      }\\n      if (key !== SUITE_PREFIX) {\\n        link = ' - [' + key.substring(1) + ']';\\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\\\n';\\n        buf += Array(level).join('  ') + link;\\n      }\\n      buf += stringifyTOC(obj[key], level);\\n    }\\n    return buf;\\n  }\\n\\n  function generateTOC(suite) {\\n    var obj = mapTOC(suite, {});\\n    return stringifyTOC(obj, 0);\\n  }\\n\\n  generateTOC(runner.suite);\\n\\n  runner.on('suite', function(suite) {\\n    ++level;\\n    var slug = utils.slug(suite.fullTitle());\\n    buf += '<a name=\\\"' + slug + '\\\"></a>' + '\\\\n';\\n    buf += title(suite.title) + '\\\\n';\\n  });\\n\\n  runner.on('suite end', function() {\\n    --level;\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var code = utils.clean(test.fn.toString());\\n    buf += test.title + '.\\\\n';\\n    buf += '\\\\n```js\\\\n';\\n    buf += code + '\\\\n';\\n    buf += '```\\\\n\\\\n';\\n  });\\n\\n  runner.on('end', function() {\\n    process.stdout.write('# TOC\\\\n');\\n    process.stdout.write(generateTOC(runner.suite));\\n    process.stdout.write(buf);\\n  });\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],29:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\n\\n/**\\n * Expose `Min`.\\n */\\n\\nexports = module.exports = Min;\\n\\n/**\\n * Initialize a new `Min` minimal test reporter (best used with --watch).\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Min(runner) {\\n  Base.call(this, runner);\\n\\n  runner.on('start', function() {\\n    // clear screen\\n    process.stdout.write('\\\\u001b[2J');\\n    // set cursor position\\n    process.stdout.write('\\\\u001b[1;3H');\\n  });\\n\\n  runner.on('end', this.epilogue.bind(this));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Min, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],30:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\n\\n/**\\n * Expose `Dot`.\\n */\\n\\nexports = module.exports = NyanCat;\\n\\n/**\\n * Initialize a new `Dot` matrix test reporter.\\n *\\n * @param {Runner} runner\\n * @api public\\n */\\n\\nfunction NyanCat(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .75 | 0;\\n  var nyanCatWidth = this.nyanCatWidth = 11;\\n\\n  this.colorIndex = 0;\\n  this.numberOfLines = 4;\\n  this.rainbowColors = self.generateColors();\\n  this.scoreboardWidth = 5;\\n  this.tick = 0;\\n  this.trajectories = [[], [], [], []];\\n  this.trajectoryWidthMax = (width - nyanCatWidth);\\n\\n  runner.on('start', function() {\\n    Base.cursor.hide();\\n    self.draw();\\n  });\\n\\n  runner.on('pending', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('pass', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('fail', function() {\\n    self.draw();\\n  });\\n\\n  runner.on('end', function() {\\n    Base.cursor.show();\\n    for (var i = 0; i < self.numberOfLines; i++) {\\n      write('\\\\n');\\n    }\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(NyanCat, Base);\\n\\n/**\\n * Draw the nyan cat\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.draw = function() {\\n  this.appendRainbow();\\n  this.drawScoreboard();\\n  this.drawRainbow();\\n  this.drawNyanCat();\\n  this.tick = !this.tick;\\n};\\n\\n/**\\n * Draw the \\\"scoreboard\\\" showing the number\\n * of passes, failures and pending tests.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.drawScoreboard = function() {\\n  var stats = this.stats;\\n\\n  function draw(type, n) {\\n    write(' ');\\n    write(Base.color(type, n));\\n    write('\\\\n');\\n  }\\n\\n  draw('green', stats.passes);\\n  draw('fail', stats.failures);\\n  draw('pending', stats.pending);\\n  write('\\\\n');\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Append the rainbow.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.appendRainbow = function() {\\n  var segment = this.tick ? '_' : '-';\\n  var rainbowified = this.rainbowify(segment);\\n\\n  for (var index = 0; index < this.numberOfLines; index++) {\\n    var trajectory = this.trajectories[index];\\n    if (trajectory.length >= this.trajectoryWidthMax) {\\n      trajectory.shift();\\n    }\\n    trajectory.push(rainbowified);\\n  }\\n};\\n\\n/**\\n * Draw the rainbow.\\n *\\n * @api private\\n */\\n\\nNyanCat.prototype.drawRainbow = function() {\\n  var self = this;\\n\\n  this.trajectories.forEach(function(line) {\\n    write('\\\\u001b[' + self.scoreboardWidth + 'C');\\n    write(line.join(''));\\n    write('\\\\n');\\n  });\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Draw the nyan cat\\n *\\n * @api private\\n */\\nNyanCat.prototype.drawNyanCat = function() {\\n  var self = this;\\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\\n  var dist = '\\\\u001b[' + startWidth + 'C';\\n  var padding = '';\\n\\n  write(dist);\\n  write('_,------,');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? '  ' : '   ';\\n  write('_|' + padding + '/\\\\\\\\_/\\\\\\\\ ');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? '_' : '__';\\n  var tail = self.tick ? '~' : '^';\\n  write(tail + '|' + padding + this.face() + ' ');\\n  write('\\\\n');\\n\\n  write(dist);\\n  padding = self.tick ? ' ' : '  ';\\n  write(padding + '\\\"\\\"  \\\"\\\" ');\\n  write('\\\\n');\\n\\n  this.cursorUp(this.numberOfLines);\\n};\\n\\n/**\\n * Draw nyan cat face.\\n *\\n * @api private\\n * @return {string}\\n */\\n\\nNyanCat.prototype.face = function() {\\n  var stats = this.stats;\\n  if (stats.failures) {\\n    return '( x .x)';\\n  } else if (stats.pending) {\\n    return '( o .o)';\\n  } else if (stats.passes) {\\n    return '( ^ .^)';\\n  }\\n  return '( - .-)';\\n};\\n\\n/**\\n * Move cursor up `n`.\\n *\\n * @api private\\n * @param {number} n\\n */\\n\\nNyanCat.prototype.cursorUp = function(n) {\\n  write('\\\\u001b[' + n + 'A');\\n};\\n\\n/**\\n * Move cursor down `n`.\\n *\\n * @api private\\n * @param {number} n\\n */\\n\\nNyanCat.prototype.cursorDown = function(n) {\\n  write('\\\\u001b[' + n + 'B');\\n};\\n\\n/**\\n * Generate rainbow colors.\\n *\\n * @api private\\n * @return {Array}\\n */\\nNyanCat.prototype.generateColors = function() {\\n  var colors = [];\\n\\n  for (var i = 0; i < (6 * 7); i++) {\\n    var pi3 = Math.floor(Math.PI / 3);\\n    var n = (i * (1.0 / 6));\\n    var r = Math.floor(3 * Math.sin(n) + 3);\\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\\n    colors.push(36 * r + 6 * g + b + 16);\\n  }\\n\\n  return colors;\\n};\\n\\n/**\\n * Apply rainbow to the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nNyanCat.prototype.rainbowify = function(str) {\\n  if (!Base.useColors) {\\n    return str;\\n  }\\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\\n  this.colorIndex += 1;\\n  return '\\\\u001b[38;5;' + color + 'm' + str + '\\\\u001b[0m';\\n};\\n\\n/**\\n * Stdout helper.\\n *\\n * @param {string} string A message to write to stdout.\\n */\\nfunction write(string) {\\n  process.stdout.write(string);\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],31:[function(require,module,exports){\\n(function (process){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `Progress`.\\n */\\n\\nexports = module.exports = Progress;\\n\\n/**\\n * General progress bar color.\\n */\\n\\nBase.colors.progress = 90;\\n\\n/**\\n * Initialize a new `Progress` bar test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n * @param {Object} options\\n */\\nfunction Progress(runner, options) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var width = Base.window.width * .50 | 0;\\n  var total = runner.total;\\n  var complete = 0;\\n  var lastN = -1;\\n\\n  // default chars\\n  options = options || {};\\n  options.open = options.open || '[';\\n  options.complete = options.complete || '▬';\\n  options.incomplete = options.incomplete || Base.symbols.dot;\\n  options.close = options.close || ']';\\n  options.verbose = false;\\n\\n  // tests started\\n  runner.on('start', function() {\\n    console.log();\\n    cursor.hide();\\n  });\\n\\n  // tests complete\\n  runner.on('test end', function() {\\n    complete++;\\n\\n    var percent = complete / total;\\n    var n = width * percent | 0;\\n    var i = width - n;\\n\\n    if (n === lastN && !options.verbose) {\\n      // Don't re-render the line if it hasn't changed\\n      return;\\n    }\\n    lastN = n;\\n\\n    cursor.CR();\\n    process.stdout.write('\\\\u001b[J');\\n    process.stdout.write(color('progress', '  ' + options.open));\\n    process.stdout.write(Array(n).join(options.complete));\\n    process.stdout.write(Array(i).join(options.incomplete));\\n    process.stdout.write(color('progress', options.close));\\n    if (options.verbose) {\\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\\n    }\\n  });\\n\\n  // tests are complete, output some stats\\n  // and the failures if any\\n  runner.on('end', function() {\\n    cursor.show();\\n    console.log();\\n    self.epilogue();\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Progress, Base);\\n\\n}).call(this,require('_process'))\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"_process\\\":51}],32:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar inherits = require('../utils').inherits;\\nvar color = Base.color;\\nvar cursor = Base.cursor;\\n\\n/**\\n * Expose `Spec`.\\n */\\n\\nexports = module.exports = Spec;\\n\\n/**\\n * Initialize a new `Spec` test reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction Spec(runner) {\\n  Base.call(this, runner);\\n\\n  var self = this;\\n  var indents = 0;\\n  var n = 0;\\n\\n  function indent() {\\n    return Array(indents).join('  ');\\n  }\\n\\n  runner.on('start', function() {\\n    console.log();\\n  });\\n\\n  runner.on('suite', function(suite) {\\n    ++indents;\\n    console.log(color('suite', '%s%s'), indent(), suite.title);\\n  });\\n\\n  runner.on('suite end', function() {\\n    --indents;\\n    if (indents === 1) {\\n      console.log();\\n    }\\n  });\\n\\n  runner.on('pending', function(test) {\\n    var fmt = indent() + color('pending', '  - %s');\\n    console.log(fmt, test.title);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    var fmt;\\n    if (test.speed === 'fast') {\\n      fmt = indent()\\n        + color('checkmark', '  ' + Base.symbols.ok)\\n        + color('pass', ' %s');\\n      cursor.CR();\\n      console.log(fmt, test.title);\\n    } else {\\n      fmt = indent()\\n        + color('checkmark', '  ' + Base.symbols.ok)\\n        + color('pass', ' %s')\\n        + color(test.speed, ' (%dms)');\\n      cursor.CR();\\n      console.log(fmt, test.title, test.duration);\\n    }\\n  });\\n\\n  runner.on('fail', function(test) {\\n    cursor.CR();\\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\\n  });\\n\\n  runner.on('end', self.epilogue.bind(self));\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(Spec, Base);\\n\\n},{\\\"../utils\\\":39,\\\"./base\\\":17}],33:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\n\\n/**\\n * Expose `TAP`.\\n */\\n\\nexports = module.exports = TAP;\\n\\n/**\\n * Initialize a new `TAP` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction TAP(runner) {\\n  Base.call(this, runner);\\n\\n  var n = 1;\\n  var passes = 0;\\n  var failures = 0;\\n\\n  runner.on('start', function() {\\n    var total = runner.grepTotal(runner.suite);\\n    console.log('%d..%d', 1, total);\\n  });\\n\\n  runner.on('test end', function() {\\n    ++n;\\n  });\\n\\n  runner.on('pending', function(test) {\\n    console.log('ok %d %s # SKIP -', n, title(test));\\n  });\\n\\n  runner.on('pass', function(test) {\\n    passes++;\\n    console.log('ok %d %s', n, title(test));\\n  });\\n\\n  runner.on('fail', function(test, err) {\\n    failures++;\\n    console.log('not ok %d %s', n, title(test));\\n    if (err.stack) {\\n      console.log(err.stack.replace(/^/gm, '  '));\\n    }\\n  });\\n\\n  runner.on('end', function() {\\n    console.log('# tests ' + (passes + failures));\\n    console.log('# pass ' + passes);\\n    console.log('# fail ' + failures);\\n  });\\n}\\n\\n/**\\n * Return a TAP-safe title of `test`\\n *\\n * @api private\\n * @param {Object} test\\n * @return {String}\\n */\\nfunction title(test) {\\n  return test.fullTitle().replace(/#/g, '');\\n}\\n\\n},{\\\"./base\\\":17}],34:[function(require,module,exports){\\n(function (global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Base = require('./base');\\nvar utils = require('../utils');\\nvar inherits = utils.inherits;\\nvar fs = require('fs');\\nvar escape = utils.escape;\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Expose `XUnit`.\\n */\\n\\nexports = module.exports = XUnit;\\n\\n/**\\n * Initialize a new `XUnit` reporter.\\n *\\n * @api public\\n * @param {Runner} runner\\n */\\nfunction XUnit(runner, options) {\\n  Base.call(this, runner);\\n\\n  var stats = this.stats;\\n  var tests = [];\\n  var self = this;\\n\\n  if (options.reporterOptions && options.reporterOptions.output) {\\n    if (!fs.createWriteStream) {\\n      throw new Error('file output not supported in browser');\\n    }\\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\\n  }\\n\\n  runner.on('pending', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('pass', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('fail', function(test) {\\n    tests.push(test);\\n  });\\n\\n  runner.on('end', function() {\\n    self.write(tag('testsuite', {\\n      name: 'Mocha Tests',\\n      tests: stats.tests,\\n      failures: stats.failures,\\n      errors: stats.failures,\\n      skipped: stats.tests - stats.failures - stats.passes,\\n      timestamp: (new Date()).toUTCString(),\\n      time: (stats.duration / 1000) || 0\\n    }, false));\\n\\n    tests.forEach(function(t) {\\n      self.test(t);\\n    });\\n\\n    self.write('</testsuite>');\\n  });\\n}\\n\\n/**\\n * Inherit from `Base.prototype`.\\n */\\ninherits(XUnit, Base);\\n\\n/**\\n * Override done to close the stream (if it's a file).\\n *\\n * @param failures\\n * @param {Function} fn\\n */\\nXUnit.prototype.done = function(failures, fn) {\\n  if (this.fileStream) {\\n    this.fileStream.end(function() {\\n      fn(failures);\\n    });\\n  } else {\\n    fn(failures);\\n  }\\n};\\n\\n/**\\n * Write out the given line.\\n *\\n * @param {string} line\\n */\\nXUnit.prototype.write = function(line) {\\n  if (this.fileStream) {\\n    this.fileStream.write(line + '\\\\n');\\n  } else {\\n    console.log(line);\\n  }\\n};\\n\\n/**\\n * Output tag for the given `test.`\\n *\\n * @param {Test} test\\n */\\nXUnit.prototype.test = function(test) {\\n  var attrs = {\\n    classname: test.parent.fullTitle(),\\n    name: test.title,\\n    time: (test.duration / 1000) || 0\\n  };\\n\\n  if (test.state === 'failed') {\\n    var err = test.err;\\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + '\\\\n' + err.stack))));\\n  } else if (test.pending) {\\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\\n  } else {\\n    this.write(tag('testcase', attrs, true));\\n  }\\n};\\n\\n/**\\n * HTML tag helper.\\n *\\n * @param name\\n * @param attrs\\n * @param close\\n * @param content\\n * @return {string}\\n */\\nfunction tag(name, attrs, close, content) {\\n  var end = close ? '/>' : '>';\\n  var pairs = [];\\n  var tag;\\n\\n  for (var key in attrs) {\\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\\n      pairs.push(key + '=\\\"' + escape(attrs[key]) + '\\\"');\\n    }\\n  }\\n\\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\\n  if (content) {\\n    tag += content + '</' + name + end;\\n  }\\n  return tag;\\n}\\n\\n/**\\n * Return cdata escaped CDATA `str`.\\n */\\n\\nfunction cdata(str) {\\n  return '<![CDATA[' + escape(str) + ']]>';\\n}\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../utils\\\":39,\\\"./base\\\":17,\\\"fs\\\":41}],35:[function(require,module,exports){\\n(function (global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Pending = require('./pending');\\nvar debug = require('debug')('mocha:runnable');\\nvar milliseconds = require('./ms');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\n/* eslint-disable no-unused-vars, no-native-reassign */\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n/* eslint-enable no-unused-vars, no-native-reassign */\\n\\n/**\\n * Object#toString().\\n */\\n\\nvar toString = Object.prototype.toString;\\n\\n/**\\n * Expose `Runnable`.\\n */\\n\\nmodule.exports = Runnable;\\n\\n/**\\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\\n *\\n * @param {String} title\\n * @param {Function} fn\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n */\\nfunction Runnable(title, fn) {\\n  this.title = title;\\n  this.fn = fn;\\n  this.async = fn && fn.length;\\n  this.sync = !this.async;\\n  this._timeout = 2000;\\n  this._slow = 75;\\n  this._enableTimeouts = true;\\n  this.timedOut = false;\\n  this._trace = new Error('done() called multiple times');\\n}\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Runnable, EventEmitter);\\n\\n/**\\n * Set & get timeout `ms`.\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Runnable|number} ms or Runnable instance.\\n */\\nRunnable.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this._timeout;\\n  }\\n  if (ms === 0) {\\n    this._enableTimeouts = false;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._timeout = ms;\\n  if (this.timer) {\\n    this.resetTimeout();\\n  }\\n  return this;\\n};\\n\\n/**\\n * Set & get slow `ms`.\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Runnable|number} ms or Runnable instance.\\n */\\nRunnable.prototype.slow = function(ms) {\\n  if (!arguments.length) {\\n    return this._slow;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._slow = ms;\\n  return this;\\n};\\n\\n/**\\n * Set and get whether timeout is `enabled`.\\n *\\n * @api private\\n * @param {boolean} enabled\\n * @return {Runnable|boolean} enabled or Runnable instance.\\n */\\nRunnable.prototype.enableTimeouts = function(enabled) {\\n  if (!arguments.length) {\\n    return this._enableTimeouts;\\n  }\\n  debug('enableTimeouts %s', enabled);\\n  this._enableTimeouts = enabled;\\n  return this;\\n};\\n\\n/**\\n * Halt and mark as pending.\\n *\\n * @api private\\n */\\nRunnable.prototype.skip = function() {\\n  throw new Pending();\\n};\\n\\n/**\\n * Return the full title generated by recursively concatenating the parent's\\n * full title.\\n *\\n * @api public\\n * @return {string}\\n */\\nRunnable.prototype.fullTitle = function() {\\n  return this.parent.fullTitle() + ' ' + this.title;\\n};\\n\\n/**\\n * Clear the timeout.\\n *\\n * @api private\\n */\\nRunnable.prototype.clearTimeout = function() {\\n  clearTimeout(this.timer);\\n};\\n\\n/**\\n * Inspect the runnable void of private properties.\\n *\\n * @api private\\n * @return {string}\\n */\\nRunnable.prototype.inspect = function() {\\n  return JSON.stringify(this, function(key, val) {\\n    if (key[0] === '_') {\\n      return;\\n    }\\n    if (key === 'parent') {\\n      return '#<Suite>';\\n    }\\n    if (key === 'ctx') {\\n      return '#<Context>';\\n    }\\n    return val;\\n  }, 2);\\n};\\n\\n/**\\n * Reset the timeout.\\n *\\n * @api private\\n */\\nRunnable.prototype.resetTimeout = function() {\\n  var self = this;\\n  var ms = this.timeout() || 1e9;\\n\\n  if (!this._enableTimeouts) {\\n    return;\\n  }\\n  this.clearTimeout();\\n  this.timer = setTimeout(function() {\\n    if (!self._enableTimeouts) {\\n      return;\\n    }\\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\\n    self.timedOut = true;\\n  }, ms);\\n};\\n\\n/**\\n * Whitelist a list of globals for this test run.\\n *\\n * @api private\\n * @param {string[]} globals\\n */\\nRunnable.prototype.globals = function(globals) {\\n  this._allowedGlobals = globals;\\n};\\n\\n/**\\n * Run the test and invoke `fn(err)`.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunnable.prototype.run = function(fn) {\\n  var self = this;\\n  var start = new Date();\\n  var ctx = this.ctx;\\n  var finished;\\n  var emitted;\\n\\n  // Sometimes the ctx exists, but it is not runnable\\n  if (ctx && ctx.runnable) {\\n    ctx.runnable(this);\\n  }\\n\\n  // called multiple times\\n  function multiple(err) {\\n    if (emitted) {\\n      return;\\n    }\\n    emitted = true;\\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\\n  }\\n\\n  // finished\\n  function done(err) {\\n    var ms = self.timeout();\\n    if (self.timedOut) {\\n      return;\\n    }\\n    if (finished) {\\n      return multiple(err || self._trace);\\n    }\\n\\n    self.clearTimeout();\\n    self.duration = new Date() - start;\\n    finished = true;\\n    if (!err && self.duration > ms && self._enableTimeouts) {\\n      err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\\n    }\\n    fn(err);\\n  }\\n\\n  // for .resetTimeout()\\n  this.callback = done;\\n\\n  // explicit async with `done` argument\\n  if (this.async) {\\n    this.resetTimeout();\\n\\n    if (this.allowUncaught) {\\n      return callFnAsync(this.fn);\\n    }\\n    try {\\n      callFnAsync(this.fn);\\n    } catch (err) {\\n      done(utils.getError(err));\\n    }\\n    return;\\n  }\\n\\n  if (this.allowUncaught) {\\n    callFn(this.fn);\\n    done();\\n    return;\\n  }\\n\\n  // sync or promise-returning\\n  try {\\n    if (this.pending) {\\n      done();\\n    } else {\\n      callFn(this.fn);\\n    }\\n  } catch (err) {\\n    done(utils.getError(err));\\n  }\\n\\n  function callFn(fn) {\\n    var result = fn.call(ctx);\\n    if (result && typeof result.then === 'function') {\\n      self.resetTimeout();\\n      result\\n        .then(function() {\\n          done();\\n        },\\n        function(reason) {\\n          done(reason || new Error('Promise rejected with no or falsy reason'));\\n        });\\n    } else {\\n      if (self.asyncOnly) {\\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\\n      }\\n\\n      done();\\n    }\\n  }\\n\\n  function callFnAsync(fn) {\\n    fn.call(ctx, function(err) {\\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\\n        return done(err);\\n      }\\n      if (err) {\\n        if (Object.prototype.toString.call(err) === '[object Object]') {\\n          return done(new Error('done() invoked with non-Error: '\\n            + JSON.stringify(err)));\\n        }\\n        return done(new Error('done() invoked with non-Error: ' + err));\\n      }\\n      done();\\n    });\\n  }\\n};\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./ms\\\":15,\\\"./pending\\\":16,\\\"./utils\\\":39,\\\"debug\\\":2,\\\"events\\\":3}],36:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Pending = require('./pending');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\nvar debug = require('debug')('mocha:runner');\\nvar Runnable = require('./runnable');\\nvar filter = utils.filter;\\nvar indexOf = utils.indexOf;\\nvar keys = utils.keys;\\nvar stackFilter = utils.stackTraceFilter();\\nvar stringify = utils.stringify;\\nvar type = utils.type;\\nvar undefinedError = utils.undefinedError;\\n\\n/**\\n * Non-enumerable globals.\\n */\\n\\nvar globals = [\\n  'setTimeout',\\n  'clearTimeout',\\n  'setInterval',\\n  'clearInterval',\\n  'XMLHttpRequest',\\n  'Date',\\n  'setImmediate',\\n  'clearImmediate'\\n];\\n\\n/**\\n * Expose `Runner`.\\n */\\n\\nmodule.exports = Runner;\\n\\n/**\\n * Initialize a `Runner` for the given `suite`.\\n *\\n * Events:\\n *\\n *   - `start`  execution started\\n *   - `end`  execution complete\\n *   - `suite`  (suite) test suite execution started\\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\\n *   - `test`  (test) test execution started\\n *   - `test end`  (test) test completed\\n *   - `hook`  (hook) hook execution started\\n *   - `hook end`  (hook) hook complete\\n *   - `pass`  (test) test passed\\n *   - `fail`  (test, err) test failed\\n *   - `pending`  (test) test pending\\n *\\n * @api public\\n * @param {Suite} suite Root suite\\n * @param {boolean} [delay] Whether or not to delay execution of root suite\\n * until ready.\\n */\\nfunction Runner(suite, delay) {\\n  var self = this;\\n  this._globals = [];\\n  this._abort = false;\\n  this._delay = delay;\\n  this.suite = suite;\\n  this.started = false;\\n  this.total = suite.total();\\n  this.failures = 0;\\n  this.on('test end', function(test) {\\n    self.checkGlobals(test);\\n  });\\n  this.on('hook end', function(hook) {\\n    self.checkGlobals(hook);\\n  });\\n  this._defaultGrep = /.*/;\\n  this.grep(this._defaultGrep);\\n  this.globals(this.globalProps().concat(extraGlobals()));\\n}\\n\\n/**\\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.immediately = global.setImmediate || process.nextTick;\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Runner, EventEmitter);\\n\\n/**\\n * Run tests with full titles matching `re`. Updates runner.total\\n * with number of tests matched.\\n *\\n * @param {RegExp} re\\n * @param {Boolean} invert\\n * @return {Runner} for chaining\\n * @api public\\n * @param {RegExp} re\\n * @param {boolean} invert\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.grep = function(re, invert) {\\n  debug('grep %s', re);\\n  this._grep = re;\\n  this._invert = invert;\\n  this.total = this.grepTotal(this.suite);\\n  return this;\\n};\\n\\n/**\\n * Returns the number of tests matching the grep search for the\\n * given suite.\\n *\\n * @param {Suite} suite\\n * @return {Number}\\n * @api public\\n * @param {Suite} suite\\n * @return {number}\\n */\\nRunner.prototype.grepTotal = function(suite) {\\n  var self = this;\\n  var total = 0;\\n\\n  suite.eachTest(function(test) {\\n    var match = self._grep.test(test.fullTitle());\\n    if (self._invert) {\\n      match = !match;\\n    }\\n    if (match) {\\n      total++;\\n    }\\n  });\\n\\n  return total;\\n};\\n\\n/**\\n * Return a list of global properties.\\n *\\n * @return {Array}\\n * @api private\\n */\\nRunner.prototype.globalProps = function() {\\n  var props = keys(global);\\n\\n  // non-enumerables\\n  for (var i = 0; i < globals.length; ++i) {\\n    if (~indexOf(props, globals[i])) {\\n      continue;\\n    }\\n    props.push(globals[i]);\\n  }\\n\\n  return props;\\n};\\n\\n/**\\n * Allow the given `arr` of globals.\\n *\\n * @param {Array} arr\\n * @return {Runner} for chaining\\n * @api public\\n * @param {Array} arr\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.globals = function(arr) {\\n  if (!arguments.length) {\\n    return this._globals;\\n  }\\n  debug('globals %j', arr);\\n  this._globals = this._globals.concat(arr);\\n  return this;\\n};\\n\\n/**\\n * Check for global variable leaks.\\n *\\n * @api private\\n */\\nRunner.prototype.checkGlobals = function(test) {\\n  if (this.ignoreLeaks) {\\n    return;\\n  }\\n  var ok = this._globals;\\n\\n  var globals = this.globalProps();\\n  var leaks;\\n\\n  if (test) {\\n    ok = ok.concat(test._allowedGlobals || []);\\n  }\\n\\n  if (this.prevGlobalsLength === globals.length) {\\n    return;\\n  }\\n  this.prevGlobalsLength = globals.length;\\n\\n  leaks = filterLeaks(ok, globals);\\n  this._globals = this._globals.concat(leaks);\\n\\n  if (leaks.length > 1) {\\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\\n  } else if (leaks.length) {\\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\\n  }\\n};\\n\\n/**\\n * Fail the given `test`.\\n *\\n * @api private\\n * @param {Test} test\\n * @param {Error} err\\n */\\nRunner.prototype.fail = function(test, err) {\\n  ++this.failures;\\n  test.state = 'failed';\\n\\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\\n  }\\n\\n  err.stack = (this.fullStackTrace || !err.stack)\\n    ? err.stack\\n    : stackFilter(err.stack);\\n\\n  this.emit('fail', test, err);\\n};\\n\\n/**\\n * Fail the given `hook` with `err`.\\n *\\n * Hook failures work in the following pattern:\\n * - If bail, then exit\\n * - Failed `before` hook skips all tests in a suite and subsuites,\\n *   but jumps to corresponding `after` hook\\n * - Failed `before each` hook skips remaining tests in a\\n *   suite and jumps to corresponding `after each` hook,\\n *   which is run only once\\n * - Failed `after` hook does not alter\\n *   execution order\\n * - Failed `after each` hook skips remaining tests in a\\n *   suite and subsuites, but executes other `after each`\\n *   hooks\\n *\\n * @api private\\n * @param {Hook} hook\\n * @param {Error} err\\n */\\nRunner.prototype.failHook = function(hook, err) {\\n  if (hook.ctx && hook.ctx.currentTest) {\\n    hook.originalTitle = hook.originalTitle || hook.title;\\n    hook.title = hook.originalTitle + ' for \\\"' + hook.ctx.currentTest.title + '\\\"';\\n  }\\n\\n  this.fail(hook, err);\\n  if (this.suite.bail()) {\\n    this.emit('end');\\n  }\\n};\\n\\n/**\\n * Run hook `name` callbacks and then invoke `fn()`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {Function} fn\\n */\\n\\nRunner.prototype.hook = function(name, fn) {\\n  var suite = this.suite;\\n  var hooks = suite['_' + name];\\n  var self = this;\\n\\n  function next(i) {\\n    var hook = hooks[i];\\n    if (!hook) {\\n      return fn();\\n    }\\n    self.currentRunnable = hook;\\n\\n    hook.ctx.currentTest = self.test;\\n\\n    self.emit('hook', hook);\\n\\n    if (!hook.listeners('error').length) {\\n      hook.on('error', function(err) {\\n        self.failHook(hook, err);\\n      });\\n    }\\n\\n    hook.run(function(err) {\\n      var testError = hook.error();\\n      if (testError) {\\n        self.fail(self.test, testError);\\n      }\\n      if (err) {\\n        if (err instanceof Pending) {\\n          suite.pending = true;\\n        } else {\\n          self.failHook(hook, err);\\n\\n          // stop executing hooks, notify callee of hook err\\n          return fn(err);\\n        }\\n      }\\n      self.emit('hook end', hook);\\n      delete hook.ctx.currentTest;\\n      next(++i);\\n    });\\n  }\\n\\n  Runner.immediately(function() {\\n    next(0);\\n  });\\n};\\n\\n/**\\n * Run hook `name` for the given array of `suites`\\n * in order, and callback `fn(err, errSuite)`.\\n *\\n * @api private\\n * @param {string} name\\n * @param {Array} suites\\n * @param {Function} fn\\n */\\nRunner.prototype.hooks = function(name, suites, fn) {\\n  var self = this;\\n  var orig = this.suite;\\n\\n  function next(suite) {\\n    self.suite = suite;\\n\\n    if (!suite) {\\n      self.suite = orig;\\n      return fn();\\n    }\\n\\n    self.hook(name, function(err) {\\n      if (err) {\\n        var errSuite = self.suite;\\n        self.suite = orig;\\n        return fn(err, errSuite);\\n      }\\n\\n      next(suites.pop());\\n    });\\n  }\\n\\n  next(suites.pop());\\n};\\n\\n/**\\n * Run hooks from the top level down.\\n *\\n * @param {String} name\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.hookUp = function(name, fn) {\\n  var suites = [this.suite].concat(this.parents()).reverse();\\n  this.hooks(name, suites, fn);\\n};\\n\\n/**\\n * Run hooks from the bottom up.\\n *\\n * @param {String} name\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.hookDown = function(name, fn) {\\n  var suites = [this.suite].concat(this.parents());\\n  this.hooks(name, suites, fn);\\n};\\n\\n/**\\n * Return an array of parent Suites from\\n * closest to furthest.\\n *\\n * @return {Array}\\n * @api private\\n */\\nRunner.prototype.parents = function() {\\n  var suite = this.suite;\\n  var suites = [];\\n  while (suite.parent) {\\n    suite = suite.parent;\\n    suites.push(suite);\\n  }\\n  return suites;\\n};\\n\\n/**\\n * Run the current test and callback `fn(err)`.\\n *\\n * @param {Function} fn\\n * @api private\\n */\\nRunner.prototype.runTest = function(fn) {\\n  var self = this;\\n  var test = this.test;\\n\\n  if (this.asyncOnly) {\\n    test.asyncOnly = true;\\n  }\\n\\n  if (this.allowUncaught) {\\n    test.allowUncaught = true;\\n    return test.run(fn);\\n  }\\n  try {\\n    test.on('error', function(err) {\\n      self.fail(test, err);\\n    });\\n    test.run(fn);\\n  } catch (err) {\\n    fn(err);\\n  }\\n};\\n\\n/**\\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @param {Function} fn\\n */\\nRunner.prototype.runTests = function(suite, fn) {\\n  var self = this;\\n  var tests = suite.tests.slice();\\n  var test;\\n\\n  function hookErr(_, errSuite, after) {\\n    // before/after Each hook for errSuite failed:\\n    var orig = self.suite;\\n\\n    // for failed 'after each' hook start from errSuite parent,\\n    // otherwise start from errSuite itself\\n    self.suite = after ? errSuite.parent : errSuite;\\n\\n    if (self.suite) {\\n      // call hookUp afterEach\\n      self.hookUp('afterEach', function(err2, errSuite2) {\\n        self.suite = orig;\\n        // some hooks may fail even now\\n        if (err2) {\\n          return hookErr(err2, errSuite2, true);\\n        }\\n        // report error suite\\n        fn(errSuite);\\n      });\\n    } else {\\n      // there is no need calling other 'after each' hooks\\n      self.suite = orig;\\n      fn(errSuite);\\n    }\\n  }\\n\\n  function next(err, errSuite) {\\n    // if we bail after first err\\n    if (self.failures && suite._bail) {\\n      return fn();\\n    }\\n\\n    if (self._abort) {\\n      return fn();\\n    }\\n\\n    if (err) {\\n      return hookErr(err, errSuite, true);\\n    }\\n\\n    // next test\\n    test = tests.shift();\\n\\n    // all done\\n    if (!test) {\\n      return fn();\\n    }\\n\\n    // grep\\n    var match = self._grep.test(test.fullTitle());\\n    if (self._invert) {\\n      match = !match;\\n    }\\n    if (!match) {\\n      // Run immediately only if we have defined a grep. When we\\n      // define a grep — It can cause maximum callstack error if\\n      // the grep is doing a large recursive loop by neglecting\\n      // all tests. The run immediately function also comes with\\n      // a performance cost. So we don't want to run immediately\\n      // if we run the whole test suite, because running the whole\\n      // test suite don't do any immediate recursive loops. Thus,\\n      // allowing a JS runtime to breathe.\\n      if (self._grep !== self._defaultGrep) {\\n        Runner.immediately(next);\\n      } else {\\n        next();\\n      }\\n      return;\\n    }\\n\\n    // pending\\n    if (test.pending) {\\n      self.emit('pending', test);\\n      self.emit('test end', test);\\n      return next();\\n    }\\n\\n    // execute test and hook(s)\\n    self.emit('test', self.test = test);\\n    self.hookDown('beforeEach', function(err, errSuite) {\\n      if (suite.pending) {\\n        self.emit('pending', test);\\n        self.emit('test end', test);\\n        return next();\\n      }\\n      if (err) {\\n        return hookErr(err, errSuite, false);\\n      }\\n      self.currentRunnable = self.test;\\n      self.runTest(function(err) {\\n        test = self.test;\\n\\n        if (err) {\\n          if (err instanceof Pending) {\\n            self.emit('pending', test);\\n          } else {\\n            self.fail(test, err);\\n          }\\n          self.emit('test end', test);\\n\\n          if (err instanceof Pending) {\\n            return next();\\n          }\\n\\n          return self.hookUp('afterEach', next);\\n        }\\n\\n        test.state = 'passed';\\n        self.emit('pass', test);\\n        self.emit('test end', test);\\n        self.hookUp('afterEach', next);\\n      });\\n    });\\n  }\\n\\n  this.next = next;\\n  this.hookErr = hookErr;\\n  next();\\n};\\n\\n/**\\n * Run the given `suite` and invoke the callback `fn()` when complete.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @param {Function} fn\\n */\\nRunner.prototype.runSuite = function(suite, fn) {\\n  var i = 0;\\n  var self = this;\\n  var total = this.grepTotal(suite);\\n  var afterAllHookCalled = false;\\n\\n  debug('run suite %s', suite.fullTitle());\\n\\n  if (!total || (self.failures && suite._bail)) {\\n    return fn();\\n  }\\n\\n  this.emit('suite', this.suite = suite);\\n\\n  function next(errSuite) {\\n    if (errSuite) {\\n      // current suite failed on a hook from errSuite\\n      if (errSuite === suite) {\\n        // if errSuite is current suite\\n        // continue to the next sibling suite\\n        return done();\\n      }\\n      // errSuite is among the parents of current suite\\n      // stop execution of errSuite and all sub-suites\\n      return done(errSuite);\\n    }\\n\\n    if (self._abort) {\\n      return done();\\n    }\\n\\n    var curr = suite.suites[i++];\\n    if (!curr) {\\n      return done();\\n    }\\n\\n    // Avoid grep neglecting large number of tests causing a\\n    // huge recursive loop and thus a maximum call stack error.\\n    // See comment in `this.runTests()` for more information.\\n    if (self._grep !== self._defaultGrep) {\\n      Runner.immediately(function() {\\n        self.runSuite(curr, next);\\n      });\\n    } else {\\n      self.runSuite(curr, next);\\n    }\\n  }\\n\\n  function done(errSuite) {\\n    self.suite = suite;\\n    self.nextSuite = next;\\n\\n    if (afterAllHookCalled) {\\n      fn(errSuite);\\n    } else {\\n      // mark that the afterAll block has been called once\\n      // and so can be skipped if there is an error in it.\\n      afterAllHookCalled = true;\\n      self.hook('afterAll', function() {\\n        self.emit('suite end', suite);\\n        fn(errSuite);\\n      });\\n    }\\n  }\\n\\n  this.nextSuite = next;\\n\\n  this.hook('beforeAll', function(err) {\\n    if (err) {\\n      return done();\\n    }\\n    self.runTests(suite, next);\\n  });\\n};\\n\\n/**\\n * Handle uncaught exceptions.\\n *\\n * @param {Error} err\\n * @api private\\n */\\nRunner.prototype.uncaught = function(err) {\\n  if (err) {\\n    debug('uncaught exception %s', err !== function() {\\n      return this;\\n    }.call(err) ? err : (err.message || err));\\n  } else {\\n    debug('uncaught undefined exception');\\n    err = undefinedError();\\n  }\\n  err.uncaught = true;\\n\\n  var runnable = this.currentRunnable;\\n\\n  if (!runnable) {\\n    runnable = new Runnable('Uncaught error outside test suite');\\n    runnable.parent = this.suite;\\n\\n    if (this.started) {\\n      this.fail(runnable, err);\\n    } else {\\n      // Can't recover from this failure\\n      this.emit('start');\\n      this.fail(runnable, err);\\n      this.emit('end');\\n    }\\n\\n    return;\\n  }\\n\\n  runnable.clearTimeout();\\n\\n  // Ignore errors if complete\\n  if (runnable.state) {\\n    return;\\n  }\\n  this.fail(runnable, err);\\n\\n  // recover from test\\n  if (runnable.type === 'test') {\\n    this.emit('test end', runnable);\\n    this.hookUp('afterEach', this.next);\\n    return;\\n  }\\n\\n // recover from hooks\\n  if (runnable.type === 'hook') {\\n    var errSuite = this.suite;\\n    // if hook failure is in afterEach block\\n    if (runnable.fullTitle().indexOf('after each') > -1) {\\n      return this.hookErr(err, errSuite, true);\\n    }\\n    // if hook failure is in beforeEach block\\n    if (runnable.fullTitle().indexOf('before each') > -1) {\\n      return this.hookErr(err, errSuite, false);\\n    }\\n    // if hook failure is in after or before blocks\\n    return this.nextSuite(errSuite);\\n  }\\n\\n  // bail\\n  this.emit('end');\\n};\\n\\n/**\\n * Run the root suite and invoke `fn(failures)`\\n * on completion.\\n *\\n * @param {Function} fn\\n * @return {Runner} for chaining\\n * @api public\\n * @param {Function} fn\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.run = function(fn) {\\n  var self = this;\\n  var rootSuite = this.suite;\\n\\n  fn = fn || function() {};\\n\\n  function uncaught(err) {\\n    self.uncaught(err);\\n  }\\n\\n  function start() {\\n    self.started = true;\\n    self.emit('start');\\n    self.runSuite(rootSuite, function() {\\n      debug('finished running');\\n      self.emit('end');\\n    });\\n  }\\n\\n  debug('start');\\n\\n  // callback\\n  this.on('end', function() {\\n    debug('end');\\n    process.removeListener('uncaughtException', uncaught);\\n    fn(self.failures);\\n  });\\n\\n  // uncaught exception\\n  process.on('uncaughtException', uncaught);\\n\\n  if (this._delay) {\\n    // for reporters, I guess.\\n    // might be nice to debounce some dots while we wait.\\n    this.emit('waiting', rootSuite);\\n    rootSuite.once('run', start);\\n  } else {\\n    start();\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Cleanly abort execution.\\n *\\n * @api public\\n * @return {Runner} Runner instance.\\n */\\nRunner.prototype.abort = function() {\\n  debug('aborting');\\n  this._abort = true;\\n\\n  return this;\\n};\\n\\n/**\\n * Filter leaks with the given globals flagged as `ok`.\\n *\\n * @api private\\n * @param {Array} ok\\n * @param {Array} globals\\n * @return {Array}\\n */\\nfunction filterLeaks(ok, globals) {\\n  return filter(globals, function(key) {\\n    // Firefox and Chrome exposes iframes as index inside the window object\\n    if (/^d+/.test(key)) {\\n      return false;\\n    }\\n\\n    // in firefox\\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\\n    // it is assigned in some seconds\\n    if (global.navigator && (/^getInterface/).test(key)) {\\n      return false;\\n    }\\n\\n    // an iframe could be approached by window[iframeIndex]\\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\\n    if (global.navigator && (/^\\\\d+/).test(key)) {\\n      return false;\\n    }\\n\\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\\n    if (/^mocha-/.test(key)) {\\n      return false;\\n    }\\n\\n    var matched = filter(ok, function(ok) {\\n      if (~ok.indexOf('*')) {\\n        return key.indexOf(ok.split('*')[0]) === 0;\\n      }\\n      return key === ok;\\n    });\\n    return !matched.length && (!global.navigator || key !== 'onerror');\\n  });\\n}\\n\\n/**\\n * Array of globals dependent on the environment.\\n *\\n * @return {Array}\\n * @api private\\n */\\nfunction extraGlobals() {\\n  if (typeof process === 'object' && typeof process.version === 'string') {\\n    var parts = process.version.split('.');\\n    var nodeVersion = utils.reduce(parts, function(a, v) {\\n      return a << 8 | v;\\n    });\\n\\n    // 'errno' was renamed to process._errno in v0.9.11.\\n\\n    if (nodeVersion < 0x00090B) {\\n      return ['errno'];\\n    }\\n  }\\n\\n  return [];\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./pending\\\":16,\\\"./runnable\\\":35,\\\"./utils\\\":39,\\\"_process\\\":51,\\\"debug\\\":2,\\\"events\\\":3}],37:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar EventEmitter = require('events').EventEmitter;\\nvar Hook = require('./hook');\\nvar utils = require('./utils');\\nvar inherits = utils.inherits;\\nvar debug = require('debug')('mocha:suite');\\nvar milliseconds = require('./ms');\\n\\n/**\\n * Expose `Suite`.\\n */\\n\\nexports = module.exports = Suite;\\n\\n/**\\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\\n * with the same title is already present, that suite is returned to provide\\n * nicer reporter and more flexible meta-testing.\\n *\\n * @api public\\n * @param {Suite} parent\\n * @param {string} title\\n * @return {Suite}\\n */\\nexports.create = function(parent, title) {\\n  var suite = new Suite(title, parent.ctx);\\n  suite.parent = parent;\\n  if (parent.pending) {\\n    suite.pending = true;\\n  }\\n  title = suite.fullTitle();\\n  parent.addSuite(suite);\\n  return suite;\\n};\\n\\n/**\\n * Initialize a new `Suite` with the given `title` and `ctx`.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Context} parentContext\\n */\\nfunction Suite(title, parentContext) {\\n  this.title = title;\\n  function Context() {}\\n  Context.prototype = parentContext;\\n  this.ctx = new Context();\\n  this.suites = [];\\n  this.tests = [];\\n  this.pending = false;\\n  this._beforeEach = [];\\n  this._beforeAll = [];\\n  this._afterEach = [];\\n  this._afterAll = [];\\n  this.root = !title;\\n  this._timeout = 2000;\\n  this._enableTimeouts = true;\\n  this._slow = 75;\\n  this._bail = false;\\n  this.delayed = false;\\n}\\n\\n/**\\n * Inherit from `EventEmitter.prototype`.\\n */\\ninherits(Suite, EventEmitter);\\n\\n/**\\n * Return a clone of this `Suite`.\\n *\\n * @api private\\n * @return {Suite}\\n */\\nSuite.prototype.clone = function() {\\n  var suite = new Suite(this.title);\\n  debug('clone');\\n  suite.ctx = this.ctx;\\n  suite.timeout(this.timeout());\\n  suite.enableTimeouts(this.enableTimeouts());\\n  suite.slow(this.slow());\\n  suite.bail(this.bail());\\n  return suite;\\n};\\n\\n/**\\n * Set timeout `ms` or short-hand such as \\\"2s\\\".\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.timeout = function(ms) {\\n  if (!arguments.length) {\\n    return this._timeout;\\n  }\\n  if (ms.toString() === '0') {\\n    this._enableTimeouts = false;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('timeout %d', ms);\\n  this._timeout = parseInt(ms, 10);\\n  return this;\\n};\\n\\n/**\\n  * Set timeout to `enabled`.\\n  *\\n  * @api private\\n  * @param {boolean} enabled\\n  * @return {Suite|boolean} self or enabled\\n  */\\nSuite.prototype.enableTimeouts = function(enabled) {\\n  if (!arguments.length) {\\n    return this._enableTimeouts;\\n  }\\n  debug('enableTimeouts %s', enabled);\\n  this._enableTimeouts = enabled;\\n  return this;\\n};\\n\\n/**\\n * Set slow `ms` or short-hand such as \\\"2s\\\".\\n *\\n * @api private\\n * @param {number|string} ms\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.slow = function(ms) {\\n  if (!arguments.length) {\\n    return this._slow;\\n  }\\n  if (typeof ms === 'string') {\\n    ms = milliseconds(ms);\\n  }\\n  debug('slow %d', ms);\\n  this._slow = ms;\\n  return this;\\n};\\n\\n/**\\n * Sets whether to bail after first error.\\n *\\n * @api private\\n * @param {boolean} bail\\n * @return {Suite|number} for chaining\\n */\\nSuite.prototype.bail = function(bail) {\\n  if (!arguments.length) {\\n    return this._bail;\\n  }\\n  debug('bail %s', bail);\\n  this._bail = bail;\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` before running tests.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.beforeAll = function(title, fn) {\\n  if (this.pending) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"before all\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._beforeAll.push(hook);\\n  this.emit('beforeAll', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` after running tests.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.afterAll = function(title, fn) {\\n  if (this.pending) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"after all\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._afterAll.push(hook);\\n  this.emit('afterAll', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` before each test case.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.beforeEach = function(title, fn) {\\n  if (this.pending) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"before each\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._beforeEach.push(hook);\\n  this.emit('beforeEach', hook);\\n  return this;\\n};\\n\\n/**\\n * Run `fn(test[, done])` after each test case.\\n *\\n * @api private\\n * @param {string} title\\n * @param {Function} fn\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.afterEach = function(title, fn) {\\n  if (this.pending) {\\n    return this;\\n  }\\n  if (typeof title === 'function') {\\n    fn = title;\\n    title = fn.name;\\n  }\\n  title = '\\\"after each\\\" hook' + (title ? ': ' + title : '');\\n\\n  var hook = new Hook(title, fn);\\n  hook.parent = this;\\n  hook.timeout(this.timeout());\\n  hook.enableTimeouts(this.enableTimeouts());\\n  hook.slow(this.slow());\\n  hook.ctx = this.ctx;\\n  this._afterEach.push(hook);\\n  this.emit('afterEach', hook);\\n  return this;\\n};\\n\\n/**\\n * Add a test `suite`.\\n *\\n * @api private\\n * @param {Suite} suite\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.addSuite = function(suite) {\\n  suite.parent = this;\\n  suite.timeout(this.timeout());\\n  suite.enableTimeouts(this.enableTimeouts());\\n  suite.slow(this.slow());\\n  suite.bail(this.bail());\\n  this.suites.push(suite);\\n  this.emit('suite', suite);\\n  return this;\\n};\\n\\n/**\\n * Add a `test` to this suite.\\n *\\n * @api private\\n * @param {Test} test\\n * @return {Suite} for chaining\\n */\\nSuite.prototype.addTest = function(test) {\\n  test.parent = this;\\n  test.timeout(this.timeout());\\n  test.enableTimeouts(this.enableTimeouts());\\n  test.slow(this.slow());\\n  test.ctx = this.ctx;\\n  this.tests.push(test);\\n  this.emit('test', test);\\n  return this;\\n};\\n\\n/**\\n * Return the full title generated by recursively concatenating the parent's\\n * full title.\\n *\\n * @api public\\n * @return {string}\\n */\\nSuite.prototype.fullTitle = function() {\\n  if (this.parent) {\\n    var full = this.parent.fullTitle();\\n    if (full) {\\n      return full + ' ' + this.title;\\n    }\\n  }\\n  return this.title;\\n};\\n\\n/**\\n * Return the total number of tests.\\n *\\n * @api public\\n * @return {number}\\n */\\nSuite.prototype.total = function() {\\n  return utils.reduce(this.suites, function(sum, suite) {\\n    return sum + suite.total();\\n  }, 0) + this.tests.length;\\n};\\n\\n/**\\n * Iterates through each suite recursively to find all tests. Applies a\\n * function in the format `fn(test)`.\\n *\\n * @api private\\n * @param {Function} fn\\n * @return {Suite}\\n */\\nSuite.prototype.eachTest = function(fn) {\\n  utils.forEach(this.tests, fn);\\n  utils.forEach(this.suites, function(suite) {\\n    suite.eachTest(fn);\\n  });\\n  return this;\\n};\\n\\n/**\\n * This will run the root suite if we happen to be running in delayed mode.\\n */\\nSuite.prototype.run = function run() {\\n  if (this.root) {\\n    this.emit('run');\\n  }\\n};\\n\\n},{\\\"./hook\\\":7,\\\"./ms\\\":15,\\\"./utils\\\":39,\\\"debug\\\":2,\\\"events\\\":3}],38:[function(require,module,exports){\\n/**\\n * Module dependencies.\\n */\\n\\nvar Runnable = require('./runnable');\\nvar inherits = require('./utils').inherits;\\n\\n/**\\n * Expose `Test`.\\n */\\n\\nmodule.exports = Test;\\n\\n/**\\n * Initialize a new `Test` with the given `title` and callback `fn`.\\n *\\n * @api private\\n * @param {String} title\\n * @param {Function} fn\\n */\\nfunction Test(title, fn) {\\n  Runnable.call(this, title, fn);\\n  this.pending = !fn;\\n  this.type = 'test';\\n}\\n\\n/**\\n * Inherit from `Runnable.prototype`.\\n */\\ninherits(Test, Runnable);\\n\\n},{\\\"./runnable\\\":35,\\\"./utils\\\":39}],39:[function(require,module,exports){\\n(function (process,Buffer){\\n/* eslint-env browser */\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar basename = require('path').basename;\\nvar debug = require('debug')('mocha:watch');\\nvar exists = require('fs').existsSync || require('path').existsSync;\\nvar glob = require('glob');\\nvar join = require('path').join;\\nvar readdirSync = require('fs').readdirSync;\\nvar statSync = require('fs').statSync;\\nvar watchFile = require('fs').watchFile;\\n\\n/**\\n * Ignored directories.\\n */\\n\\nvar ignore = ['node_modules', '.git'];\\n\\nexports.inherits = require('util').inherits;\\n\\n/**\\n * Escape special characters in the given string of html.\\n *\\n * @api private\\n * @param  {string} html\\n * @return {string}\\n */\\nexports.escape = function(html) {\\n  return String(html)\\n    .replace(/&/g, '&amp;')\\n    .replace(/\\\"/g, '&quot;')\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;');\\n};\\n\\n/**\\n * Array#forEach (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} scope\\n */\\nexports.forEach = function(arr, fn, scope) {\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    fn.call(scope, arr[i], i);\\n  }\\n};\\n\\n/**\\n * Test if the given obj is type of string.\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {boolean}\\n */\\nexports.isString = function(obj) {\\n  return typeof obj === 'string';\\n};\\n\\n/**\\n * Array#map (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} scope\\n * @return {Array}\\n */\\nexports.map = function(arr, fn, scope) {\\n  var result = [];\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    result.push(fn.call(scope, arr[i], i, arr));\\n  }\\n  return result;\\n};\\n\\n/**\\n * Array#indexOf (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Object} obj to find index of\\n * @param {number} start\\n * @return {number}\\n */\\nexports.indexOf = function(arr, obj, start) {\\n  for (var i = start || 0, l = arr.length; i < l; i++) {\\n    if (arr[i] === obj) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n};\\n\\n/**\\n * Array#reduce (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @param {Object} val Initial value.\\n * @return {*}\\n */\\nexports.reduce = function(arr, fn, val) {\\n  var rval = val;\\n\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    rval = fn(rval, arr[i], i, arr);\\n  }\\n\\n  return rval;\\n};\\n\\n/**\\n * Array#filter (<=IE8)\\n *\\n * @api private\\n * @param {Array} arr\\n * @param {Function} fn\\n * @return {Array}\\n */\\nexports.filter = function(arr, fn) {\\n  var ret = [];\\n\\n  for (var i = 0, l = arr.length; i < l; i++) {\\n    var val = arr[i];\\n    if (fn(val, i, arr)) {\\n      ret.push(val);\\n    }\\n  }\\n\\n  return ret;\\n};\\n\\n/**\\n * Object.keys (<=IE8)\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {Array} keys\\n */\\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function(obj) {\\n  var keys = [];\\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\\n\\n  for (var key in obj) {\\n    if (has.call(obj, key)) {\\n      keys.push(key);\\n    }\\n  }\\n\\n  return keys;\\n};\\n\\n/**\\n * Watch the given `files` for changes\\n * and invoke `fn(file)` on modification.\\n *\\n * @api private\\n * @param {Array} files\\n * @param {Function} fn\\n */\\nexports.watch = function(files, fn) {\\n  var options = { interval: 100 };\\n  files.forEach(function(file) {\\n    debug('file %s', file);\\n    watchFile(file, options, function(curr, prev) {\\n      if (prev.mtime < curr.mtime) {\\n        fn(file);\\n      }\\n    });\\n  });\\n};\\n\\n/**\\n * Array.isArray (<=IE8)\\n *\\n * @api private\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\\n  return Object.prototype.toString.call(obj) === '[object Array]';\\n};\\n\\n/**\\n * Buffer.prototype.toJSON polyfill.\\n *\\n * @type {Function}\\n */\\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function() {\\n    return Array.prototype.slice.call(this, 0);\\n  };\\n}\\n\\n/**\\n * Ignored files.\\n *\\n * @api private\\n * @param {string} path\\n * @return {boolean}\\n */\\nfunction ignored(path) {\\n  return !~ignore.indexOf(path);\\n}\\n\\n/**\\n * Lookup files in the given `dir`.\\n *\\n * @api private\\n * @param {string} dir\\n * @param {string[]} [ext=['.js']]\\n * @param {Array} [ret=[]]\\n * @return {Array}\\n */\\nexports.files = function(dir, ext, ret) {\\n  ret = ret || [];\\n  ext = ext || ['js'];\\n\\n  var re = new RegExp('\\\\\\\\.(' + ext.join('|') + ')$');\\n\\n  readdirSync(dir)\\n    .filter(ignored)\\n    .forEach(function(path) {\\n      path = join(dir, path);\\n      if (statSync(path).isDirectory()) {\\n        exports.files(path, ext, ret);\\n      } else if (path.match(re)) {\\n        ret.push(path);\\n      }\\n    });\\n\\n  return ret;\\n};\\n\\n/**\\n * Compute a slug from the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nexports.slug = function(str) {\\n  return str\\n    .toLowerCase()\\n    .replace(/ +/g, '-')\\n    .replace(/[^-\\\\w]/g, '');\\n};\\n\\n/**\\n * Strip the function definition from `str`, and re-indent for pre whitespace.\\n *\\n * @param {string} str\\n * @return {string}\\n */\\nexports.clean = function(str) {\\n  str = str\\n    .replace(/\\\\r\\\\n?|[\\\\n\\\\u2028\\\\u2029]/g, '\\\\n').replace(/^\\\\uFEFF/, '')\\n    .replace(/^function *\\\\(.*\\\\)\\\\s*{|\\\\(.*\\\\) *=> *{?/, '')\\n    .replace(/\\\\s+\\\\}$/, '');\\n\\n  var spaces = str.match(/^\\\\n?( *)/)[1].length;\\n  var tabs = str.match(/^\\\\n?(\\\\t*)/)[1].length;\\n  var re = new RegExp('^\\\\n?' + (tabs ? '\\\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\\n\\n  str = str.replace(re, '');\\n\\n  return exports.trim(str);\\n};\\n\\n/**\\n * Trim the given `str`.\\n *\\n * @api private\\n * @param {string} str\\n * @return {string}\\n */\\nexports.trim = function(str) {\\n  return str.replace(/^\\\\s+|\\\\s+$/g, '');\\n};\\n\\n/**\\n * Parse the given `qs`.\\n *\\n * @api private\\n * @param {string} qs\\n * @return {Object}\\n */\\nexports.parseQuery = function(qs) {\\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair) {\\n    var i = pair.indexOf('=');\\n    var key = pair.slice(0, i);\\n    var val = pair.slice(++i);\\n\\n    obj[key] = decodeURIComponent(val);\\n    return obj;\\n  }, {});\\n};\\n\\n/**\\n * Highlight the given string of `js`.\\n *\\n * @api private\\n * @param {string} js\\n * @return {string}\\n */\\nfunction highlight(js) {\\n  return js\\n    .replace(/</g, '&lt;')\\n    .replace(/>/g, '&gt;')\\n    .replace(/\\\\/\\\\/(.*)/gm, '<span class=\\\"comment\\\">//$1</span>')\\n    .replace(/('.*?')/gm, '<span class=\\\"string\\\">$1</span>')\\n    .replace(/(\\\\d+\\\\.\\\\d+)/gm, '<span class=\\\"number\\\">$1</span>')\\n    .replace(/(\\\\d+)/gm, '<span class=\\\"number\\\">$1</span>')\\n    .replace(/\\\\bnew[ \\\\t]+(\\\\w+)/gm, '<span class=\\\"keyword\\\">new</span> <span class=\\\"init\\\">$1</span>')\\n    .replace(/\\\\b(function|new|throw|return|var|if|else)\\\\b/gm, '<span class=\\\"keyword\\\">$1</span>');\\n}\\n\\n/**\\n * Highlight the contents of tag `name`.\\n *\\n * @api private\\n * @param {string} name\\n */\\nexports.highlightTags = function(name) {\\n  var code = document.getElementById('mocha').getElementsByTagName(name);\\n  for (var i = 0, len = code.length; i < len; ++i) {\\n    code[i].innerHTML = highlight(code[i].innerHTML);\\n  }\\n};\\n\\n/**\\n * If a value could have properties, and has none, this function is called,\\n * which returns a string representation of the empty value.\\n *\\n * Functions w/ no properties return `'[Function]'`\\n * Arrays w/ length === 0 return `'[]'`\\n * Objects w/ no properties return `'{}'`\\n * All else: return result of `value.toString()`\\n *\\n * @api private\\n * @param {*} value The value to inspect.\\n * @param {string} [type] The type of the value, if known.\\n * @returns {string}\\n */\\nfunction emptyRepresentation(value, type) {\\n  type = type || exports.type(value);\\n\\n  switch (type) {\\n    case 'function':\\n      return '[Function]';\\n    case 'object':\\n      return '{}';\\n    case 'array':\\n      return '[]';\\n    default:\\n      return value.toString();\\n  }\\n}\\n\\n/**\\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\\n * is.\\n *\\n * @api private\\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\\n * @param {*} value The value to test.\\n * @returns {string}\\n * @example\\n * type({}) // 'object'\\n * type([]) // 'array'\\n * type(1) // 'number'\\n * type(false) // 'boolean'\\n * type(Infinity) // 'number'\\n * type(null) // 'null'\\n * type(new Date()) // 'date'\\n * type(/foo/) // 'regexp'\\n * type('type') // 'string'\\n * type(global) // 'global'\\n */\\nexports.type = function type(value) {\\n  if (value === undefined) {\\n    return 'undefined';\\n  } else if (value === null) {\\n    return 'null';\\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\\n    return 'buffer';\\n  }\\n  return Object.prototype.toString.call(value)\\n    .replace(/^\\\\[.+\\\\s(.+?)\\\\]$/, '$1')\\n    .toLowerCase();\\n};\\n\\n/**\\n * Stringify `value`. Different behavior depending on type of value:\\n *\\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\\n * - If `value` is an *empty* object, function, or array, return result of function\\n *   {@link emptyRepresentation}.\\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\\n *   JSON.stringify().\\n *\\n * @api private\\n * @see exports.type\\n * @param {*} value\\n * @return {string}\\n */\\nexports.stringify = function(value) {\\n  var type = exports.type(value);\\n\\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\\n    if (type !== 'buffer') {\\n      return jsonStringify(value);\\n    }\\n    var json = value.toJSON();\\n    // Based on the toJSON result\\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\\n      .replace(/,(\\\\n|$)/g, '$1');\\n  }\\n\\n  for (var prop in value) {\\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\\\n|$)/g, '$1');\\n    }\\n  }\\n\\n  return emptyRepresentation(value, type);\\n};\\n\\n/**\\n * like JSON.stringify but more sense.\\n *\\n * @api private\\n * @param {Object}  object\\n * @param {number=} spaces\\n * @param {number=} depth\\n * @returns {*}\\n */\\nfunction jsonStringify(object, spaces, depth) {\\n  if (typeof spaces === 'undefined') {\\n    // primitive types\\n    return _stringify(object);\\n  }\\n\\n  depth = depth || 1;\\n  var space = spaces * depth;\\n  var str = isArray(object) ? '[' : '{';\\n  var end = isArray(object) ? ']' : '}';\\n  var length = object.length || exports.keys(object).length;\\n  // `.repeat()` polyfill\\n  function repeat(s, n) {\\n    return new Array(n).join(s);\\n  }\\n\\n  function _stringify(val) {\\n    switch (exports.type(val)) {\\n      case 'null':\\n      case 'undefined':\\n        val = '[' + val + ']';\\n        break;\\n      case 'array':\\n      case 'object':\\n        val = jsonStringify(val, spaces, depth + 1);\\n        break;\\n      case 'boolean':\\n      case 'regexp':\\n      case 'number':\\n        val = val === 0 && (1 / val) === -Infinity // `-0`\\n          ? '-0'\\n          : val.toString();\\n        break;\\n      case 'date':\\n        var sDate = isNaN(val.getTime())        // Invalid date\\n          ? val.toString()\\n          : val.toISOString();\\n        val = '[Date: ' + sDate + ']';\\n        break;\\n      case 'buffer':\\n        var json = val.toJSON();\\n        // Based on the toJSON result\\n        json = json.data && json.type ? json.data : json;\\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\\n        break;\\n      default:\\n        val = (val === '[Function]' || val === '[Circular]')\\n          ? val\\n          : JSON.stringify(val); // string\\n    }\\n    return val;\\n  }\\n\\n  for (var i in object) {\\n    if (!object.hasOwnProperty(i)) {\\n      continue; // not my business\\n    }\\n    --length;\\n    str += '\\\\n ' + repeat(' ', space)\\n      + (isArray(object) ? '' : '\\\"' + i + '\\\": ') // key\\n      + _stringify(object[i])                     // value\\n      + (length ? ',' : '');                     // comma\\n  }\\n\\n  return str\\n    // [], {}\\n    + (str.length !== 1 ? '\\\\n' + repeat(' ', --space) + end : end);\\n}\\n\\n/**\\n * Test if a value is a buffer.\\n *\\n * @api private\\n * @param {*} value The value to test.\\n * @return {boolean} True if `value` is a buffer, otherwise false\\n */\\nexports.isBuffer = function(value) {\\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\\n};\\n\\n/**\\n * Return a new Thing that has the keys in sorted order. Recursive.\\n *\\n * If the Thing...\\n * - has already been seen, return string `'[Circular]'`\\n * - is `undefined`, return string `'[undefined]'`\\n * - is `null`, return value `null`\\n * - is some other primitive, return the value\\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\\n *\\n * @api private\\n * @see {@link exports.stringify}\\n * @param {*} value Thing to inspect.  May or may not have properties.\\n * @param {Array} [stack=[]] Stack of seen values\\n * @return {(Object|Array|Function|string|undefined)}\\n */\\nexports.canonicalize = function(value, stack) {\\n  var canonicalizedObj;\\n  /* eslint-disable no-unused-vars */\\n  var prop;\\n  /* eslint-enable no-unused-vars */\\n  var type = exports.type(value);\\n  function withStack(value, fn) {\\n    stack.push(value);\\n    fn();\\n    stack.pop();\\n  }\\n\\n  stack = stack || [];\\n\\n  if (exports.indexOf(stack, value) !== -1) {\\n    return '[Circular]';\\n  }\\n\\n  switch (type) {\\n    case 'undefined':\\n    case 'buffer':\\n    case 'null':\\n      canonicalizedObj = value;\\n      break;\\n    case 'array':\\n      withStack(value, function() {\\n        canonicalizedObj = exports.map(value, function(item) {\\n          return exports.canonicalize(item, stack);\\n        });\\n      });\\n      break;\\n    case 'function':\\n      /* eslint-disable guard-for-in */\\n      for (prop in value) {\\n        canonicalizedObj = {};\\n        break;\\n      }\\n      /* eslint-enable guard-for-in */\\n      if (!canonicalizedObj) {\\n        canonicalizedObj = emptyRepresentation(value, type);\\n        break;\\n      }\\n    /* falls through */\\n    case 'object':\\n      canonicalizedObj = canonicalizedObj || {};\\n      withStack(value, function() {\\n        exports.forEach(exports.keys(value).sort(), function(key) {\\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\\n        });\\n      });\\n      break;\\n    case 'date':\\n    case 'number':\\n    case 'regexp':\\n    case 'boolean':\\n      canonicalizedObj = value;\\n      break;\\n    default:\\n      canonicalizedObj = value.toString();\\n  }\\n\\n  return canonicalizedObj;\\n};\\n\\n/**\\n * Lookup file names at the given `path`.\\n *\\n * @api public\\n * @param {string} path Base path to start searching from.\\n * @param {string[]} extensions File extensions to look for.\\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\\n * @return {string[]} An array of paths.\\n */\\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\\n  var files = [];\\n  var re = new RegExp('\\\\\\\\.(' + extensions.join('|') + ')$');\\n\\n  if (!exists(path)) {\\n    if (exists(path + '.js')) {\\n      path += '.js';\\n    } else {\\n      files = glob.sync(path);\\n      if (!files.length) {\\n        throw new Error(\\\"cannot resolve path (or pattern) '\\\" + path + \\\"'\\\");\\n      }\\n      return files;\\n    }\\n  }\\n\\n  try {\\n    var stat = statSync(path);\\n    if (stat.isFile()) {\\n      return path;\\n    }\\n  } catch (err) {\\n    // ignore error\\n    return;\\n  }\\n\\n  readdirSync(path).forEach(function(file) {\\n    file = join(path, file);\\n    try {\\n      var stat = statSync(file);\\n      if (stat.isDirectory()) {\\n        if (recursive) {\\n          files = files.concat(lookupFiles(file, extensions, recursive));\\n        }\\n        return;\\n      }\\n    } catch (err) {\\n      // ignore error\\n      return;\\n    }\\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\\n      return;\\n    }\\n    files.push(file);\\n  });\\n\\n  return files;\\n};\\n\\n/**\\n * Generate an undefined error with a message warning the user.\\n *\\n * @return {Error}\\n */\\n\\nexports.undefinedError = function() {\\n  return new Error('Caught undefined error, did you throw without specifying what?');\\n};\\n\\n/**\\n * Generate an undefined error if `err` is not defined.\\n *\\n * @param {Error} err\\n * @return {Error}\\n */\\n\\nexports.getError = function(err) {\\n  return err || exports.undefinedError();\\n};\\n\\n/**\\n * @summary\\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\\n * @description\\n * When invoking this function you get a filter function that get the Error.stack as an input,\\n * and return a prettify output.\\n * (i.e: strip Mocha and internal node functions from stack trace).\\n * @returns {Function}\\n */\\nexports.stackTraceFilter = function() {\\n  // TODO: Replace with `process.browser`\\n  var slash = '/';\\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\\n  var cwd = is.node\\n      ? process.cwd() + slash\\n      : (typeof location === 'undefined' ? window.location : location).href.replace(/\\\\/[^\\\\/]*$/, '/');\\n\\n  function isMochaInternal(line) {\\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash))\\n      || (~line.indexOf('components' + slash + 'mochajs' + slash))\\n      || (~line.indexOf('components' + slash + 'mocha' + slash))\\n      || (~line.indexOf(slash + 'mocha.js'));\\n  }\\n\\n  function isNodeInternal(line) {\\n    return (~line.indexOf('(timers.js:'))\\n      || (~line.indexOf('(events.js:'))\\n      || (~line.indexOf('(node.js:'))\\n      || (~line.indexOf('(module.js:'))\\n      || (~line.indexOf('GeneratorFunctionPrototype.next (native)'))\\n      || false;\\n  }\\n\\n  return function(stack) {\\n    stack = stack.split('\\\\n');\\n\\n    stack = exports.reduce(stack, function(list, line) {\\n      if (isMochaInternal(line)) {\\n        return list;\\n      }\\n\\n      if (is.node && isNodeInternal(line)) {\\n        return list;\\n      }\\n\\n      // Clean up cwd(absolute)\\n      list.push(line.replace(cwd, ''));\\n      return list;\\n    }, []);\\n\\n    return stack.join('\\\\n');\\n  };\\n};\\n\\n}).call(this,require('_process'),require(\\\"buffer\\\").Buffer)\\n},{\\\"_process\\\":51,\\\"buffer\\\":43,\\\"debug\\\":2,\\\"fs\\\":41,\\\"glob\\\":41,\\\"path\\\":41,\\\"util\\\":66}],40:[function(require,module,exports){\\n(function (process){\\nvar WritableStream = require('stream').Writable\\nvar inherits = require('util').inherits\\n\\nmodule.exports = BrowserStdout\\n\\n\\ninherits(BrowserStdout, WritableStream)\\n\\nfunction BrowserStdout(opts) {\\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\\n\\n  opts = opts || {}\\n  WritableStream.call(this, opts)\\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\\n}\\n\\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\\n  var output = chunks.toString ? chunks.toString() : chunks\\n  if (this.label === false) {\\n    console.log(output)\\n  } else {\\n    console.log(this.label+':', output)\\n  }\\n  process.nextTick(cb)\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":51,\\\"stream\\\":63,\\\"util\\\":66}],41:[function(require,module,exports){\\n\\n},{}],42:[function(require,module,exports){\\narguments[4][41][0].apply(exports,arguments)\\n},{\\\"dup\\\":41}],43:[function(require,module,exports){\\n/*!\\n * The buffer module from node.js, for the browser.\\n *\\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\\n * @license  MIT\\n */\\n\\nvar base64 = require('base64-js')\\nvar ieee754 = require('ieee754')\\nvar isArray = require('is-array')\\n\\nexports.Buffer = Buffer\\nexports.SlowBuffer = SlowBuffer\\nexports.INSPECT_MAX_BYTES = 50\\nBuffer.poolSize = 8192 // not used by this implementation\\n\\nvar rootParent = {}\\n\\n/**\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\n *   === true    Use Uint8Array implementation (fastest)\\n *   === false   Use Object implementation (most compatible, even IE6)\\n *\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\n * Opera 11.6+, iOS 4.2+.\\n *\\n * Due to various browser bugs, sometimes the Object implementation will be used even\\n * when the browser supports typed arrays.\\n *\\n * Note:\\n *\\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\\n *\\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\\n *     on objects.\\n *\\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\\n *\\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\\n *     incorrect length in some situations.\\n\\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\\n * get the Object implementation, which is slower but behaves correctly.\\n */\\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\\n  function Bar () {}\\n  try {\\n    var arr = new Uint8Array(1)\\n    arr.foo = function () { return 42 }\\n    arr.constructor = Bar\\n    return arr.foo() === 42 && // typed array instances can be augmented\\n        arr.constructor === Bar && // constructor can be set\\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\\n  } catch (e) {\\n    return false\\n  }\\n})()\\n\\nfunction kMaxLength () {\\n  return Buffer.TYPED_ARRAY_SUPPORT\\n    ? 0x7fffffff\\n    : 0x3fffffff\\n}\\n\\n/**\\n * Class: Buffer\\n * =============\\n *\\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\\n * with function properties for all the node `Buffer` API functions. We use\\n * `Uint8Array` so that square bracket notation works as expected -- it returns\\n * a single octet.\\n *\\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\\n * prototype.\\n */\\nfunction Buffer (arg) {\\n  if (!(this instanceof Buffer)) {\\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\\n    return new Buffer(arg)\\n  }\\n\\n  this.length = 0\\n  this.parent = undefined\\n\\n  // Common case.\\n  if (typeof arg === 'number') {\\n    return fromNumber(this, arg)\\n  }\\n\\n  // Slightly less common case.\\n  if (typeof arg === 'string') {\\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\\n  }\\n\\n  // Unusual.\\n  return fromObject(this, arg)\\n}\\n\\nfunction fromNumber (that, length) {\\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\\n    for (var i = 0; i < length; i++) {\\n      that[i] = 0\\n    }\\n  }\\n  return that\\n}\\n\\nfunction fromString (that, string, encoding) {\\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\\n\\n  // Assumption: byteLength() return value is always < kMaxLength.\\n  var length = byteLength(string, encoding) | 0\\n  that = allocate(that, length)\\n\\n  that.write(string, encoding)\\n  return that\\n}\\n\\nfunction fromObject (that, object) {\\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\\n\\n  if (isArray(object)) return fromArray(that, object)\\n\\n  if (object == null) {\\n    throw new TypeError('must start with number, buffer, array or string')\\n  }\\n\\n  if (typeof ArrayBuffer !== 'undefined') {\\n    if (object.buffer instanceof ArrayBuffer) {\\n      return fromTypedArray(that, object)\\n    }\\n    if (object instanceof ArrayBuffer) {\\n      return fromArrayBuffer(that, object)\\n    }\\n  }\\n\\n  if (object.length) return fromArrayLike(that, object)\\n\\n  return fromJsonObject(that, object)\\n}\\n\\nfunction fromBuffer (that, buffer) {\\n  var length = checked(buffer.length) | 0\\n  that = allocate(that, length)\\n  buffer.copy(that, 0, 0, length)\\n  return that\\n}\\n\\nfunction fromArray (that, array) {\\n  var length = checked(array.length) | 0\\n  that = allocate(that, length)\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\n// Duplicate of fromArray() to keep fromArray() monomorphic.\\nfunction fromTypedArray (that, array) {\\n  var length = checked(array.length) | 0\\n  that = allocate(that, length)\\n  // Truncating the elements is probably not what people expect from typed\\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\\n  // of the old Buffer constructor.\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\nfunction fromArrayBuffer (that, array) {\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    array.byteLength\\n    that = Buffer._augment(new Uint8Array(array))\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    that = fromTypedArray(that, new Uint8Array(array))\\n  }\\n  return that\\n}\\n\\nfunction fromArrayLike (that, array) {\\n  var length = checked(array.length) | 0\\n  that = allocate(that, length)\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\\n// Returns a zero-length buffer for inputs that don't conform to the spec.\\nfunction fromJsonObject (that, object) {\\n  var array\\n  var length = 0\\n\\n  if (object.type === 'Buffer' && isArray(object.data)) {\\n    array = object.data\\n    length = checked(array.length) | 0\\n  }\\n  that = allocate(that, length)\\n\\n  for (var i = 0; i < length; i += 1) {\\n    that[i] = array[i] & 255\\n  }\\n  return that\\n}\\n\\nfunction allocate (that, length) {\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    // Return an augmented `Uint8Array` instance, for best performance\\n    that = Buffer._augment(new Uint8Array(length))\\n  } else {\\n    // Fallback: Return an object instance of the Buffer class\\n    that.length = length\\n    that._isBuffer = true\\n  }\\n\\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\\n  if (fromPool) that.parent = rootParent\\n\\n  return that\\n}\\n\\nfunction checked (length) {\\n  // Note: cannot use `length < kMaxLength` here because that fails when\\n  // length is NaN (which is otherwise coerced to zero.)\\n  if (length >= kMaxLength()) {\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\\n  }\\n  return length | 0\\n}\\n\\nfunction SlowBuffer (subject, encoding) {\\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\\n\\n  var buf = new Buffer(subject, encoding)\\n  delete buf.parent\\n  return buf\\n}\\n\\nBuffer.isBuffer = function isBuffer (b) {\\n  return !!(b != null && b._isBuffer)\\n}\\n\\nBuffer.compare = function compare (a, b) {\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\n    throw new TypeError('Arguments must be Buffers')\\n  }\\n\\n  if (a === b) return 0\\n\\n  var x = a.length\\n  var y = b.length\\n\\n  var i = 0\\n  var len = Math.min(x, y)\\n  while (i < len) {\\n    if (a[i] !== b[i]) break\\n\\n    ++i\\n  }\\n\\n  if (i !== len) {\\n    x = a[i]\\n    y = b[i]\\n  }\\n\\n  if (x < y) return -1\\n  if (y < x) return 1\\n  return 0\\n}\\n\\nBuffer.isEncoding = function isEncoding (encoding) {\\n  switch (String(encoding).toLowerCase()) {\\n    case 'hex':\\n    case 'utf8':\\n    case 'utf-8':\\n    case 'ascii':\\n    case 'binary':\\n    case 'base64':\\n    case 'raw':\\n    case 'ucs2':\\n    case 'ucs-2':\\n    case 'utf16le':\\n    case 'utf-16le':\\n      return true\\n    default:\\n      return false\\n  }\\n}\\n\\nBuffer.concat = function concat (list, length) {\\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\\n\\n  if (list.length === 0) {\\n    return new Buffer(0)\\n  }\\n\\n  var i\\n  if (length === undefined) {\\n    length = 0\\n    for (i = 0; i < list.length; i++) {\\n      length += list[i].length\\n    }\\n  }\\n\\n  var buf = new Buffer(length)\\n  var pos = 0\\n  for (i = 0; i < list.length; i++) {\\n    var item = list[i]\\n    item.copy(buf, pos)\\n    pos += item.length\\n  }\\n  return buf\\n}\\n\\nfunction byteLength (string, encoding) {\\n  if (typeof string !== 'string') string = '' + string\\n\\n  var len = string.length\\n  if (len === 0) return 0\\n\\n  // Use a for loop to avoid recursion\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'ascii':\\n      case 'binary':\\n      // Deprecated\\n      case 'raw':\\n      case 'raws':\\n        return len\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8ToBytes(string).length\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return len * 2\\n      case 'hex':\\n        return len >>> 1\\n      case 'base64':\\n        return base64ToBytes(string).length\\n      default:\\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\nBuffer.byteLength = byteLength\\n\\n// pre-set for values that may exist in the future\\nBuffer.prototype.length = undefined\\nBuffer.prototype.parent = undefined\\n\\nfunction slowToString (encoding, start, end) {\\n  var loweredCase = false\\n\\n  start = start | 0\\n  end = end === undefined || end === Infinity ? this.length : end | 0\\n\\n  if (!encoding) encoding = 'utf8'\\n  if (start < 0) start = 0\\n  if (end > this.length) end = this.length\\n  if (end <= start) return ''\\n\\n  while (true) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexSlice(this, start, end)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Slice(this, start, end)\\n\\n      case 'ascii':\\n        return asciiSlice(this, start, end)\\n\\n      case 'binary':\\n        return binarySlice(this, start, end)\\n\\n      case 'base64':\\n        return base64Slice(this, start, end)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return utf16leSlice(this, start, end)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = (encoding + '').toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\nBuffer.prototype.toString = function toString () {\\n  var length = this.length | 0\\n  if (length === 0) return ''\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\n  return slowToString.apply(this, arguments)\\n}\\n\\nBuffer.prototype.equals = function equals (b) {\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\n  if (this === b) return true\\n  return Buffer.compare(this, b) === 0\\n}\\n\\nBuffer.prototype.inspect = function inspect () {\\n  var str = ''\\n  var max = exports.INSPECT_MAX_BYTES\\n  if (this.length > 0) {\\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\\n    if (this.length > max) str += ' ... '\\n  }\\n  return '<Buffer ' + str + '>'\\n}\\n\\nBuffer.prototype.compare = function compare (b) {\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\n  if (this === b) return 0\\n  return Buffer.compare(this, b)\\n}\\n\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\\n  byteOffset >>= 0\\n\\n  if (this.length === 0) return -1\\n  if (byteOffset >= this.length) return -1\\n\\n  // Negative offsets start from the end of the buffer\\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\\n\\n  if (typeof val === 'string') {\\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\\n    return String.prototype.indexOf.call(this, val, byteOffset)\\n  }\\n  if (Buffer.isBuffer(val)) {\\n    return arrayIndexOf(this, val, byteOffset)\\n  }\\n  if (typeof val === 'number') {\\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\\n    }\\n    return arrayIndexOf(this, [ val ], byteOffset)\\n  }\\n\\n  function arrayIndexOf (arr, val, byteOffset) {\\n    var foundIndex = -1\\n    for (var i = 0; byteOffset + i < arr.length; i++) {\\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\\n        if (foundIndex === -1) foundIndex = i\\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\\n      } else {\\n        foundIndex = -1\\n      }\\n    }\\n    return -1\\n  }\\n\\n  throw new TypeError('val must be string, number or Buffer')\\n}\\n\\n// `get` is deprecated\\nBuffer.prototype.get = function get (offset) {\\n  console.log('.get() is deprecated. Access using array indexes instead.')\\n  return this.readUInt8(offset)\\n}\\n\\n// `set` is deprecated\\nBuffer.prototype.set = function set (v, offset) {\\n  console.log('.set() is deprecated. Access using array indexes instead.')\\n  return this.writeUInt8(v, offset)\\n}\\n\\nfunction hexWrite (buf, string, offset, length) {\\n  offset = Number(offset) || 0\\n  var remaining = buf.length - offset\\n  if (!length) {\\n    length = remaining\\n  } else {\\n    length = Number(length)\\n    if (length > remaining) {\\n      length = remaining\\n    }\\n  }\\n\\n  // must be an even number of digits\\n  var strLen = string.length\\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\\n\\n  if (length > strLen / 2) {\\n    length = strLen / 2\\n  }\\n  for (var i = 0; i < length; i++) {\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\\n    buf[offset + i] = parsed\\n  }\\n  return i\\n}\\n\\nfunction utf8Write (buf, string, offset, length) {\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nfunction asciiWrite (buf, string, offset, length) {\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\n}\\n\\nfunction binaryWrite (buf, string, offset, length) {\\n  return asciiWrite(buf, string, offset, length)\\n}\\n\\nfunction base64Write (buf, string, offset, length) {\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\n}\\n\\nfunction ucs2Write (buf, string, offset, length) {\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\n}\\n\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\n  // Buffer#write(string)\\n  if (offset === undefined) {\\n    encoding = 'utf8'\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, encoding)\\n  } else if (length === undefined && typeof offset === 'string') {\\n    encoding = offset\\n    length = this.length\\n    offset = 0\\n  // Buffer#write(string, offset[, length][, encoding])\\n  } else if (isFinite(offset)) {\\n    offset = offset | 0\\n    if (isFinite(length)) {\\n      length = length | 0\\n      if (encoding === undefined) encoding = 'utf8'\\n    } else {\\n      encoding = length\\n      length = undefined\\n    }\\n  // legacy write(string, encoding, offset, length) - remove in v0.13\\n  } else {\\n    var swap = encoding\\n    encoding = offset\\n    offset = length | 0\\n    length = swap\\n  }\\n\\n  var remaining = this.length - offset\\n  if (length === undefined || length > remaining) length = remaining\\n\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\n    throw new RangeError('attempt to write outside buffer bounds')\\n  }\\n\\n  if (!encoding) encoding = 'utf8'\\n\\n  var loweredCase = false\\n  for (;;) {\\n    switch (encoding) {\\n      case 'hex':\\n        return hexWrite(this, string, offset, length)\\n\\n      case 'utf8':\\n      case 'utf-8':\\n        return utf8Write(this, string, offset, length)\\n\\n      case 'ascii':\\n        return asciiWrite(this, string, offset, length)\\n\\n      case 'binary':\\n        return binaryWrite(this, string, offset, length)\\n\\n      case 'base64':\\n        // Warning: maxLength not taken into account in base64Write\\n        return base64Write(this, string, offset, length)\\n\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return ucs2Write(this, string, offset, length)\\n\\n      default:\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\n        encoding = ('' + encoding).toLowerCase()\\n        loweredCase = true\\n    }\\n  }\\n}\\n\\nBuffer.prototype.toJSON = function toJSON () {\\n  return {\\n    type: 'Buffer',\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\n  }\\n}\\n\\nfunction base64Slice (buf, start, end) {\\n  if (start === 0 && end === buf.length) {\\n    return base64.fromByteArray(buf)\\n  } else {\\n    return base64.fromByteArray(buf.slice(start, end))\\n  }\\n}\\n\\nfunction utf8Slice (buf, start, end) {\\n  end = Math.min(buf.length, end)\\n  var res = []\\n\\n  var i = start\\n  while (i < end) {\\n    var firstByte = buf[i]\\n    var codePoint = null\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\n      : (firstByte > 0xDF) ? 3\\n      : (firstByte > 0xBF) ? 2\\n      : 1\\n\\n    if (i + bytesPerSequence <= end) {\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\n\\n      switch (bytesPerSequence) {\\n        case 1:\\n          if (firstByte < 0x80) {\\n            codePoint = firstByte\\n          }\\n          break\\n        case 2:\\n          secondByte = buf[i + 1]\\n          if ((secondByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\n            if (tempCodePoint > 0x7F) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 3:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n          break\\n        case 4:\\n          secondByte = buf[i + 1]\\n          thirdByte = buf[i + 2]\\n          fourthByte = buf[i + 3]\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\n              codePoint = tempCodePoint\\n            }\\n          }\\n      }\\n    }\\n\\n    if (codePoint === null) {\\n      // we did not generate a valid codePoint so insert a\\n      // replacement char (U+FFFD) and advance only 1 byte\\n      codePoint = 0xFFFD\\n      bytesPerSequence = 1\\n    } else if (codePoint > 0xFFFF) {\\n      // encode to utf16 (surrogate pair dance)\\n      codePoint -= 0x10000\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\n    }\\n\\n    res.push(codePoint)\\n    i += bytesPerSequence\\n  }\\n\\n  return decodeCodePointsArray(res)\\n}\\n\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\n// the lowest limit is Chrome, with 0x10000 args.\\n// We go 1 magnitude less, for safety\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\n\\nfunction decodeCodePointsArray (codePoints) {\\n  var len = codePoints.length\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\n  }\\n\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\n  var res = ''\\n  var i = 0\\n  while (i < len) {\\n    res += String.fromCharCode.apply(\\n      String,\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\n    )\\n  }\\n  return res\\n}\\n\\nfunction asciiSlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; i++) {\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\n  }\\n  return ret\\n}\\n\\nfunction binarySlice (buf, start, end) {\\n  var ret = ''\\n  end = Math.min(buf.length, end)\\n\\n  for (var i = start; i < end; i++) {\\n    ret += String.fromCharCode(buf[i])\\n  }\\n  return ret\\n}\\n\\nfunction hexSlice (buf, start, end) {\\n  var len = buf.length\\n\\n  if (!start || start < 0) start = 0\\n  if (!end || end < 0 || end > len) end = len\\n\\n  var out = ''\\n  for (var i = start; i < end; i++) {\\n    out += toHex(buf[i])\\n  }\\n  return out\\n}\\n\\nfunction utf16leSlice (buf, start, end) {\\n  var bytes = buf.slice(start, end)\\n  var res = ''\\n  for (var i = 0; i < bytes.length; i += 2) {\\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\\n  }\\n  return res\\n}\\n\\nBuffer.prototype.slice = function slice (start, end) {\\n  var len = this.length\\n  start = ~~start\\n  end = end === undefined ? len : ~~end\\n\\n  if (start < 0) {\\n    start += len\\n    if (start < 0) start = 0\\n  } else if (start > len) {\\n    start = len\\n  }\\n\\n  if (end < 0) {\\n    end += len\\n    if (end < 0) end = 0\\n  } else if (end > len) {\\n    end = len\\n  }\\n\\n  if (end < start) end = start\\n\\n  var newBuf\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    newBuf = Buffer._augment(this.subarray(start, end))\\n  } else {\\n    var sliceLen = end - start\\n    newBuf = new Buffer(sliceLen, undefined)\\n    for (var i = 0; i < sliceLen; i++) {\\n      newBuf[i] = this[i + start]\\n    }\\n  }\\n\\n  if (newBuf.length) newBuf.parent = this.parent || this\\n\\n  return newBuf\\n}\\n\\n/*\\n * Need to make sure that buffer isn't trying to write out of bounds.\\n */\\nfunction checkOffset (offset, ext, length) {\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\n}\\n\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) {\\n    checkOffset(offset, byteLength, this.length)\\n  }\\n\\n  var val = this[offset + --byteLength]\\n  var mul = 1\\n  while (byteLength > 0 && (mul *= 0x100)) {\\n    val += this[offset + --byteLength] * mul\\n  }\\n\\n  return val\\n}\\n\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  return this[offset]\\n}\\n\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return this[offset] | (this[offset + 1] << 8)\\n}\\n\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  return (this[offset] << 8) | this[offset + 1]\\n}\\n\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return ((this[offset]) |\\n      (this[offset + 1] << 8) |\\n      (this[offset + 2] << 16)) +\\n      (this[offset + 3] * 0x1000000)\\n}\\n\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] * 0x1000000) +\\n    ((this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    this[offset + 3])\\n}\\n\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var val = this[offset]\\n  var mul = 1\\n  var i = 0\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    val += this[offset + i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\n\\n  var i = byteLength\\n  var mul = 1\\n  var val = this[offset + --i]\\n  while (i > 0 && (mul *= 0x100)) {\\n    val += this[offset + --i] * mul\\n  }\\n  mul *= 0x80\\n\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\n\\n  return val\\n}\\n\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\n  if (!(this[offset] & 0x80)) return (this[offset])\\n  return ((0xff - this[offset] + 1) * -1)\\n}\\n\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset] | (this[offset + 1] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\n  var val = this[offset + 1] | (this[offset] << 8)\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\n}\\n\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset]) |\\n    (this[offset + 1] << 8) |\\n    (this[offset + 2] << 16) |\\n    (this[offset + 3] << 24)\\n}\\n\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n\\n  return (this[offset] << 24) |\\n    (this[offset + 1] << 16) |\\n    (this[offset + 2] << 8) |\\n    (this[offset + 3])\\n}\\n\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, true, 23, 4)\\n}\\n\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\n  return ieee754.read(this, offset, false, 23, 4)\\n}\\n\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, true, 52, 8)\\n}\\n\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\n  return ieee754.read(this, offset, false, 52, 8)\\n}\\n\\nfunction checkInt (buf, value, offset, ext, max, min) {\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\\n}\\n\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\\n\\n  var mul = 1\\n  var i = 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  byteLength = byteLength | 0\\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    this[offset + i] = (value / mul) & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  this[offset] = value\\n  return offset + 1\\n}\\n\\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\\n      (littleEndian ? i : 1 - i) * 8\\n  }\\n}\\n\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = value\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = value\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\\n  if (value < 0) value = 0xffffffff + value + 1\\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\\n  }\\n}\\n\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset + 3] = (value >>> 24)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 1] = (value >>> 8)\\n    this[offset] = value\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = value\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = 0\\n  var mul = 1\\n  var sub = value < 0 ? 1 : 0\\n  this[offset] = value & 0xFF\\n  while (++i < byteLength && (mul *= 0x100)) {\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) {\\n    var limit = Math.pow(2, 8 * byteLength - 1)\\n\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\n  }\\n\\n  var i = byteLength - 1\\n  var mul = 1\\n  var sub = value < 0 ? 1 : 0\\n  this[offset + i] = value & 0xFF\\n  while (--i >= 0 && (mul *= 0x100)) {\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\n  }\\n\\n  return offset + byteLength\\n}\\n\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\\n  if (value < 0) value = 0xff + value + 1\\n  this[offset] = value\\n  return offset + 1\\n}\\n\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = value\\n    this[offset + 1] = (value >>> 8)\\n  } else {\\n    objectWriteUInt16(this, value, offset, true)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 8)\\n    this[offset + 1] = value\\n  } else {\\n    objectWriteUInt16(this, value, offset, false)\\n  }\\n  return offset + 2\\n}\\n\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = value\\n    this[offset + 1] = (value >>> 8)\\n    this[offset + 2] = (value >>> 16)\\n    this[offset + 3] = (value >>> 24)\\n  } else {\\n    objectWriteUInt32(this, value, offset, true)\\n  }\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\n  value = +value\\n  offset = offset | 0\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\n  if (value < 0) value = 0xffffffff + value + 1\\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\\n    this[offset] = (value >>> 24)\\n    this[offset + 1] = (value >>> 16)\\n    this[offset + 2] = (value >>> 8)\\n    this[offset + 3] = value\\n  } else {\\n    objectWriteUInt32(this, value, offset, false)\\n  }\\n  return offset + 4\\n}\\n\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\\n  if (offset < 0) throw new RangeError('index out of range')\\n}\\n\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\n  return offset + 4\\n}\\n\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\n  return writeFloat(this, value, offset, false, noAssert)\\n}\\n\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\n  if (!noAssert) {\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\n  }\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\n  return offset + 8\\n}\\n\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, true, noAssert)\\n}\\n\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\n  return writeDouble(this, value, offset, false, noAssert)\\n}\\n\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\n  if (!start) start = 0\\n  if (!end && end !== 0) end = this.length\\n  if (targetStart >= target.length) targetStart = target.length\\n  if (!targetStart) targetStart = 0\\n  if (end > 0 && end < start) end = start\\n\\n  // Copy 0 bytes; we're done\\n  if (end === start) return 0\\n  if (target.length === 0 || this.length === 0) return 0\\n\\n  // Fatal error conditions\\n  if (targetStart < 0) {\\n    throw new RangeError('targetStart out of bounds')\\n  }\\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\n\\n  // Are we oob?\\n  if (end > this.length) end = this.length\\n  if (target.length - targetStart < end - start) {\\n    end = target.length - targetStart + start\\n  }\\n\\n  var len = end - start\\n  var i\\n\\n  if (this === target && start < targetStart && targetStart < end) {\\n    // descending copy from end\\n    for (i = len - 1; i >= 0; i--) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\\n    // ascending copy from start\\n    for (i = 0; i < len; i++) {\\n      target[i + targetStart] = this[i + start]\\n    }\\n  } else {\\n    target._set(this.subarray(start, start + len), targetStart)\\n  }\\n\\n  return len\\n}\\n\\n// fill(value, start=0, end=buffer.length)\\nBuffer.prototype.fill = function fill (value, start, end) {\\n  if (!value) value = 0\\n  if (!start) start = 0\\n  if (!end) end = this.length\\n\\n  if (end < start) throw new RangeError('end < start')\\n\\n  // Fill 0 bytes; we're done\\n  if (end === start) return\\n  if (this.length === 0) return\\n\\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\\n\\n  var i\\n  if (typeof value === 'number') {\\n    for (i = start; i < end; i++) {\\n      this[i] = value\\n    }\\n  } else {\\n    var bytes = utf8ToBytes(value.toString())\\n    var len = bytes.length\\n    for (i = start; i < end; i++) {\\n      this[i] = bytes[i % len]\\n    }\\n  }\\n\\n  return this\\n}\\n\\n/**\\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\\n */\\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\\n  if (typeof Uint8Array !== 'undefined') {\\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\\n      return (new Buffer(this)).buffer\\n    } else {\\n      var buf = new Uint8Array(this.length)\\n      for (var i = 0, len = buf.length; i < len; i += 1) {\\n        buf[i] = this[i]\\n      }\\n      return buf.buffer\\n    }\\n  } else {\\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\\n  }\\n}\\n\\n// HELPER FUNCTIONS\\n// ================\\n\\nvar BP = Buffer.prototype\\n\\n/**\\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\\n */\\nBuffer._augment = function _augment (arr) {\\n  arr.constructor = Buffer\\n  arr._isBuffer = true\\n\\n  // save reference to original Uint8Array set method before overwriting\\n  arr._set = arr.set\\n\\n  // deprecated\\n  arr.get = BP.get\\n  arr.set = BP.set\\n\\n  arr.write = BP.write\\n  arr.toString = BP.toString\\n  arr.toLocaleString = BP.toString\\n  arr.toJSON = BP.toJSON\\n  arr.equals = BP.equals\\n  arr.compare = BP.compare\\n  arr.indexOf = BP.indexOf\\n  arr.copy = BP.copy\\n  arr.slice = BP.slice\\n  arr.readUIntLE = BP.readUIntLE\\n  arr.readUIntBE = BP.readUIntBE\\n  arr.readUInt8 = BP.readUInt8\\n  arr.readUInt16LE = BP.readUInt16LE\\n  arr.readUInt16BE = BP.readUInt16BE\\n  arr.readUInt32LE = BP.readUInt32LE\\n  arr.readUInt32BE = BP.readUInt32BE\\n  arr.readIntLE = BP.readIntLE\\n  arr.readIntBE = BP.readIntBE\\n  arr.readInt8 = BP.readInt8\\n  arr.readInt16LE = BP.readInt16LE\\n  arr.readInt16BE = BP.readInt16BE\\n  arr.readInt32LE = BP.readInt32LE\\n  arr.readInt32BE = BP.readInt32BE\\n  arr.readFloatLE = BP.readFloatLE\\n  arr.readFloatBE = BP.readFloatBE\\n  arr.readDoubleLE = BP.readDoubleLE\\n  arr.readDoubleBE = BP.readDoubleBE\\n  arr.writeUInt8 = BP.writeUInt8\\n  arr.writeUIntLE = BP.writeUIntLE\\n  arr.writeUIntBE = BP.writeUIntBE\\n  arr.writeUInt16LE = BP.writeUInt16LE\\n  arr.writeUInt16BE = BP.writeUInt16BE\\n  arr.writeUInt32LE = BP.writeUInt32LE\\n  arr.writeUInt32BE = BP.writeUInt32BE\\n  arr.writeIntLE = BP.writeIntLE\\n  arr.writeIntBE = BP.writeIntBE\\n  arr.writeInt8 = BP.writeInt8\\n  arr.writeInt16LE = BP.writeInt16LE\\n  arr.writeInt16BE = BP.writeInt16BE\\n  arr.writeInt32LE = BP.writeInt32LE\\n  arr.writeInt32BE = BP.writeInt32BE\\n  arr.writeFloatLE = BP.writeFloatLE\\n  arr.writeFloatBE = BP.writeFloatBE\\n  arr.writeDoubleLE = BP.writeDoubleLE\\n  arr.writeDoubleBE = BP.writeDoubleBE\\n  arr.fill = BP.fill\\n  arr.inspect = BP.inspect\\n  arr.toArrayBuffer = BP.toArrayBuffer\\n\\n  return arr\\n}\\n\\nvar INVALID_BASE64_RE = /[^+\\\\/0-9A-Za-z-_]/g\\n\\nfunction base64clean (str) {\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\\n  // Node converts strings with length < 2 to ''\\n  if (str.length < 2) return ''\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\n  while (str.length % 4 !== 0) {\\n    str = str + '='\\n  }\\n  return str\\n}\\n\\nfunction stringtrim (str) {\\n  if (str.trim) return str.trim()\\n  return str.replace(/^\\\\s+|\\\\s+$/g, '')\\n}\\n\\nfunction toHex (n) {\\n  if (n < 16) return '0' + n.toString(16)\\n  return n.toString(16)\\n}\\n\\nfunction utf8ToBytes (string, units) {\\n  units = units || Infinity\\n  var codePoint\\n  var length = string.length\\n  var leadSurrogate = null\\n  var bytes = []\\n\\n  for (var i = 0; i < length; i++) {\\n    codePoint = string.charCodeAt(i)\\n\\n    // is surrogate component\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\n      // last char was a lead\\n      if (!leadSurrogate) {\\n        // no lead yet\\n        if (codePoint > 0xDBFF) {\\n          // unexpected trail\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        } else if (i + 1 === length) {\\n          // unpaired lead\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n          continue\\n        }\\n\\n        // valid lead\\n        leadSurrogate = codePoint\\n\\n        continue\\n      }\\n\\n      // 2 leads in a row\\n      if (codePoint < 0xDC00) {\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n        leadSurrogate = codePoint\\n        continue\\n      }\\n\\n      // valid surrogate pair\\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\\n    } else if (leadSurrogate) {\\n      // valid bmp char, but last char was a lead\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\n    }\\n\\n    leadSurrogate = null\\n\\n    // encode utf8\\n    if (codePoint < 0x80) {\\n      if ((units -= 1) < 0) break\\n      bytes.push(codePoint)\\n    } else if (codePoint < 0x800) {\\n      if ((units -= 2) < 0) break\\n      bytes.push(\\n        codePoint >> 0x6 | 0xC0,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x10000) {\\n      if ((units -= 3) < 0) break\\n      bytes.push(\\n        codePoint >> 0xC | 0xE0,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else if (codePoint < 0x110000) {\\n      if ((units -= 4) < 0) break\\n      bytes.push(\\n        codePoint >> 0x12 | 0xF0,\\n        codePoint >> 0xC & 0x3F | 0x80,\\n        codePoint >> 0x6 & 0x3F | 0x80,\\n        codePoint & 0x3F | 0x80\\n      )\\n    } else {\\n      throw new Error('Invalid code point')\\n    }\\n  }\\n\\n  return bytes\\n}\\n\\nfunction asciiToBytes (str) {\\n  var byteArray = []\\n  for (var i = 0; i < str.length; i++) {\\n    // Node's code seems to be doing this and not & 0x7F..\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\n  }\\n  return byteArray\\n}\\n\\nfunction utf16leToBytes (str, units) {\\n  var c, hi, lo\\n  var byteArray = []\\n  for (var i = 0; i < str.length; i++) {\\n    if ((units -= 2) < 0) break\\n\\n    c = str.charCodeAt(i)\\n    hi = c >> 8\\n    lo = c % 256\\n    byteArray.push(lo)\\n    byteArray.push(hi)\\n  }\\n\\n  return byteArray\\n}\\n\\nfunction base64ToBytes (str) {\\n  return base64.toByteArray(base64clean(str))\\n}\\n\\nfunction blitBuffer (src, dst, offset, length) {\\n  for (var i = 0; i < length; i++) {\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\n    dst[i + offset] = src[i]\\n  }\\n  return i\\n}\\n\\n},{\\\"base64-js\\\":44,\\\"ieee754\\\":45,\\\"is-array\\\":46}],44:[function(require,module,exports){\\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n;(function (exports) {\\n\\t'use strict';\\n\\n  var Arr = (typeof Uint8Array !== 'undefined')\\n    ? Uint8Array\\n    : Array\\n\\n\\tvar PLUS   = '+'.charCodeAt(0)\\n\\tvar SLASH  = '/'.charCodeAt(0)\\n\\tvar NUMBER = '0'.charCodeAt(0)\\n\\tvar LOWER  = 'a'.charCodeAt(0)\\n\\tvar UPPER  = 'A'.charCodeAt(0)\\n\\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\\n\\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\\n\\n\\tfunction decode (elt) {\\n\\t\\tvar code = elt.charCodeAt(0)\\n\\t\\tif (code === PLUS ||\\n\\t\\t    code === PLUS_URL_SAFE)\\n\\t\\t\\treturn 62 // '+'\\n\\t\\tif (code === SLASH ||\\n\\t\\t    code === SLASH_URL_SAFE)\\n\\t\\t\\treturn 63 // '/'\\n\\t\\tif (code < NUMBER)\\n\\t\\t\\treturn -1 //no match\\n\\t\\tif (code < NUMBER + 10)\\n\\t\\t\\treturn code - NUMBER + 26 + 26\\n\\t\\tif (code < UPPER + 26)\\n\\t\\t\\treturn code - UPPER\\n\\t\\tif (code < LOWER + 26)\\n\\t\\t\\treturn code - LOWER + 26\\n\\t}\\n\\n\\tfunction b64ToByteArray (b64) {\\n\\t\\tvar i, j, l, tmp, placeHolders, arr\\n\\n\\t\\tif (b64.length % 4 > 0) {\\n\\t\\t\\tthrow new Error('Invalid string. Length must be a multiple of 4')\\n\\t\\t}\\n\\n\\t\\t// the number of equal signs (place holders)\\n\\t\\t// if there are two placeholders, than the two characters before it\\n\\t\\t// represent one byte\\n\\t\\t// if there is only one, then the three characters before it represent 2 bytes\\n\\t\\t// this is just a cheap hack to not do indexOf twice\\n\\t\\tvar len = b64.length\\n\\t\\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\\n\\n\\t\\t// base64 is 4/3 + up to two characters of the original data\\n\\t\\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\\n\\n\\t\\t// if there are placeholders, only get up to the last complete 4 chars\\n\\t\\tl = placeHolders > 0 ? b64.length - 4 : b64.length\\n\\n\\t\\tvar L = 0\\n\\n\\t\\tfunction push (v) {\\n\\t\\t\\tarr[L++] = v\\n\\t\\t}\\n\\n\\t\\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\\n\\t\\t\\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\\n\\t\\t\\tpush((tmp & 0xFF0000) >> 16)\\n\\t\\t\\tpush((tmp & 0xFF00) >> 8)\\n\\t\\t\\tpush(tmp & 0xFF)\\n\\t\\t}\\n\\n\\t\\tif (placeHolders === 2) {\\n\\t\\t\\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\\n\\t\\t\\tpush(tmp & 0xFF)\\n\\t\\t} else if (placeHolders === 1) {\\n\\t\\t\\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\\n\\t\\t\\tpush((tmp >> 8) & 0xFF)\\n\\t\\t\\tpush(tmp & 0xFF)\\n\\t\\t}\\n\\n\\t\\treturn arr\\n\\t}\\n\\n\\tfunction uint8ToBase64 (uint8) {\\n\\t\\tvar i,\\n\\t\\t\\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\\n\\t\\t\\toutput = \\\"\\\",\\n\\t\\t\\ttemp, length\\n\\n\\t\\tfunction encode (num) {\\n\\t\\t\\treturn lookup.charAt(num)\\n\\t\\t}\\n\\n\\t\\tfunction tripletToBase64 (num) {\\n\\t\\t\\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\\n\\t\\t}\\n\\n\\t\\t// go through the array every three bytes, we'll deal with trailing stuff later\\n\\t\\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\\n\\t\\t\\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\\n\\t\\t\\toutput += tripletToBase64(temp)\\n\\t\\t}\\n\\n\\t\\t// pad the end with zeros, but make sure to not forget the extra bytes\\n\\t\\tswitch (extraBytes) {\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\ttemp = uint8[uint8.length - 1]\\n\\t\\t\\t\\toutput += encode(temp >> 2)\\n\\t\\t\\t\\toutput += encode((temp << 4) & 0x3F)\\n\\t\\t\\t\\toutput += '=='\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\\n\\t\\t\\t\\toutput += encode(temp >> 10)\\n\\t\\t\\t\\toutput += encode((temp >> 4) & 0x3F)\\n\\t\\t\\t\\toutput += encode((temp << 2) & 0x3F)\\n\\t\\t\\t\\toutput += '='\\n\\t\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\treturn output\\n\\t}\\n\\n\\texports.toByteArray = b64ToByteArray\\n\\texports.fromByteArray = uint8ToBase64\\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\\n\\n},{}],45:[function(require,module,exports){\\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\\n  var e, m\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var nBits = -7\\n  var i = isLE ? (nBytes - 1) : 0\\n  var d = isLE ? -1 : 1\\n  var s = buffer[offset + i]\\n\\n  i += d\\n\\n  e = s & ((1 << (-nBits)) - 1)\\n  s >>= (-nBits)\\n  nBits += eLen\\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  m = e & ((1 << (-nBits)) - 1)\\n  e >>= (-nBits)\\n  nBits += mLen\\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\n\\n  if (e === 0) {\\n    e = 1 - eBias\\n  } else if (e === eMax) {\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\n  } else {\\n    m = m + Math.pow(2, mLen)\\n    e = e - eBias\\n  }\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\n}\\n\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\n  var e, m, c\\n  var eLen = nBytes * 8 - mLen - 1\\n  var eMax = (1 << eLen) - 1\\n  var eBias = eMax >> 1\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\n  var i = isLE ? 0 : (nBytes - 1)\\n  var d = isLE ? 1 : -1\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\n\\n  value = Math.abs(value)\\n\\n  if (isNaN(value) || value === Infinity) {\\n    m = isNaN(value) ? 1 : 0\\n    e = eMax\\n  } else {\\n    e = Math.floor(Math.log(value) / Math.LN2)\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\n      e--\\n      c *= 2\\n    }\\n    if (e + eBias >= 1) {\\n      value += rt / c\\n    } else {\\n      value += rt * Math.pow(2, 1 - eBias)\\n    }\\n    if (value * c >= 2) {\\n      e++\\n      c /= 2\\n    }\\n\\n    if (e + eBias >= eMax) {\\n      m = 0\\n      e = eMax\\n    } else if (e + eBias >= 1) {\\n      m = (value * c - 1) * Math.pow(2, mLen)\\n      e = e + eBias\\n    } else {\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\n      e = 0\\n    }\\n  }\\n\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\n\\n  e = (e << mLen) | m\\n  eLen += mLen\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\n\\n  buffer[offset + i - d] |= s * 128\\n}\\n\\n},{}],46:[function(require,module,exports){\\n\\n/**\\n * isArray\\n */\\n\\nvar isArray = Array.isArray;\\n\\n/**\\n * toString\\n */\\n\\nvar str = Object.prototype.toString;\\n\\n/**\\n * Whether or not the given `val`\\n * is an array.\\n *\\n * example:\\n *\\n *        isArray([]);\\n *        // > true\\n *        isArray(arguments);\\n *        // > false\\n *        isArray('');\\n *        // > false\\n *\\n * @param {mixed} val\\n * @return {bool}\\n */\\n\\nmodule.exports = isArray || function (val) {\\n  return !! val && '[object Array]' == str.call(val);\\n};\\n\\n},{}],47:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nfunction EventEmitter() {\\n  this._events = this._events || {};\\n  this._maxListeners = this._maxListeners || undefined;\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function(n) {\\n  if (!isNumber(n) || n < 0 || isNaN(n))\\n    throw TypeError('n must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nEventEmitter.prototype.emit = function(type) {\\n  var er, handler, len, args, i, listeners;\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // If there is no 'error' event listener then throw.\\n  if (type === 'error') {\\n    if (!this._events.error ||\\n        (isObject(this._events.error) && !this._events.error.length)) {\\n      er = arguments[1];\\n      if (er instanceof Error) {\\n        throw er; // Unhandled 'error' event\\n      }\\n      throw TypeError('Uncaught, unspecified \\\"error\\\" event.');\\n    }\\n  }\\n\\n  handler = this._events[type];\\n\\n  if (isUndefined(handler))\\n    return false;\\n\\n  if (isFunction(handler)) {\\n    switch (arguments.length) {\\n      // fast cases\\n      case 1:\\n        handler.call(this);\\n        break;\\n      case 2:\\n        handler.call(this, arguments[1]);\\n        break;\\n      case 3:\\n        handler.call(this, arguments[1], arguments[2]);\\n        break;\\n      // slower\\n      default:\\n        len = arguments.length;\\n        args = new Array(len - 1);\\n        for (i = 1; i < len; i++)\\n          args[i - 1] = arguments[i];\\n        handler.apply(this, args);\\n    }\\n  } else if (isObject(handler)) {\\n    len = arguments.length;\\n    args = new Array(len - 1);\\n    for (i = 1; i < len; i++)\\n      args[i - 1] = arguments[i];\\n\\n    listeners = handler.slice();\\n    len = listeners.length;\\n    for (i = 0; i < len; i++)\\n      listeners[i].apply(this, args);\\n  }\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function(type, listener) {\\n  var m;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n  // adding it to the listeners, first emit \\\"newListener\\\".\\n  if (this._events.newListener)\\n    this.emit('newListener', type,\\n              isFunction(listener.listener) ?\\n              listener.listener : listener);\\n\\n  if (!this._events[type])\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    this._events[type] = listener;\\n  else if (isObject(this._events[type]))\\n    // If we've already got an array, just append.\\n    this._events[type].push(listener);\\n  else\\n    // Adding the second element, need to change to array.\\n    this._events[type] = [this._events[type], listener];\\n\\n  // Check for listener leak\\n  if (isObject(this._events[type]) && !this._events[type].warned) {\\n    var m;\\n    if (!isUndefined(this._maxListeners)) {\\n      m = this._maxListeners;\\n    } else {\\n      m = EventEmitter.defaultMaxListeners;\\n    }\\n\\n    if (m && m > 0 && this._events[type].length > m) {\\n      this._events[type].warned = true;\\n      console.error('(node) warning: possible EventEmitter memory ' +\\n                    'leak detected. %d listeners added. ' +\\n                    'Use emitter.setMaxListeners() to increase limit.',\\n                    this._events[type].length);\\n      if (typeof console.trace === 'function') {\\n        // not supported in IE 10\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function(type, listener) {\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener = function(type, listener) {\\n  var list, position, length, i;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events || !this._events[type])\\n    return this;\\n\\n  list = this._events[type];\\n  length = list.length;\\n  position = -1;\\n\\n  if (list === listener ||\\n      (isFunction(list.listener) && list.listener === listener)) {\\n    delete this._events[type];\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n\\n  } else if (isObject(list)) {\\n    for (i = length; i-- > 0;) {\\n      if (list[i] === listener ||\\n          (list[i].listener && list[i].listener === listener)) {\\n        position = i;\\n        break;\\n      }\\n    }\\n\\n    if (position < 0)\\n      return this;\\n\\n    if (list.length === 1) {\\n      list.length = 0;\\n      delete this._events[type];\\n    } else {\\n      list.splice(position, 1);\\n    }\\n\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.removeAllListeners = function(type) {\\n  var key, listeners;\\n\\n  if (!this._events)\\n    return this;\\n\\n  // not listening for removeListener, no need to emit\\n  if (!this._events.removeListener) {\\n    if (arguments.length === 0)\\n      this._events = {};\\n    else if (this._events[type])\\n      delete this._events[type];\\n    return this;\\n  }\\n\\n  // emit removeListener for all listeners on all events\\n  if (arguments.length === 0) {\\n    for (key in this._events) {\\n      if (key === 'removeListener') continue;\\n      this.removeAllListeners(key);\\n    }\\n    this.removeAllListeners('removeListener');\\n    this._events = {};\\n    return this;\\n  }\\n\\n  listeners = this._events[type];\\n\\n  if (isFunction(listeners)) {\\n    this.removeListener(type, listeners);\\n  } else {\\n    // LIFO order\\n    while (listeners.length)\\n      this.removeListener(type, listeners[listeners.length - 1]);\\n  }\\n  delete this._events[type];\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.listeners = function(type) {\\n  var ret;\\n  if (!this._events || !this._events[type])\\n    ret = [];\\n  else if (isFunction(this._events[type]))\\n    ret = [this._events[type]];\\n  else\\n    ret = this._events[type].slice();\\n  return ret;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  var ret;\\n  if (!emitter._events || !emitter._events[type])\\n    ret = 0;\\n  else if (isFunction(emitter._events[type]))\\n    ret = 1;\\n  else\\n    ret = emitter._events[type].length;\\n  return ret;\\n};\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\n\\n},{}],48:[function(require,module,exports){\\nif (typeof Object.create === 'function') {\\n  // implementation from standard node.js 'util' module\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    ctor.prototype = Object.create(superCtor.prototype, {\\n      constructor: {\\n        value: ctor,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n  };\\n} else {\\n  // old school shim for old browsers\\n  module.exports = function inherits(ctor, superCtor) {\\n    ctor.super_ = superCtor\\n    var TempCtor = function () {}\\n    TempCtor.prototype = superCtor.prototype\\n    ctor.prototype = new TempCtor()\\n    ctor.prototype.constructor = ctor\\n  }\\n}\\n\\n},{}],49:[function(require,module,exports){\\nmodule.exports = Array.isArray || function (arr) {\\n  return Object.prototype.toString.call(arr) == '[object Array]';\\n};\\n\\n},{}],50:[function(require,module,exports){\\nexports.endianness = function () { return 'LE' };\\n\\nexports.hostname = function () {\\n    if (typeof location !== 'undefined') {\\n        return location.hostname\\n    }\\n    else return '';\\n};\\n\\nexports.loadavg = function () { return [] };\\n\\nexports.uptime = function () { return 0 };\\n\\nexports.freemem = function () {\\n    return Number.MAX_VALUE;\\n};\\n\\nexports.totalmem = function () {\\n    return Number.MAX_VALUE;\\n};\\n\\nexports.cpus = function () { return [] };\\n\\nexports.type = function () { return 'Browser' };\\n\\nexports.release = function () {\\n    if (typeof navigator !== 'undefined') {\\n        return navigator.appVersion;\\n    }\\n    return '';\\n};\\n\\nexports.networkInterfaces\\n= exports.getNetworkInterfaces\\n= function () { return {} };\\n\\nexports.arch = function () { return 'javascript' };\\n\\nexports.platform = function () { return 'browser' };\\n\\nexports.tmpdir = exports.tmpDir = function () {\\n    return '/tmp';\\n};\\n\\nexports.EOL = '\\\\n';\\n\\n},{}],51:[function(require,module,exports){\\n// shim for using process in browser\\n\\nvar process = module.exports = {};\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = setTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    clearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        setTimeout(drainQueue, 0);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n},{}],52:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_duplex.js\\\")\\n\\n},{\\\"./lib/_stream_duplex.js\\\":53}],53:[function(require,module,exports){\\n(function (process){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// a duplex stream is just a stream that is both readable and writable.\\n// Since JS doesn't have multiple prototypal inheritance, this class\\n// prototypally inherits from Readable, and then parasitically from\\n// Writable.\\n\\nmodule.exports = Duplex;\\n\\n/*<replacement>*/\\nvar objectKeys = Object.keys || function (obj) {\\n  var keys = [];\\n  for (var key in obj) keys.push(key);\\n  return keys;\\n}\\n/*</replacement>*/\\n\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nvar Readable = require('./_stream_readable');\\nvar Writable = require('./_stream_writable');\\n\\nutil.inherits(Duplex, Readable);\\n\\nforEach(objectKeys(Writable.prototype), function(method) {\\n  if (!Duplex.prototype[method])\\n    Duplex.prototype[method] = Writable.prototype[method];\\n});\\n\\nfunction Duplex(options) {\\n  if (!(this instanceof Duplex))\\n    return new Duplex(options);\\n\\n  Readable.call(this, options);\\n  Writable.call(this, options);\\n\\n  if (options && options.readable === false)\\n    this.readable = false;\\n\\n  if (options && options.writable === false)\\n    this.writable = false;\\n\\n  this.allowHalfOpen = true;\\n  if (options && options.allowHalfOpen === false)\\n    this.allowHalfOpen = false;\\n\\n  this.once('end', onend);\\n}\\n\\n// the no-half-open enforcer\\nfunction onend() {\\n  // if we allow half-open state, or if the writable side ended,\\n  // then we're ok.\\n  if (this.allowHalfOpen || this._writableState.ended)\\n    return;\\n\\n  // no more data can be written.\\n  // But allow more writes to happen in this tick.\\n  process.nextTick(this.end.bind(this));\\n}\\n\\nfunction forEach (xs, f) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    f(xs[i], i);\\n  }\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./_stream_readable\\\":55,\\\"./_stream_writable\\\":57,\\\"_process\\\":51,\\\"core-util-is\\\":58,\\\"inherits\\\":48}],54:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// a passthrough stream.\\n// basically just the most minimal sort of Transform stream.\\n// Every written chunk gets output as-is.\\n\\nmodule.exports = PassThrough;\\n\\nvar Transform = require('./_stream_transform');\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nutil.inherits(PassThrough, Transform);\\n\\nfunction PassThrough(options) {\\n  if (!(this instanceof PassThrough))\\n    return new PassThrough(options);\\n\\n  Transform.call(this, options);\\n}\\n\\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\\n  cb(null, chunk);\\n};\\n\\n},{\\\"./_stream_transform\\\":56,\\\"core-util-is\\\":58,\\\"inherits\\\":48}],55:[function(require,module,exports){\\n(function (process){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nmodule.exports = Readable;\\n\\n/*<replacement>*/\\nvar isArray = require('isarray');\\n/*</replacement>*/\\n\\n\\n/*<replacement>*/\\nvar Buffer = require('buffer').Buffer;\\n/*</replacement>*/\\n\\nReadable.ReadableState = ReadableState;\\n\\nvar EE = require('events').EventEmitter;\\n\\n/*<replacement>*/\\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\\n  return emitter.listeners(type).length;\\n};\\n/*</replacement>*/\\n\\nvar Stream = require('stream');\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nvar StringDecoder;\\n\\n\\n/*<replacement>*/\\nvar debug = require('util');\\nif (debug && debug.debuglog) {\\n  debug = debug.debuglog('stream');\\n} else {\\n  debug = function () {};\\n}\\n/*</replacement>*/\\n\\n\\nutil.inherits(Readable, Stream);\\n\\nfunction ReadableState(options, stream) {\\n  var Duplex = require('./_stream_duplex');\\n\\n  options = options || {};\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.buffer = [];\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Duplex)\\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // when piping, we only care about 'readable' events that happen\\n  // after read()ing all the bytes and not getting any pushback.\\n  this.ranOut = false;\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder)\\n      StringDecoder = require('string_decoder/').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nfunction Readable(options) {\\n  var Duplex = require('./_stream_duplex');\\n\\n  if (!(this instanceof Readable))\\n    return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  Stream.call(this);\\n}\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function(chunk, encoding) {\\n  var state = this._readableState;\\n\\n  if (util.isString(chunk) && !state.objectMode) {\\n    encoding = encoding || state.defaultEncoding;\\n    if (encoding !== state.encoding) {\\n      chunk = new Buffer(chunk, encoding);\\n      encoding = '';\\n    }\\n  }\\n\\n  return readableAddChunk(this, state, chunk, encoding, false);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function(chunk) {\\n  var state = this._readableState;\\n  return readableAddChunk(this, state, chunk, '', true);\\n};\\n\\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\\n  var er = chunkInvalid(state, chunk);\\n  if (er) {\\n    stream.emit('error', er);\\n  } else if (util.isNullOrUndefined(chunk)) {\\n    state.reading = false;\\n    if (!state.ended)\\n      onEofChunk(stream, state);\\n  } else if (state.objectMode || chunk && chunk.length > 0) {\\n    if (state.ended && !addToFront) {\\n      var e = new Error('stream.push() after EOF');\\n      stream.emit('error', e);\\n    } else if (state.endEmitted && addToFront) {\\n      var e = new Error('stream.unshift() after end event');\\n      stream.emit('error', e);\\n    } else {\\n      if (state.decoder && !addToFront && !encoding)\\n        chunk = state.decoder.write(chunk);\\n\\n      if (!addToFront)\\n        state.reading = false;\\n\\n      // if we want the data now, just emit it.\\n      if (state.flowing && state.length === 0 && !state.sync) {\\n        stream.emit('data', chunk);\\n        stream.read(0);\\n      } else {\\n        // update the buffer info.\\n        state.length += state.objectMode ? 1 : chunk.length;\\n        if (addToFront)\\n          state.buffer.unshift(chunk);\\n        else\\n          state.buffer.push(chunk);\\n\\n        if (state.needReadable)\\n          emitReadable(stream);\\n      }\\n\\n      maybeReadMore(stream, state);\\n    }\\n  } else if (!addToFront) {\\n    state.reading = false;\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\n\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended &&\\n         (state.needReadable ||\\n          state.length < state.highWaterMark ||\\n          state.length === 0);\\n}\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function(enc) {\\n  if (!StringDecoder)\\n    StringDecoder = require('string_decoder/').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 128MB\\nvar MAX_HWM = 0x800000;\\nfunction roundUpToNextPowerOf2(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2\\n    n--;\\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\\n    n++;\\n  }\\n  return n;\\n}\\n\\nfunction howMuchToRead(n, state) {\\n  if (state.length === 0 && state.ended)\\n    return 0;\\n\\n  if (state.objectMode)\\n    return n === 0 ? 0 : 1;\\n\\n  if (isNaN(n) || util.isNull(n)) {\\n    // only flow one buffer at a time\\n    if (state.flowing && state.buffer.length)\\n      return state.buffer[0].length;\\n    else\\n      return state.length;\\n  }\\n\\n  if (n <= 0)\\n    return 0;\\n\\n  // If we're asking for more than the target buffer level,\\n  // then raise the water mark.  Bump up to the next highest\\n  // power of 2, to prevent increasing it excessively in tiny\\n  // amounts.\\n  if (n > state.highWaterMark)\\n    state.highWaterMark = roundUpToNextPowerOf2(n);\\n\\n  // don't have that much.  return null, unless we've ended.\\n  if (n > state.length) {\\n    if (!state.ended) {\\n      state.needReadable = true;\\n      return 0;\\n    } else\\n      return state.length;\\n  }\\n\\n  return n;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function(n) {\\n  debug('read', n);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (!util.isNumber(n) || n > 0)\\n    state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 &&\\n      state.needReadable &&\\n      (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended)\\n      endReadable(this);\\n    else\\n      emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0)\\n      endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  }\\n\\n  if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0)\\n      state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n  }\\n\\n  // If _read pushed data synchronously, then `reading` will be false,\\n  // and we need to re-evaluate how much data we can return to the user.\\n  if (doRead && !state.reading)\\n    n = howMuchToRead(nOrig, state);\\n\\n  var ret;\\n  if (n > 0)\\n    ret = fromList(n, state);\\n  else\\n    ret = null;\\n\\n  if (util.isNull(ret)) {\\n    state.needReadable = true;\\n    n = 0;\\n  }\\n\\n  state.length -= n;\\n\\n  // If we have nothing in the buffer, then we want to know\\n  // as soon as we *do* get something into the buffer.\\n  if (state.length === 0 && !state.ended)\\n    state.needReadable = true;\\n\\n  // If we tried to read() past the EOF, then emit end on the next tick.\\n  if (nOrig !== n && state.ended && state.length === 0)\\n    endReadable(this);\\n\\n  if (!util.isNull(ret))\\n    this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er = null;\\n  if (!util.isBuffer(chunk) &&\\n      !util.isString(chunk) &&\\n      !util.isNullOrUndefined(chunk) &&\\n      !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.decoder && !state.ended) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync)\\n      process.nextTick(function() {\\n        emitReadable_(stream);\\n      });\\n    else\\n      emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    process.nextTick(function() {\\n      maybeReadMore_(stream, state);\\n    });\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended &&\\n         state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;\\n    else\\n      len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function(n) {\\n  this.emit('error', new Error('not implemented'));\\n};\\n\\nReadable.prototype.pipe = function(dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\\n              dest !== process.stdout &&\\n              dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : cleanup;\\n  if (state.endEmitted)\\n    process.nextTick(endFn);\\n  else\\n    src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      cleanup();\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', cleanup);\\n    src.removeListener('data', ondata);\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain &&\\n        (!dest._writableState || dest._writableState.needDrain))\\n      ondrain();\\n  }\\n\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    var ret = dest.write(chunk);\\n    if (false === ret) {\\n      debug('false write response, pause',\\n            src._readableState.awaitDrain);\\n      src._readableState.awaitDrain++;\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EE.listenerCount(dest, 'error') === 0)\\n      dest.emit('error', er);\\n  }\\n  // This is a brutally ugly hack to make sure that our error handler\\n  // is attached before any userland ones.  NEVER DO THIS.\\n  if (!dest._events || !dest._events.error)\\n    dest.on('error', onerror);\\n  else if (isArray(dest._events.error))\\n    dest._events.error.unshift(onerror);\\n  else\\n    dest._events.error = [onerror, dest._events.error];\\n\\n\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function() {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain)\\n      state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\n\\nReadable.prototype.unpipe = function(dest) {\\n  var state = this._readableState;\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0)\\n    return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes)\\n      return this;\\n\\n    if (!dest)\\n      dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest)\\n      dest.emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var i = 0; i < len; i++)\\n      dests[i].emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // try to find the right one.\\n  var i = indexOf(state.pipes, dest);\\n  if (i === -1)\\n    return this;\\n\\n  state.pipes.splice(i, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1)\\n    state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function(ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  // If listening to data, and it has not explicitly been paused,\\n  // then call resume to start the flow of data on the next tick.\\n  if (ev === 'data' && false !== this._readableState.flowing) {\\n    this.resume();\\n  }\\n\\n  if (ev === 'readable' && this.readable) {\\n    var state = this._readableState;\\n    if (!state.readableListening) {\\n      state.readableListening = true;\\n      state.emittedReadable = false;\\n      state.needReadable = true;\\n      if (!state.reading) {\\n        var self = this;\\n        process.nextTick(function() {\\n          debug('readable nexttick read 0');\\n          self.read(0);\\n        });\\n      } else if (state.length) {\\n        emitReadable(this, state);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function() {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    if (!state.reading) {\\n      debug('resume read 0');\\n      this.read(0);\\n    }\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    process.nextTick(function() {\\n      resume_(stream, state);\\n    });\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  state.resumeScheduled = false;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading)\\n    stream.read(0);\\n}\\n\\nReadable.prototype.pause = function() {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  if (state.flowing) {\\n    do {\\n      var chunk = stream.read();\\n    } while (null !== chunk && state.flowing);\\n  }\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function(stream) {\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  var self = this;\\n  stream.on('end', function() {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length)\\n        self.push(chunk);\\n    }\\n\\n    self.push(null);\\n  });\\n\\n  stream.on('data', function(chunk) {\\n    debug('wrapped data');\\n    if (state.decoder)\\n      chunk = state.decoder.write(chunk);\\n    if (!chunk || !state.objectMode && !chunk.length)\\n      return;\\n\\n    var ret = self.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\\n      this[i] = function(method) { return function() {\\n        return stream[method].apply(stream, arguments);\\n      }}(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\\n  forEach(events, function(ev) {\\n    stream.on(ev, self.emit.bind(self, ev));\\n  });\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  self._read = function(n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return self;\\n};\\n\\n\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\nfunction fromList(n, state) {\\n  var list = state.buffer;\\n  var length = state.length;\\n  var stringMode = !!state.decoder;\\n  var objectMode = !!state.objectMode;\\n  var ret;\\n\\n  // nothing in the list, definitely empty.\\n  if (list.length === 0)\\n    return null;\\n\\n  if (length === 0)\\n    ret = null;\\n  else if (objectMode)\\n    ret = list.shift();\\n  else if (!n || n >= length) {\\n    // read it all, truncate the array.\\n    if (stringMode)\\n      ret = list.join('');\\n    else\\n      ret = Buffer.concat(list, length);\\n    list.length = 0;\\n  } else {\\n    // read just some of it.\\n    if (n < list[0].length) {\\n      // just take a part of the first list item.\\n      // slice is the same for buffers and strings.\\n      var buf = list[0];\\n      ret = buf.slice(0, n);\\n      list[0] = buf.slice(n);\\n    } else if (n === list[0].length) {\\n      // first list is a perfect match\\n      ret = list.shift();\\n    } else {\\n      // complex case.\\n      // we have enough to cover it, but it spans past the first buffer.\\n      if (stringMode)\\n        ret = '';\\n      else\\n        ret = new Buffer(n);\\n\\n      var c = 0;\\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\\n        var buf = list[0];\\n        var cpy = Math.min(n - c, buf.length);\\n\\n        if (stringMode)\\n          ret += buf.slice(0, cpy);\\n        else\\n          buf.copy(ret, c, 0, cpy);\\n\\n        if (cpy < buf.length)\\n          list[0] = buf.slice(cpy);\\n        else\\n          list.shift();\\n\\n        c += cpy;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0)\\n    throw new Error('endReadable called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    process.nextTick(function() {\\n      // Check that we didn't get one last unshift.\\n      if (!state.endEmitted && state.length === 0) {\\n        state.endEmitted = true;\\n        stream.readable = false;\\n        stream.emit('end');\\n      }\\n    });\\n  }\\n}\\n\\nfunction forEach (xs, f) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    f(xs[i], i);\\n  }\\n}\\n\\nfunction indexOf (xs, x) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    if (xs[i] === x) return i;\\n  }\\n  return -1;\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./_stream_duplex\\\":53,\\\"_process\\\":51,\\\"buffer\\\":43,\\\"core-util-is\\\":58,\\\"events\\\":47,\\\"inherits\\\":48,\\\"isarray\\\":49,\\\"stream\\\":63,\\\"string_decoder/\\\":64,\\\"util\\\":42}],56:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('./_stream_duplex');\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nutil.inherits(Transform, Duplex);\\n\\n\\nfunction TransformState(options, stream) {\\n  this.afterTransform = function(er, data) {\\n    return afterTransform(stream, er, data);\\n  };\\n\\n  this.needTransform = false;\\n  this.transforming = false;\\n  this.writecb = null;\\n  this.writechunk = null;\\n}\\n\\nfunction afterTransform(stream, er, data) {\\n  var ts = stream._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb)\\n    return stream.emit('error', new Error('no writecb in Transform class'));\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (!util.isNullOrUndefined(data))\\n    stream.push(data);\\n\\n  if (cb)\\n    cb(er);\\n\\n  var rs = stream._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    stream._read(rs.highWaterMark);\\n  }\\n}\\n\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform))\\n    return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = new TransformState(options, this);\\n\\n  // when the writable side finishes, then flush out anything remaining.\\n  var stream = this;\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  this.once('prefinish', function() {\\n    if (util.isFunction(this._flush))\\n      this._flush(function(er) {\\n        done(stream, er);\\n      });\\n    else\\n      done(stream);\\n  });\\n}\\n\\nTransform.prototype.push = function(chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function(chunk, encoding, cb) {\\n  throw new Error('not implemented');\\n};\\n\\nTransform.prototype._write = function(chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform ||\\n        rs.needReadable ||\\n        rs.length < rs.highWaterMark)\\n      this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function(n) {\\n  var ts = this._transformState;\\n\\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\n\\nfunction done(stream, er) {\\n  if (er)\\n    return stream.emit('error', er);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  var ws = stream._writableState;\\n  var ts = stream._transformState;\\n\\n  if (ws.length)\\n    throw new Error('calling transform done when ws.length != 0');\\n\\n  if (ts.transforming)\\n    throw new Error('calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n\\n},{\\\"./_stream_duplex\\\":53,\\\"core-util-is\\\":58,\\\"inherits\\\":48}],57:[function(require,module,exports){\\n(function (process){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\nmodule.exports = Writable;\\n\\n/*<replacement>*/\\nvar Buffer = require('buffer').Buffer;\\n/*</replacement>*/\\n\\nWritable.WritableState = WritableState;\\n\\n\\n/*<replacement>*/\\nvar util = require('core-util-is');\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nvar Stream = require('stream');\\n\\nutil.inherits(Writable, Stream);\\n\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n}\\n\\nfunction WritableState(options, stream) {\\n  var Duplex = require('./_stream_duplex');\\n\\n  options = options || {};\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Duplex)\\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function(er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n\\n  this.buffer = [];\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n}\\n\\nfunction Writable(options) {\\n  var Duplex = require('./_stream_duplex');\\n\\n  // Writable ctor is applied to Duplexes, though they're not\\n  // instanceof Writable, they're instanceof Readable.\\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\\n    return new Writable(options);\\n\\n  this._writableState = new WritableState(options, this);\\n\\n  // legacy.\\n  this.writable = true;\\n\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function() {\\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\\n};\\n\\n\\nfunction writeAfterEnd(stream, state, cb) {\\n  var er = new Error('write after end');\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  stream.emit('error', er);\\n  process.nextTick(function() {\\n    cb(er);\\n  });\\n}\\n\\n// If we get something that is not a buffer, string, null, or undefined,\\n// and we're not in objectMode, then that's an error.\\n// Otherwise stream chunks are all considered to be of length=1, and the\\n// watermarks determine how many objects to keep in the buffer, rather than\\n// how many bytes or characters.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var valid = true;\\n  if (!util.isBuffer(chunk) &&\\n      !util.isString(chunk) &&\\n      !util.isNullOrUndefined(chunk) &&\\n      !state.objectMode) {\\n    var er = new TypeError('Invalid non-string/buffer chunk');\\n    stream.emit('error', er);\\n    process.nextTick(function() {\\n      cb(er);\\n    });\\n    valid = false;\\n  }\\n  return valid;\\n}\\n\\nWritable.prototype.write = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n\\n  if (util.isFunction(encoding)) {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (util.isBuffer(chunk))\\n    encoding = 'buffer';\\n  else if (!encoding)\\n    encoding = state.defaultEncoding;\\n\\n  if (!util.isFunction(cb))\\n    cb = function() {};\\n\\n  if (state.ended)\\n    writeAfterEnd(this, state, cb);\\n  else if (validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n};\\n\\nWritable.prototype.cork = function() {\\n  var state = this._writableState;\\n\\n  state.corked++;\\n};\\n\\nWritable.prototype.uncork = function() {\\n  var state = this._writableState;\\n\\n  if (state.corked) {\\n    state.corked--;\\n\\n    if (!state.writing &&\\n        !state.corked &&\\n        !state.finished &&\\n        !state.bufferProcessing &&\\n        state.buffer.length)\\n      clearBuffer(this, state);\\n  }\\n};\\n\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode &&\\n      state.decodeStrings !== false &&\\n      util.isString(chunk)) {\\n    chunk = new Buffer(chunk, encoding);\\n  }\\n  return chunk;\\n}\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\\n  chunk = decodeChunk(state, chunk, encoding);\\n  if (util.isBuffer(chunk))\\n    encoding = 'buffer';\\n  var len = state.objectMode ? 1 : chunk.length;\\n\\n  state.length += len;\\n\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret)\\n    state.needDrain = true;\\n\\n  if (state.writing || state.corked)\\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\\n  else\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n\\n  return ret;\\n}\\n\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (writev)\\n    stream._writev(chunk, state.onwrite);\\n  else\\n    stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\n\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  if (sync)\\n    process.nextTick(function() {\\n      state.pendingcb--;\\n      cb(er);\\n    });\\n  else {\\n    state.pendingcb--;\\n    cb(er);\\n  }\\n\\n  stream._writableState.errorEmitted = true;\\n  stream.emit('error', er);\\n}\\n\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\n\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n\\n  onwriteStateUpdate(state);\\n\\n  if (er)\\n    onwriteError(stream, state, sync, er, cb);\\n  else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(stream, state);\\n\\n    if (!finished &&\\n        !state.corked &&\\n        !state.bufferProcessing &&\\n        state.buffer.length) {\\n      clearBuffer(stream, state);\\n    }\\n\\n    if (sync) {\\n      process.nextTick(function() {\\n        afterWrite(stream, state, finished, cb);\\n      });\\n    } else {\\n      afterWrite(stream, state, finished, cb);\\n    }\\n  }\\n}\\n\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished)\\n    onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n\\n  if (stream._writev && state.buffer.length > 1) {\\n    // Fast case, write everything using _writev()\\n    var cbs = [];\\n    for (var c = 0; c < state.buffer.length; c++)\\n      cbs.push(state.buffer[c].callback);\\n\\n    // count the one we are adding, as well.\\n    // TODO(isaacs) clean this up\\n    state.pendingcb++;\\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\\n      for (var i = 0; i < cbs.length; i++) {\\n        state.pendingcb--;\\n        cbs[i](err);\\n      }\\n    });\\n\\n    // Clear buffer\\n    state.buffer = [];\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    for (var c = 0; c < state.buffer.length; c++) {\\n      var entry = state.buffer[c];\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        c++;\\n        break;\\n      }\\n    }\\n\\n    if (c < state.buffer.length)\\n      state.buffer = state.buffer.slice(c);\\n    else\\n      state.buffer.length = 0;\\n  }\\n\\n  state.bufferProcessing = false;\\n}\\n\\nWritable.prototype._write = function(chunk, encoding, cb) {\\n  cb(new Error('not implemented'));\\n\\n};\\n\\nWritable.prototype._writev = null;\\n\\nWritable.prototype.end = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n\\n  if (util.isFunction(chunk)) {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (util.isFunction(encoding)) {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (!util.isNullOrUndefined(chunk))\\n    this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending && !state.finished)\\n    endWritable(this, state, cb);\\n};\\n\\n\\nfunction needFinish(stream, state) {\\n  return (state.ending &&\\n          state.length === 0 &&\\n          !state.finished &&\\n          !state.writing);\\n}\\n\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished) {\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n  }\\n}\\n\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(stream, state);\\n  if (need) {\\n    if (state.pendingcb === 0) {\\n      prefinish(stream, state);\\n      state.finished = true;\\n      stream.emit('finish');\\n    } else\\n      prefinish(stream, state);\\n  }\\n  return need;\\n}\\n\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished)\\n      process.nextTick(cb);\\n    else\\n      stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n}\\n\\n}).call(this,require('_process'))\\n},{\\\"./_stream_duplex\\\":53,\\\"_process\\\":51,\\\"buffer\\\":43,\\\"core-util-is\\\":58,\\\"inherits\\\":48,\\\"stream\\\":63}],58:[function(require,module,exports){\\n(function (Buffer){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\n// because it is fragile and can be easily faked with `Object.create()`.\\nfunction isArray(ar) {\\n  return Array.isArray(ar);\\n}\\nexports.isArray = isArray;\\n\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\nexports.isBoolean = isBoolean;\\n\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\nexports.isNull = isNull;\\n\\nfunction isNullOrUndefined(arg) {\\n  return arg == null;\\n}\\nexports.isNullOrUndefined = isNullOrUndefined;\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\nexports.isNumber = isNumber;\\n\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\nexports.isString = isString;\\n\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\nexports.isSymbol = isSymbol;\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\nexports.isUndefined = isUndefined;\\n\\nfunction isRegExp(re) {\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\n}\\nexports.isRegExp = isRegExp;\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\nexports.isObject = isObject;\\n\\nfunction isDate(d) {\\n  return isObject(d) && objectToString(d) === '[object Date]';\\n}\\nexports.isDate = isDate;\\n\\nfunction isError(e) {\\n  return isObject(e) &&\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\n}\\nexports.isError = isError;\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\nexports.isFunction = isFunction;\\n\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         typeof arg === 'boolean' ||\\n         typeof arg === 'number' ||\\n         typeof arg === 'string' ||\\n         typeof arg === 'symbol' ||  // ES6 symbol\\n         typeof arg === 'undefined';\\n}\\nexports.isPrimitive = isPrimitive;\\n\\nfunction isBuffer(arg) {\\n  return Buffer.isBuffer(arg);\\n}\\nexports.isBuffer = isBuffer;\\n\\nfunction objectToString(o) {\\n  return Object.prototype.toString.call(o);\\n}\\n}).call(this,require(\\\"buffer\\\").Buffer)\\n},{\\\"buffer\\\":43}],59:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_passthrough.js\\\")\\n\\n},{\\\"./lib/_stream_passthrough.js\\\":54}],60:[function(require,module,exports){\\nexports = module.exports = require('./lib/_stream_readable.js');\\nexports.Stream = require('stream');\\nexports.Readable = exports;\\nexports.Writable = require('./lib/_stream_writable.js');\\nexports.Duplex = require('./lib/_stream_duplex.js');\\nexports.Transform = require('./lib/_stream_transform.js');\\nexports.PassThrough = require('./lib/_stream_passthrough.js');\\n\\n},{\\\"./lib/_stream_duplex.js\\\":53,\\\"./lib/_stream_passthrough.js\\\":54,\\\"./lib/_stream_readable.js\\\":55,\\\"./lib/_stream_transform.js\\\":56,\\\"./lib/_stream_writable.js\\\":57,\\\"stream\\\":63}],61:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_transform.js\\\")\\n\\n},{\\\"./lib/_stream_transform.js\\\":56}],62:[function(require,module,exports){\\nmodule.exports = require(\\\"./lib/_stream_writable.js\\\")\\n\\n},{\\\"./lib/_stream_writable.js\\\":57}],63:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nmodule.exports = Stream;\\n\\nvar EE = require('events').EventEmitter;\\nvar inherits = require('inherits');\\n\\ninherits(Stream, EE);\\nStream.Readable = require('readable-stream/readable.js');\\nStream.Writable = require('readable-stream/writable.js');\\nStream.Duplex = require('readable-stream/duplex.js');\\nStream.Transform = require('readable-stream/transform.js');\\nStream.PassThrough = require('readable-stream/passthrough.js');\\n\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\n\\n\\n// old-style streams.  Note that the pipe method (the only relevant\\n// part of this class) is overridden in the Readable class.\\n\\nfunction Stream() {\\n  EE.call(this);\\n}\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (EE.listenerCount(this, 'error') === 0) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.removeListener('data', ondata);\\n    dest.removeListener('drain', ondrain);\\n\\n    source.removeListener('end', onend);\\n    source.removeListener('close', onclose);\\n\\n    source.removeListener('error', onerror);\\n    dest.removeListener('error', onerror);\\n\\n    source.removeListener('end', cleanup);\\n    source.removeListener('close', cleanup);\\n\\n    dest.removeListener('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n};\\n\\n},{\\\"events\\\":47,\\\"inherits\\\":48,\\\"readable-stream/duplex.js\\\":52,\\\"readable-stream/passthrough.js\\\":59,\\\"readable-stream/readable.js\\\":60,\\\"readable-stream/transform.js\\\":61,\\\"readable-stream/writable.js\\\":62}],64:[function(require,module,exports){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar Buffer = require('buffer').Buffer;\\n\\nvar isBufferEncoding = Buffer.isEncoding\\n  || function(encoding) {\\n       switch (encoding && encoding.toLowerCase()) {\\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\\n         default: return false;\\n       }\\n     }\\n\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && !isBufferEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\n// StringDecoder provides an interface for efficiently splitting a series of\\n// buffers into a series of JS strings without breaking apart multi-byte\\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\\n//\\n// @TODO Handling all encodings inside a single object makes it very difficult\\n// to reason about this code, so it should be split up in the future.\\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\\n// points as used by CESU-8.\\nvar StringDecoder = exports.StringDecoder = function(encoding) {\\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\\n  assertEncoding(encoding);\\n  switch (this.encoding) {\\n    case 'utf8':\\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\\n      this.surrogateSize = 3;\\n      break;\\n    case 'ucs2':\\n    case 'utf16le':\\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\\n      this.surrogateSize = 2;\\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\\n      break;\\n    case 'base64':\\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\\n      this.surrogateSize = 3;\\n      this.detectIncompleteChar = base64DetectIncompleteChar;\\n      break;\\n    default:\\n      this.write = passThroughWrite;\\n      return;\\n  }\\n\\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\\n  this.charBuffer = new Buffer(6);\\n  // Number of bytes received for the current incomplete multi-byte character.\\n  this.charReceived = 0;\\n  // Number of bytes expected for the current incomplete multi-byte character.\\n  this.charLength = 0;\\n};\\n\\n\\n// write decodes the given buffer and returns it as JS string that is\\n// guaranteed to not contain any partial multi-byte characters. Any partial\\n// character found at the end of the buffer is buffered up, and will be\\n// returned when calling write again with the remaining bytes.\\n//\\n// Note: Converting a Buffer containing an orphan surrogate to a String\\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\\n// Buffer#write) will replace incomplete surrogates with the unicode\\n// replacement character. See https://codereview.chromium.org/121173009/ .\\nStringDecoder.prototype.write = function(buffer) {\\n  var charStr = '';\\n  // if our last write ended with an incomplete multibyte character\\n  while (this.charLength) {\\n    // determine how many remaining bytes this buffer has to offer for this char\\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\\n        this.charLength - this.charReceived :\\n        buffer.length;\\n\\n    // add the new bytes to the char buffer\\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\\n    this.charReceived += available;\\n\\n    if (this.charReceived < this.charLength) {\\n      // still not enough chars in this buffer? wait for more ...\\n      return '';\\n    }\\n\\n    // remove bytes belonging to the current character from the buffer\\n    buffer = buffer.slice(available, buffer.length);\\n\\n    // get the character that was split\\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\\n\\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n    var charCode = charStr.charCodeAt(charStr.length - 1);\\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n      this.charLength += this.surrogateSize;\\n      charStr = '';\\n      continue;\\n    }\\n    this.charReceived = this.charLength = 0;\\n\\n    // if there are no more bytes in this buffer, just emit our char\\n    if (buffer.length === 0) {\\n      return charStr;\\n    }\\n    break;\\n  }\\n\\n  // determine and set charLength / charReceived\\n  this.detectIncompleteChar(buffer);\\n\\n  var end = buffer.length;\\n  if (this.charLength) {\\n    // buffer the incomplete character bytes we got\\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\\n    end -= this.charReceived;\\n  }\\n\\n  charStr += buffer.toString(this.encoding, 0, end);\\n\\n  var end = charStr.length - 1;\\n  var charCode = charStr.charCodeAt(end);\\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n    var size = this.surrogateSize;\\n    this.charLength += size;\\n    this.charReceived += size;\\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\\n    buffer.copy(this.charBuffer, 0, 0, size);\\n    return charStr.substring(0, end);\\n  }\\n\\n  // or just emit the charStr\\n  return charStr;\\n};\\n\\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\\n// the end of the given buffer. If so, it sets this.charLength to the byte\\n// length that character, and sets this.charReceived to the number of bytes\\n// that are available for this character.\\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\\n  // determine how many bytes we have to check at the end of this buffer\\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\\n\\n  // Figure out if one of the last i bytes of our buffer announces an\\n  // incomplete char.\\n  for (; i > 0; i--) {\\n    var c = buffer[buffer.length - i];\\n\\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\\n\\n    // 110XXXXX\\n    if (i == 1 && c >> 5 == 0x06) {\\n      this.charLength = 2;\\n      break;\\n    }\\n\\n    // 1110XXXX\\n    if (i <= 2 && c >> 4 == 0x0E) {\\n      this.charLength = 3;\\n      break;\\n    }\\n\\n    // 11110XXX\\n    if (i <= 3 && c >> 3 == 0x1E) {\\n      this.charLength = 4;\\n      break;\\n    }\\n  }\\n  this.charReceived = i;\\n};\\n\\nStringDecoder.prototype.end = function(buffer) {\\n  var res = '';\\n  if (buffer && buffer.length)\\n    res = this.write(buffer);\\n\\n  if (this.charReceived) {\\n    var cr = this.charReceived;\\n    var buf = this.charBuffer;\\n    var enc = this.encoding;\\n    res += buf.slice(0, cr).toString(enc);\\n  }\\n\\n  return res;\\n};\\n\\nfunction passThroughWrite(buffer) {\\n  return buffer.toString(this.encoding);\\n}\\n\\nfunction utf16DetectIncompleteChar(buffer) {\\n  this.charReceived = buffer.length % 2;\\n  this.charLength = this.charReceived ? 2 : 0;\\n}\\n\\nfunction base64DetectIncompleteChar(buffer) {\\n  this.charReceived = buffer.length % 3;\\n  this.charLength = this.charReceived ? 3 : 0;\\n}\\n\\n},{\\\"buffer\\\":43}],65:[function(require,module,exports){\\nmodule.exports = function isBuffer(arg) {\\n  return arg && typeof arg === 'object'\\n    && typeof arg.copy === 'function'\\n    && typeof arg.fill === 'function'\\n    && typeof arg.readUInt8 === 'function';\\n}\\n},{}],66:[function(require,module,exports){\\n(function (process,global){\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar formatRegExp = /%[sdj%]/g;\\nexports.format = function(f) {\\n  if (!isString(f)) {\\n    var objects = [];\\n    for (var i = 0; i < arguments.length; i++) {\\n      objects.push(inspect(arguments[i]));\\n    }\\n    return objects.join(' ');\\n  }\\n\\n  var i = 1;\\n  var args = arguments;\\n  var len = args.length;\\n  var str = String(f).replace(formatRegExp, function(x) {\\n    if (x === '%%') return '%';\\n    if (i >= len) return x;\\n    switch (x) {\\n      case '%s': return String(args[i++]);\\n      case '%d': return Number(args[i++]);\\n      case '%j':\\n        try {\\n          return JSON.stringify(args[i++]);\\n        } catch (_) {\\n          return '[Circular]';\\n        }\\n      default:\\n        return x;\\n    }\\n  });\\n  for (var x = args[i]; i < len; x = args[++i]) {\\n    if (isNull(x) || !isObject(x)) {\\n      str += ' ' + x;\\n    } else {\\n      str += ' ' + inspect(x);\\n    }\\n  }\\n  return str;\\n};\\n\\n\\n// Mark that a method should not be used.\\n// Returns a modified function which warns once by default.\\n// If --no-deprecation is set, then it is a no-op.\\nexports.deprecate = function(fn, msg) {\\n  // Allow for deprecating things in the process of starting up.\\n  if (isUndefined(global.process)) {\\n    return function() {\\n      return exports.deprecate(fn, msg).apply(this, arguments);\\n    };\\n  }\\n\\n  if (process.noDeprecation === true) {\\n    return fn;\\n  }\\n\\n  var warned = false;\\n  function deprecated() {\\n    if (!warned) {\\n      if (process.throwDeprecation) {\\n        throw new Error(msg);\\n      } else if (process.traceDeprecation) {\\n        console.trace(msg);\\n      } else {\\n        console.error(msg);\\n      }\\n      warned = true;\\n    }\\n    return fn.apply(this, arguments);\\n  }\\n\\n  return deprecated;\\n};\\n\\n\\nvar debugs = {};\\nvar debugEnviron;\\nexports.debuglog = function(set) {\\n  if (isUndefined(debugEnviron))\\n    debugEnviron = process.env.NODE_DEBUG || '';\\n  set = set.toUpperCase();\\n  if (!debugs[set]) {\\n    if (new RegExp('\\\\\\\\b' + set + '\\\\\\\\b', 'i').test(debugEnviron)) {\\n      var pid = process.pid;\\n      debugs[set] = function() {\\n        var msg = exports.format.apply(exports, arguments);\\n        console.error('%s %d: %s', set, pid, msg);\\n      };\\n    } else {\\n      debugs[set] = function() {};\\n    }\\n  }\\n  return debugs[set];\\n};\\n\\n\\n/**\\n * Echos the value of a value. Trys to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {Object} obj The object to print out.\\n * @param {Object} opts Optional options object that alters the output.\\n */\\n/* legacy: obj, showHidden, depth, colors*/\\nfunction inspect(obj, opts) {\\n  // default options\\n  var ctx = {\\n    seen: [],\\n    stylize: stylizeNoColor\\n  };\\n  // legacy...\\n  if (arguments.length >= 3) ctx.depth = arguments[2];\\n  if (arguments.length >= 4) ctx.colors = arguments[3];\\n  if (isBoolean(opts)) {\\n    // legacy...\\n    ctx.showHidden = opts;\\n  } else if (opts) {\\n    // got an \\\"options\\\" object\\n    exports._extend(ctx, opts);\\n  }\\n  // set default options\\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\\n  if (isUndefined(ctx.colors)) ctx.colors = false;\\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  return formatValue(ctx, obj, ctx.depth);\\n}\\nexports.inspect = inspect;\\n\\n\\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\ninspect.colors = {\\n  'bold' : [1, 22],\\n  'italic' : [3, 23],\\n  'underline' : [4, 24],\\n  'inverse' : [7, 27],\\n  'white' : [37, 39],\\n  'grey' : [90, 39],\\n  'black' : [30, 39],\\n  'blue' : [34, 39],\\n  'cyan' : [36, 39],\\n  'green' : [32, 39],\\n  'magenta' : [35, 39],\\n  'red' : [31, 39],\\n  'yellow' : [33, 39]\\n};\\n\\n// Don't use 'blue' not visible on cmd.exe\\ninspect.styles = {\\n  'special': 'cyan',\\n  'number': 'yellow',\\n  'boolean': 'yellow',\\n  'undefined': 'grey',\\n  'null': 'bold',\\n  'string': 'green',\\n  'date': 'magenta',\\n  // \\\"name\\\": intentionally not styling\\n  'regexp': 'red'\\n};\\n\\n\\nfunction stylizeWithColor(str, styleType) {\\n  var style = inspect.styles[styleType];\\n\\n  if (style) {\\n    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str +\\n           '\\\\u001b[' + inspect.colors[style][1] + 'm';\\n  } else {\\n    return str;\\n  }\\n}\\n\\n\\nfunction stylizeNoColor(str, styleType) {\\n  return str;\\n}\\n\\n\\nfunction arrayToHash(array) {\\n  var hash = {};\\n\\n  array.forEach(function(val, idx) {\\n    hash[val] = true;\\n  });\\n\\n  return hash;\\n}\\n\\n\\nfunction formatValue(ctx, value, recurseTimes) {\\n  // Provide a hook for user-specified inspect functions.\\n  // Check that value is an object with an inspect function on it\\n  if (ctx.customInspect &&\\n      value &&\\n      isFunction(value.inspect) &&\\n      // Filter out the util module, it's inspect function is special\\n      value.inspect !== exports.inspect &&\\n      // Also filter out any prototype objects using the circular check.\\n      !(value.constructor && value.constructor.prototype === value)) {\\n    var ret = value.inspect(recurseTimes, ctx);\\n    if (!isString(ret)) {\\n      ret = formatValue(ctx, ret, recurseTimes);\\n    }\\n    return ret;\\n  }\\n\\n  // Primitive types cannot have properties\\n  var primitive = formatPrimitive(ctx, value);\\n  if (primitive) {\\n    return primitive;\\n  }\\n\\n  // Look up the keys of the object.\\n  var keys = Object.keys(value);\\n  var visibleKeys = arrayToHash(keys);\\n\\n  if (ctx.showHidden) {\\n    keys = Object.getOwnPropertyNames(value);\\n  }\\n\\n  // IE doesn't make error fields non-enumerable\\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\\n  if (isError(value)\\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\\n    return formatError(value);\\n  }\\n\\n  // Some type of object without properties can be shortcutted.\\n  if (keys.length === 0) {\\n    if (isFunction(value)) {\\n      var name = value.name ? ': ' + value.name : '';\\n      return ctx.stylize('[Function' + name + ']', 'special');\\n    }\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    }\\n    if (isDate(value)) {\\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\\n    }\\n    if (isError(value)) {\\n      return formatError(value);\\n    }\\n  }\\n\\n  var base = '', array = false, braces = ['{', '}'];\\n\\n  // Make Array say that they are Array\\n  if (isArray(value)) {\\n    array = true;\\n    braces = ['[', ']'];\\n  }\\n\\n  // Make functions say that they are functions\\n  if (isFunction(value)) {\\n    var n = value.name ? ': ' + value.name : '';\\n    base = ' [Function' + n + ']';\\n  }\\n\\n  // Make RegExps say that they are RegExps\\n  if (isRegExp(value)) {\\n    base = ' ' + RegExp.prototype.toString.call(value);\\n  }\\n\\n  // Make dates with properties first say the date\\n  if (isDate(value)) {\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\n  }\\n\\n  // Make error with message first say the error\\n  if (isError(value)) {\\n    base = ' ' + formatError(value);\\n  }\\n\\n  if (keys.length === 0 && (!array || value.length == 0)) {\\n    return braces[0] + base + braces[1];\\n  }\\n\\n  if (recurseTimes < 0) {\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    } else {\\n      return ctx.stylize('[Object]', 'special');\\n    }\\n  }\\n\\n  ctx.seen.push(value);\\n\\n  var output;\\n  if (array) {\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\n  } else {\\n    output = keys.map(function(key) {\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\n    });\\n  }\\n\\n  ctx.seen.pop();\\n\\n  return reduceToSingleString(output, base, braces);\\n}\\n\\n\\nfunction formatPrimitive(ctx, value) {\\n  if (isUndefined(value))\\n    return ctx.stylize('undefined', 'undefined');\\n  if (isString(value)) {\\n    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\n                                             .replace(/'/g, \\\"\\\\\\\\'\\\")\\n                                             .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\n    return ctx.stylize(simple, 'string');\\n  }\\n  if (isNumber(value))\\n    return ctx.stylize('' + value, 'number');\\n  if (isBoolean(value))\\n    return ctx.stylize('' + value, 'boolean');\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\n  if (isNull(value))\\n    return ctx.stylize('null', 'null');\\n}\\n\\n\\nfunction formatError(value) {\\n  return '[' + Error.prototype.toString.call(value) + ']';\\n}\\n\\n\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\n  var output = [];\\n  for (var i = 0, l = value.length; i < l; ++i) {\\n    if (hasOwnProperty(value, String(i))) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          String(i), true));\\n    } else {\\n      output.push('');\\n    }\\n  }\\n  keys.forEach(function(key) {\\n    if (!key.match(/^\\\\d+$/)) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          key, true));\\n    }\\n  });\\n  return output;\\n}\\n\\n\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\n  var name, str, desc;\\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\\n  if (desc.get) {\\n    if (desc.set) {\\n      str = ctx.stylize('[Getter/Setter]', 'special');\\n    } else {\\n      str = ctx.stylize('[Getter]', 'special');\\n    }\\n  } else {\\n    if (desc.set) {\\n      str = ctx.stylize('[Setter]', 'special');\\n    }\\n  }\\n  if (!hasOwnProperty(visibleKeys, key)) {\\n    name = '[' + key + ']';\\n  }\\n  if (!str) {\\n    if (ctx.seen.indexOf(desc.value) < 0) {\\n      if (isNull(recurseTimes)) {\\n        str = formatValue(ctx, desc.value, null);\\n      } else {\\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\\n      }\\n      if (str.indexOf('\\\\n') > -1) {\\n        if (array) {\\n          str = str.split('\\\\n').map(function(line) {\\n            return '  ' + line;\\n          }).join('\\\\n').substr(2);\\n        } else {\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\n            return '   ' + line;\\n          }).join('\\\\n');\\n        }\\n      }\\n    } else {\\n      str = ctx.stylize('[Circular]', 'special');\\n    }\\n  }\\n  if (isUndefined(name)) {\\n    if (array && key.match(/^\\\\d+$/)) {\\n      return str;\\n    }\\n    name = JSON.stringify('' + key);\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\n      name = name.substr(1, name.length - 2);\\n      name = ctx.stylize(name, 'name');\\n    } else {\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\");\\n      name = ctx.stylize(name, 'string');\\n    }\\n  }\\n\\n  return name + ': ' + str;\\n}\\n\\n\\nfunction reduceToSingleString(output, base, braces) {\\n  var numLinesEst = 0;\\n  var length = output.reduce(function(prev, cur) {\\n    numLinesEst++;\\n    if (cur.indexOf('\\\\n') >= 0) numLinesEst++;\\n    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;\\n  }, 0);\\n\\n  if (length > 60) {\\n    return braces[0] +\\n           (base === '' ? '' : base + '\\\\n ') +\\n           ' ' +\\n           output.join(',\\\\n  ') +\\n           ' ' +\\n           braces[1];\\n  }\\n\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\n}\\n\\n\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\n// because it is fragile and can be easily faked with `Object.create()`.\\nfunction isArray(ar) {\\n  return Array.isArray(ar);\\n}\\nexports.isArray = isArray;\\n\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\nexports.isBoolean = isBoolean;\\n\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\nexports.isNull = isNull;\\n\\nfunction isNullOrUndefined(arg) {\\n  return arg == null;\\n}\\nexports.isNullOrUndefined = isNullOrUndefined;\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\nexports.isNumber = isNumber;\\n\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\nexports.isString = isString;\\n\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\nexports.isSymbol = isSymbol;\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\nexports.isUndefined = isUndefined;\\n\\nfunction isRegExp(re) {\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\n}\\nexports.isRegExp = isRegExp;\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\nexports.isObject = isObject;\\n\\nfunction isDate(d) {\\n  return isObject(d) && objectToString(d) === '[object Date]';\\n}\\nexports.isDate = isDate;\\n\\nfunction isError(e) {\\n  return isObject(e) &&\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\n}\\nexports.isError = isError;\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\nexports.isFunction = isFunction;\\n\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         typeof arg === 'boolean' ||\\n         typeof arg === 'number' ||\\n         typeof arg === 'string' ||\\n         typeof arg === 'symbol' ||  // ES6 symbol\\n         typeof arg === 'undefined';\\n}\\nexports.isPrimitive = isPrimitive;\\n\\nexports.isBuffer = require('./support/isBuffer');\\n\\nfunction objectToString(o) {\\n  return Object.prototype.toString.call(o);\\n}\\n\\n\\nfunction pad(n) {\\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\\n}\\n\\n\\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\\n              'Oct', 'Nov', 'Dec'];\\n\\n// 26 Feb 16:19:34\\nfunction timestamp() {\\n  var d = new Date();\\n  var time = [pad(d.getHours()),\\n              pad(d.getMinutes()),\\n              pad(d.getSeconds())].join(':');\\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\\n}\\n\\n\\n// log is just a thin wrapper to console.log that prepends a timestamp\\nexports.log = function() {\\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\\n};\\n\\n\\n/**\\n * Inherit the prototype methods from one constructor into another.\\n *\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\n * during bootstrapping this function needs to be rewritten using some native\\n * functions as prototype setup using normal JavaScript does not work as\\n * expected during bootstrapping (see mirror.js in r114903).\\n *\\n * @param {function} ctor Constructor function which needs to inherit the\\n *     prototype.\\n * @param {function} superCtor Constructor function to inherit prototype from.\\n */\\nexports.inherits = require('inherits');\\n\\nexports._extend = function(origin, add) {\\n  // Don't do anything if add isn't an object\\n  if (!add || !isObject(add)) return origin;\\n\\n  var keys = Object.keys(add);\\n  var i = keys.length;\\n  while (i--) {\\n    origin[keys[i]] = add[keys[i]];\\n  }\\n  return origin;\\n};\\n\\nfunction hasOwnProperty(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./support/isBuffer\\\":65,\\\"_process\\\":51,\\\"inherits\\\":48}],67:[function(require,module,exports){\\n/* See LICENSE file for terms of use */\\n\\n/*\\n * Text diff implementation.\\n *\\n * This library supports the following APIS:\\n * JsDiff.diffChars: Character by character diff\\n * JsDiff.diffWords: Word (as defined by \\\\b regex) diff which ignores whitespace\\n * JsDiff.diffLines: Line based diff\\n *\\n * JsDiff.diffCss: Diff targeted at CSS content\\n *\\n * These methods are based on the implementation proposed in\\n * \\\"An O(ND) Difference Algorithm and its Variations\\\" (Myers, 1986).\\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\\n */\\n(function(global, undefined) {\\n  var objectPrototypeToString = Object.prototype.toString;\\n\\n  /*istanbul ignore next*/\\n  function map(arr, mapper, that) {\\n    if (Array.prototype.map) {\\n      return Array.prototype.map.call(arr, mapper, that);\\n    }\\n\\n    var other = new Array(arr.length);\\n\\n    for (var i = 0, n = arr.length; i < n; i++) {\\n      other[i] = mapper.call(that, arr[i], i, arr);\\n    }\\n    return other;\\n  }\\n  function clonePath(path) {\\n    return { newPos: path.newPos, components: path.components.slice(0) };\\n  }\\n  function removeEmpty(array) {\\n    var ret = [];\\n    for (var i = 0; i < array.length; i++) {\\n      if (array[i]) {\\n        ret.push(array[i]);\\n      }\\n    }\\n    return ret;\\n  }\\n  function escapeHTML(s) {\\n    var n = s;\\n    n = n.replace(/&/g, '&amp;');\\n    n = n.replace(/</g, '&lt;');\\n    n = n.replace(/>/g, '&gt;');\\n    n = n.replace(/\\\"/g, '&quot;');\\n\\n    return n;\\n  }\\n\\n  // This function handles the presence of circular references by bailing out when encountering an\\n  // object that is already on the \\\"stack\\\" of items being processed.\\n  function canonicalize(obj, stack, replacementStack) {\\n    stack = stack || [];\\n    replacementStack = replacementStack || [];\\n\\n    var i;\\n\\n    for (i = 0; i < stack.length; i += 1) {\\n      if (stack[i] === obj) {\\n        return replacementStack[i];\\n      }\\n    }\\n\\n    var canonicalizedObj;\\n\\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\\n      stack.push(obj);\\n      canonicalizedObj = new Array(obj.length);\\n      replacementStack.push(canonicalizedObj);\\n      for (i = 0; i < obj.length; i += 1) {\\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\\n      }\\n      stack.pop();\\n      replacementStack.pop();\\n    } else if (typeof obj === 'object' && obj !== null) {\\n      stack.push(obj);\\n      canonicalizedObj = {};\\n      replacementStack.push(canonicalizedObj);\\n      var sortedKeys = [],\\n          key;\\n      for (key in obj) {\\n        sortedKeys.push(key);\\n      }\\n      sortedKeys.sort();\\n      for (i = 0; i < sortedKeys.length; i += 1) {\\n        key = sortedKeys[i];\\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\\n      }\\n      stack.pop();\\n      replacementStack.pop();\\n    } else {\\n      canonicalizedObj = obj;\\n    }\\n    return canonicalizedObj;\\n  }\\n\\n  function buildValues(components, newString, oldString, useLongestToken) {\\n    var componentPos = 0,\\n        componentLen = components.length,\\n        newPos = 0,\\n        oldPos = 0;\\n\\n    for (; componentPos < componentLen; componentPos++) {\\n      var component = components[componentPos];\\n      if (!component.removed) {\\n        if (!component.added && useLongestToken) {\\n          var value = newString.slice(newPos, newPos + component.count);\\n          value = map(value, function(value, i) {\\n            var oldValue = oldString[oldPos + i];\\n            return oldValue.length > value.length ? oldValue : value;\\n          });\\n\\n          component.value = value.join('');\\n        } else {\\n          component.value = newString.slice(newPos, newPos + component.count).join('');\\n        }\\n        newPos += component.count;\\n\\n        // Common case\\n        if (!component.added) {\\n          oldPos += component.count;\\n        }\\n      } else {\\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\\n        oldPos += component.count;\\n\\n        // Reverse add and remove so removes are output first to match common convention\\n        // The diffing algorithm is tied to add then remove output and this is the simplest\\n        // route to get the desired output with minimal overhead.\\n        if (componentPos && components[componentPos - 1].added) {\\n          var tmp = components[componentPos - 1];\\n          components[componentPos - 1] = components[componentPos];\\n          components[componentPos] = tmp;\\n        }\\n      }\\n    }\\n\\n    return components;\\n  }\\n\\n  function Diff(ignoreWhitespace) {\\n    this.ignoreWhitespace = ignoreWhitespace;\\n  }\\n  Diff.prototype = {\\n    diff: function(oldString, newString, callback) {\\n      var self = this;\\n\\n      function done(value) {\\n        if (callback) {\\n          setTimeout(function() { callback(undefined, value); }, 0);\\n          return true;\\n        } else {\\n          return value;\\n        }\\n      }\\n\\n      // Handle the identity case (this is due to unrolling editLength == 0\\n      if (newString === oldString) {\\n        return done([{ value: newString }]);\\n      }\\n      if (!newString) {\\n        return done([{ value: oldString, removed: true }]);\\n      }\\n      if (!oldString) {\\n        return done([{ value: newString, added: true }]);\\n      }\\n\\n      newString = this.tokenize(newString);\\n      oldString = this.tokenize(oldString);\\n\\n      var newLen = newString.length, oldLen = oldString.length;\\n      var editLength = 1;\\n      var maxEditLength = newLen + oldLen;\\n      var bestPath = [{ newPos: -1, components: [] }];\\n\\n      // Seed editLength = 0, i.e. the content starts with the same values\\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\\n        // Identity per the equality and tokenizer\\n        return done([{value: newString.join('')}]);\\n      }\\n\\n      // Main worker method. checks all permutations of a given edit length for acceptance.\\n      function execEditLength() {\\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\\n          var basePath;\\n          var addPath = bestPath[diagonalPath - 1],\\n              removePath = bestPath[diagonalPath + 1],\\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\\n          if (addPath) {\\n            // No one else is going to attempt to use this value, clear it\\n            bestPath[diagonalPath - 1] = undefined;\\n          }\\n\\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\\n          if (!canAdd && !canRemove) {\\n            // If this path is a terminal then prune\\n            bestPath[diagonalPath] = undefined;\\n            continue;\\n          }\\n\\n          // Select the diagonal that we want to branch from. We select the prior\\n          // path whose position in the new string is the farthest from the origin\\n          // and does not pass the bounds of the diff graph\\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\\n            basePath = clonePath(removePath);\\n            self.pushComponent(basePath.components, undefined, true);\\n          } else {\\n            basePath = addPath;   // No need to clone, we've pulled it from the list\\n            basePath.newPos++;\\n            self.pushComponent(basePath.components, true, undefined);\\n          }\\n\\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\\n\\n          // If we have hit the end of both strings, then we are done\\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\\n          } else {\\n            // Otherwise track this path as a potential candidate and continue.\\n            bestPath[diagonalPath] = basePath;\\n          }\\n        }\\n\\n        editLength++;\\n      }\\n\\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\\n      // sync and async mode which is never fun. Loops over execEditLength until a value\\n      // is produced.\\n      if (callback) {\\n        (function exec() {\\n          setTimeout(function() {\\n            // This should not happen, but we want to be safe.\\n            /*istanbul ignore next */\\n            if (editLength > maxEditLength) {\\n              return callback();\\n            }\\n\\n            if (!execEditLength()) {\\n              exec();\\n            }\\n          }, 0);\\n        }());\\n      } else {\\n        while (editLength <= maxEditLength) {\\n          var ret = execEditLength();\\n          if (ret) {\\n            return ret;\\n          }\\n        }\\n      }\\n    },\\n\\n    pushComponent: function(components, added, removed) {\\n      var last = components[components.length - 1];\\n      if (last && last.added === added && last.removed === removed) {\\n        // We need to clone here as the component clone operation is just\\n        // as shallow array clone\\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\\n      } else {\\n        components.push({count: 1, added: added, removed: removed });\\n      }\\n    },\\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\\n      var newLen = newString.length,\\n          oldLen = oldString.length,\\n          newPos = basePath.newPos,\\n          oldPos = newPos - diagonalPath,\\n\\n          commonCount = 0;\\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\\n        newPos++;\\n        oldPos++;\\n        commonCount++;\\n      }\\n\\n      if (commonCount) {\\n        basePath.components.push({count: commonCount});\\n      }\\n\\n      basePath.newPos = newPos;\\n      return oldPos;\\n    },\\n\\n    equals: function(left, right) {\\n      var reWhitespace = /\\\\S/;\\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\\n    },\\n    tokenize: function(value) {\\n      return value.split('');\\n    }\\n  };\\n\\n  var CharDiff = new Diff();\\n\\n  var WordDiff = new Diff(true);\\n  var WordWithSpaceDiff = new Diff();\\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/(\\\\s+|\\\\b)/));\\n  };\\n\\n  var CssDiff = new Diff(true);\\n  CssDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/([{}:;,]|\\\\s+)/));\\n  };\\n\\n  var LineDiff = new Diff();\\n\\n  var TrimmedLineDiff = new Diff();\\n  TrimmedLineDiff.ignoreTrim = true;\\n\\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\\n    var retLines = [],\\n        lines = value.split(/^/m);\\n    for (var i = 0; i < lines.length; i++) {\\n      var line = lines[i],\\n          lastLine = lines[i - 1],\\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\\n\\n      // Merge lines that may contain windows new lines\\n      if (line === '\\\\n' && lastLineLastChar === '\\\\r') {\\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\\\r\\\\n';\\n      } else {\\n        if (this.ignoreTrim) {\\n          line = line.trim();\\n          // add a newline unless this is the last line.\\n          if (i < lines.length - 1) {\\n            line += '\\\\n';\\n          }\\n        }\\n        retLines.push(line);\\n      }\\n    }\\n\\n    return retLines;\\n  };\\n\\n  var PatchDiff = new Diff();\\n  PatchDiff.tokenize = function(value) {\\n    var ret = [],\\n        linesAndNewlines = value.split(/(\\\\n|\\\\r\\\\n)/);\\n\\n    // Ignore the final empty token that occurs if the string ends with a new line\\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\\n      linesAndNewlines.pop();\\n    }\\n\\n    // Merge the content and line separators into single tokens\\n    for (var i = 0; i < linesAndNewlines.length; i++) {\\n      var line = linesAndNewlines[i];\\n\\n      if (i % 2) {\\n        ret[ret.length - 1] += line;\\n      } else {\\n        ret.push(line);\\n      }\\n    }\\n    return ret;\\n  };\\n\\n  var SentenceDiff = new Diff();\\n  SentenceDiff.tokenize = function(value) {\\n    return removeEmpty(value.split(/(\\\\S.+?[.!?])(?=\\\\s+|$)/));\\n  };\\n\\n  var JsonDiff = new Diff();\\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\\n  JsonDiff.useLongestToken = true;\\n  JsonDiff.tokenize = LineDiff.tokenize;\\n  JsonDiff.equals = function(left, right) {\\n    return LineDiff.equals(left.replace(/,([\\\\r\\\\n])/g, '$1'), right.replace(/,([\\\\r\\\\n])/g, '$1'));\\n  };\\n\\n  var JsDiff = {\\n    Diff: Diff,\\n\\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\\n\\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\\n\\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\\n    diffJson: function(oldObj, newObj, callback) {\\n      return JsonDiff.diff(\\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\\n        callback\\n      );\\n    },\\n\\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\\n      var ret = [];\\n\\n      if (oldFileName == newFileName) {\\n        ret.push('Index: ' + oldFileName);\\n      }\\n      ret.push('===================================================================');\\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\\\t' + oldHeader));\\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\\\t' + newHeader));\\n\\n      var diff = PatchDiff.diff(oldStr, newStr);\\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\\n\\n      // Formats a given set of lines for printing as context lines in a patch\\n      function contextLines(lines) {\\n        return map(lines, function(entry) { return ' ' + entry; });\\n      }\\n\\n      // Outputs the no newline at end of file warning if needed\\n      function eofNL(curRange, i, current) {\\n        var last = diff[diff.length - 2],\\n            isLast = i === diff.length - 2,\\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\\n\\n        // Figure out if this is the last line for the given file and missing NL\\n        if (!(/\\\\n$/.test(current.value)) && (isLast || isLastOfType)) {\\n          curRange.push('\\\\\\\\ No newline at end of file');\\n        }\\n      }\\n\\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\\n          oldLine = 1, newLine = 1;\\n      for (var i = 0; i < diff.length; i++) {\\n        var current = diff[i],\\n            lines = current.lines || current.value.replace(/\\\\n$/, '').split('\\\\n');\\n        current.lines = lines;\\n\\n        if (current.added || current.removed) {\\n          // If we have previous context, start with that\\n          if (!oldRangeStart) {\\n            var prev = diff[i - 1];\\n            oldRangeStart = oldLine;\\n            newRangeStart = newLine;\\n\\n            if (prev) {\\n              curRange = contextLines(prev.lines.slice(-4));\\n              oldRangeStart -= curRange.length;\\n              newRangeStart -= curRange.length;\\n            }\\n          }\\n\\n          // Output our changes\\n          curRange.push.apply(curRange, map(lines, function(entry) {\\n            return (current.added ? '+' : '-') + entry;\\n          }));\\n          eofNL(curRange, i, current);\\n\\n          // Track the updated file position\\n          if (current.added) {\\n            newLine += lines.length;\\n          } else {\\n            oldLine += lines.length;\\n          }\\n        } else {\\n          // Identical context lines. Track line changes\\n          if (oldRangeStart) {\\n            // Close out any changes that have been output (or join overlapping)\\n            if (lines.length <= 8 && i < diff.length - 2) {\\n              // Overlapping\\n              curRange.push.apply(curRange, contextLines(lines));\\n            } else {\\n              // end the range and output\\n              var contextSize = Math.min(lines.length, 4);\\n              ret.push(\\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\\n                  + ' @@');\\n              ret.push.apply(ret, curRange);\\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\\n              if (lines.length <= 4) {\\n                eofNL(ret, i, current);\\n              }\\n\\n              oldRangeStart = 0;\\n              newRangeStart = 0;\\n              curRange = [];\\n            }\\n          }\\n          oldLine += lines.length;\\n          newLine += lines.length;\\n        }\\n      }\\n\\n      return ret.join('\\\\n') + '\\\\n';\\n    },\\n\\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\\n    },\\n\\n    applyPatch: function(oldStr, uniDiff) {\\n      var diffstr = uniDiff.split('\\\\n'),\\n          hunks = [],\\n          i = 0,\\n          remEOFNL = false,\\n          addEOFNL = false;\\n\\n      // Skip to the first change hunk\\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\\n        i++;\\n      }\\n\\n      // Parse the unified diff\\n      for (; i < diffstr.length; i++) {\\n        if (diffstr[i][0] === '@') {\\n          var chnukHeader = diffstr[i].split(/@@ -(\\\\d+),(\\\\d+) \\\\+(\\\\d+),(\\\\d+) @@/);\\n          hunks.unshift({\\n            start: chnukHeader[3],\\n            oldlength: +chnukHeader[2],\\n            removed: [],\\n            newlength: chnukHeader[4],\\n            added: []\\n          });\\n        } else if (diffstr[i][0] === '+') {\\n          hunks[0].added.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === '-') {\\n          hunks[0].removed.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === ' ') {\\n          hunks[0].added.push(diffstr[i].substr(1));\\n          hunks[0].removed.push(diffstr[i].substr(1));\\n        } else if (diffstr[i][0] === '\\\\\\\\') {\\n          if (diffstr[i - 1][0] === '+') {\\n            remEOFNL = true;\\n          } else if (diffstr[i - 1][0] === '-') {\\n            addEOFNL = true;\\n          }\\n        }\\n      }\\n\\n      // Apply the diff to the input\\n      var lines = oldStr.split('\\\\n');\\n      for (i = hunks.length - 1; i >= 0; i--) {\\n        var hunk = hunks[i];\\n        // Sanity check the input string. Bail if we don't match.\\n        for (var j = 0; j < hunk.oldlength; j++) {\\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\\n            return false;\\n          }\\n        }\\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\\n      }\\n\\n      // Handle EOFNL insertion/removal\\n      if (remEOFNL) {\\n        while (!lines[lines.length - 1]) {\\n          lines.pop();\\n        }\\n      } else if (addEOFNL) {\\n        lines.push('');\\n      }\\n      return lines.join('\\\\n');\\n    },\\n\\n    convertChangesToXML: function(changes) {\\n      var ret = [];\\n      for (var i = 0; i < changes.length; i++) {\\n        var change = changes[i];\\n        if (change.added) {\\n          ret.push('<ins>');\\n        } else if (change.removed) {\\n          ret.push('<del>');\\n        }\\n\\n        ret.push(escapeHTML(change.value));\\n\\n        if (change.added) {\\n          ret.push('</ins>');\\n        } else if (change.removed) {\\n          ret.push('</del>');\\n        }\\n      }\\n      return ret.join('');\\n    },\\n\\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\\n    convertChangesToDMP: function(changes) {\\n      var ret = [],\\n          change,\\n          operation;\\n      for (var i = 0; i < changes.length; i++) {\\n        change = changes[i];\\n        if (change.added) {\\n          operation = 1;\\n        } else if (change.removed) {\\n          operation = -1;\\n        } else {\\n          operation = 0;\\n        }\\n\\n        ret.push([operation, change.value]);\\n      }\\n      return ret;\\n    },\\n\\n    canonicalize: canonicalize\\n  };\\n\\n  /*istanbul ignore next */\\n  /*global module */\\n  if (typeof module !== 'undefined' && module.exports) {\\n    module.exports = JsDiff;\\n  } else if (typeof define === 'function' && define.amd) {\\n    /*global define */\\n    define([], function() { return JsDiff; });\\n  } else if (typeof global.JsDiff === 'undefined') {\\n    global.JsDiff = JsDiff;\\n  }\\n}(this));\\n\\n},{}],68:[function(require,module,exports){\\n'use strict';\\n\\nvar matchOperatorsRe = /[|\\\\\\\\{}()[\\\\]^$+*?.]/g;\\n\\nmodule.exports = function (str) {\\n\\tif (typeof str !== 'string') {\\n\\t\\tthrow new TypeError('Expected a string');\\n\\t}\\n\\n\\treturn str.replace(matchOperatorsRe,  '\\\\\\\\$&');\\n};\\n\\n},{}],69:[function(require,module,exports){\\n(function (process){\\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar exec = require('child_process').exec\\n  , fs = require('fs')\\n  , path = require('path')\\n  , exists = fs.existsSync || path.existsSync\\n  , os = require('os')\\n  , quote = JSON.stringify\\n  , cmd;\\n\\nfunction which(name) {\\n  var paths = process.env.PATH.split(':');\\n  var loc;\\n  \\n  for (var i = 0, len = paths.length; i < len; ++i) {\\n    loc = path.join(paths[i], name);\\n    if (exists(loc)) return loc;\\n  }\\n}\\n\\nswitch(os.type()) {\\n  case 'Darwin':\\n    if (which('terminal-notifier')) {\\n      cmd = {\\n          type: \\\"Darwin-NotificationCenter\\\"\\n        , pkg: \\\"terminal-notifier\\\"\\n        , msg: '-message'\\n        , title: '-title'\\n        , subtitle: '-subtitle'\\n        , priority: {\\n              cmd: '-execute'\\n            , range: []\\n          }\\n      };\\n    } else {\\n      cmd = {\\n          type: \\\"Darwin-Growl\\\"\\n        , pkg: \\\"growlnotify\\\"\\n        , msg: '-m'\\n        , sticky: '--sticky'\\n        , priority: {\\n              cmd: '--priority'\\n            , range: [\\n                -2\\n              , -1\\n              , 0\\n              , 1\\n              , 2\\n              , \\\"Very Low\\\"\\n              , \\\"Moderate\\\"\\n              , \\\"Normal\\\"\\n              , \\\"High\\\"\\n              , \\\"Emergency\\\"\\n            ]\\n          }\\n      };\\n    }\\n    break;\\n  case 'Linux':\\n    cmd = {\\n        type: \\\"Linux\\\"\\n      , pkg: \\\"notify-send\\\"\\n      , msg: ''\\n      , sticky: '-t 0'\\n      , icon: '-i'\\n      , priority: {\\n          cmd: '-u'\\n        , range: [\\n            \\\"low\\\"\\n          , \\\"normal\\\"\\n          , \\\"critical\\\"\\n        ]\\n      }\\n    };\\n    break;\\n  case 'Windows_NT':\\n    cmd = {\\n        type: \\\"Windows\\\"\\n      , pkg: \\\"growlnotify\\\"\\n      , msg: ''\\n      , sticky: '/s:true'\\n      , title: '/t:'\\n      , icon: '/i:'\\n      , priority: {\\n            cmd: '/p:'\\n          , range: [\\n              -2\\n            , -1\\n            , 0\\n            , 1\\n            , 2\\n          ]\\n        }\\n    };\\n    break;\\n}\\n\\n/**\\n * Expose `growl`.\\n */\\n\\nexports = module.exports = growl;\\n\\n/**\\n * Node-growl version.\\n */\\n\\nexports.version = '1.4.1'\\n\\n/**\\n * Send growl notification _msg_ with _options_.\\n *\\n * Options:\\n *\\n *  - title   Notification title\\n *  - sticky  Make the notification stick (defaults to false)\\n *  - priority  Specify an int or named key (default is 0)\\n *  - name    Application name (defaults to growlnotify)\\n *  - image\\n *    - path to an icon sets --iconpath\\n *    - path to an image sets --image\\n *    - capitalized word sets --appIcon\\n *    - filename uses extname as --icon\\n *    - otherwise treated as --icon\\n *\\n * Examples:\\n *\\n *   growl('New email')\\n *   growl('5 new emails', { title: 'Thunderbird' })\\n *   growl('Email sent', function(){\\n *     // ... notification sent\\n *   })\\n *\\n * @param {string} msg\\n * @param {object} options\\n * @param {function} fn\\n * @api public\\n */\\n\\nfunction growl(msg, options, fn) {\\n  var image\\n    , args\\n    , options = options || {}\\n    , fn = fn || function(){};\\n\\n  // noop\\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\\n  args = [cmd.pkg];\\n\\n  // image\\n  if (image = options.image) {\\n    switch(cmd.type) {\\n      case 'Darwin-Growl':\\n        var flag, ext = path.extname(image).substr(1)\\n        flag = flag || ext == 'icns' && 'iconpath'\\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\\n        flag = flag || ext && (image = ext) && 'icon'\\n        flag = flag || 'icon'\\n        args.push('--' + flag, quote(image))\\n        break;\\n      case 'Linux':\\n        args.push(cmd.icon, quote(image));\\n        // libnotify defaults to sticky, set a hint for transient notifications\\n        if (!options.sticky) args.push('--hint=int:transient:1');\\n        break;\\n      case 'Windows':\\n        args.push(cmd.icon + quote(image));\\n        break;\\n    }\\n  }\\n\\n  // sticky\\n  if (options.sticky) args.push(cmd.sticky);\\n\\n  // priority\\n  if (options.priority) {\\n    var priority = options.priority + '';\\n    var checkindexOf = cmd.priority.range.indexOf(priority);\\n    if (~cmd.priority.range.indexOf(priority)) {\\n      args.push(cmd.priority, options.priority);\\n    }\\n  }\\n\\n  // name\\n  if (options.name && cmd.type === \\\"Darwin-Growl\\\") {\\n    args.push('--name', options.name);\\n  }\\n\\n  switch(cmd.type) {\\n    case 'Darwin-Growl':\\n      args.push(cmd.msg);\\n      args.push(quote(msg));\\n      if (options.title) args.push(quote(options.title));\\n      break;\\n    case 'Darwin-NotificationCenter':\\n      args.push(cmd.msg);\\n      args.push(quote(msg));\\n      if (options.title) {\\n        args.push(cmd.title);\\n        args.push(quote(options.title));\\n      }\\n      if (options.subtitle) {\\n        args.push(cmd.subtitle);\\n        args.push(quote(options.subtitle));\\n      }\\n      break;\\n    case 'Darwin-Growl':\\n      args.push(cmd.msg);\\n      args.push(quote(msg));\\n      if (options.title) args.push(quote(options.title));\\n      break;\\n    case 'Linux':\\n      if (options.title) {\\n        args.push(quote(options.title));\\n        args.push(cmd.msg);\\n        args.push(quote(msg));\\n      } else {\\n        args.push(quote(msg));\\n      }\\n      break;\\n    case 'Windows':\\n      args.push(quote(msg));\\n      if (options.title) args.push(cmd.title + quote(options.title));\\n      break;\\n  }\\n\\n  // execute\\n  exec(args.join(' '), fn);\\n};\\n\\n}).call(this,require('_process'))\\n},{\\\"_process\\\":51,\\\"child_process\\\":41,\\\"fs\\\":41,\\\"os\\\":50,\\\"path\\\":41}],70:[function(require,module,exports){\\n(function (process,global){\\n/**\\n * Shim process.stdout.\\n */\\n\\nprocess.stdout = require('browser-stdout')();\\n\\nvar Mocha = require('../');\\n\\n/**\\n * Create a Mocha instance.\\n *\\n * @return {undefined}\\n */\\n\\nvar mocha = new Mocha({ reporter: 'html' });\\n\\n/**\\n * Save timer references to avoid Sinon interfering (see GH-237).\\n */\\n\\nvar Date = global.Date;\\nvar setTimeout = global.setTimeout;\\nvar setInterval = global.setInterval;\\nvar clearTimeout = global.clearTimeout;\\nvar clearInterval = global.clearInterval;\\n\\nvar uncaughtExceptionHandlers = [];\\n\\nvar originalOnerrorHandler = global.onerror;\\n\\n/**\\n * Remove uncaughtException listener.\\n * Revert to original onerror handler if previously defined.\\n */\\n\\nprocess.removeListener = function(e, fn){\\n  if ('uncaughtException' == e) {\\n    if (originalOnerrorHandler) {\\n      global.onerror = originalOnerrorHandler;\\n    } else {\\n      global.onerror = function() {};\\n    }\\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\\n    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }\\n  }\\n};\\n\\n/**\\n * Implements uncaughtException listener.\\n */\\n\\nprocess.on = function(e, fn){\\n  if ('uncaughtException' == e) {\\n    global.onerror = function(err, url, line){\\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\\n      return !mocha.allowUncaught;\\n    };\\n    uncaughtExceptionHandlers.push(fn);\\n  }\\n};\\n\\n// The BDD UI is registered by default, but no UI will be functional in the\\n// browser without an explicit call to the overridden `mocha.ui` (see below).\\n// Ensure that this default UI does not expose its methods to the global scope.\\nmocha.suite.removeAllListeners('pre-require');\\n\\nvar immediateQueue = []\\n  , immediateTimeout;\\n\\nfunction timeslice() {\\n  var immediateStart = new Date().getTime();\\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\\n    immediateQueue.shift()();\\n  }\\n  if (immediateQueue.length) {\\n    immediateTimeout = setTimeout(timeslice, 0);\\n  } else {\\n    immediateTimeout = null;\\n  }\\n}\\n\\n/**\\n * High-performance override of Runner.immediately.\\n */\\n\\nMocha.Runner.immediately = function(callback) {\\n  immediateQueue.push(callback);\\n  if (!immediateTimeout) {\\n    immediateTimeout = setTimeout(timeslice, 0);\\n  }\\n};\\n\\n/**\\n * Function to allow assertion libraries to throw errors directly into mocha.\\n * This is useful when running tests in a browser because window.onerror will\\n * only receive the 'message' attribute of the Error.\\n */\\nmocha.throwError = function(err) {\\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\\n    fn(err);\\n  });\\n  throw err;\\n};\\n\\n/**\\n * Override ui to ensure that the ui functions are initialized.\\n * Normally this would happen in Mocha.prototype.loadFiles.\\n */\\n\\nmocha.ui = function(ui){\\n  Mocha.prototype.ui.call(this, ui);\\n  this.suite.emit('pre-require', global, null, this);\\n  return this;\\n};\\n\\n/**\\n * Setup mocha with the given setting options.\\n */\\n\\nmocha.setup = function(opts){\\n  if ('string' == typeof opts) opts = { ui: opts };\\n  for (var opt in opts) this[opt](opts[opt]);\\n  return this;\\n};\\n\\n/**\\n * Run mocha, returning the Runner.\\n */\\n\\nmocha.run = function(fn){\\n  var options = mocha.options;\\n  mocha.globals('location');\\n\\n  var query = Mocha.utils.parseQuery(global.location.search || '');\\n  if (query.grep) mocha.grep(new RegExp(query.grep));\\n  if (query.fgrep) mocha.grep(query.fgrep);\\n  if (query.invert) mocha.invert();\\n\\n  return Mocha.prototype.run.call(mocha, function(err){\\n    // The DOM Document is not available in Web Workers.\\n    var document = global.document;\\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\\n      Mocha.utils.highlightTags('code');\\n    }\\n    if (fn) fn(err);\\n  });\\n};\\n\\n/**\\n * Expose the process shim.\\n * https://github.com/mochajs/mocha/pull/916\\n */\\n\\nMocha.process = process;\\n\\n/**\\n * Expose mocha.\\n */\\n\\nwindow.Mocha = Mocha;\\nwindow.mocha = mocha;\\n\\n}).call(this,require('_process'),typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"../\\\":1,\\\"_process\\\":51,\\\"browser-stdout\\\":40}]},{},[70]);\\n\"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./~/mocha/mocha.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha/mocha.js?./~/raw-loader");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(11);\n\n__webpack_require__(175);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-loader!./test/index.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./test/index.js?./~/babel-loader");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _index = __webpack_require__(12);\n\nvar _chai = __webpack_require__(135);\n\ndescribe('functional rlet evaluation', function () {\n  it('should suppress global variable assignments', function () {\n    var src = '\\n      var a;\\n      rlet b;\\n      rlet c = subscribe(b) (a = true);\\n      window.g = function() { b = true };\\n      subscribe(a) { window.f(a); }';\n    (0, _index.evalR)(src);\n    (0, _chai.expect)(function () {\n      return window.g();\n    }).to.throw(new Error('State updates in reactive variables not allowed'));\n  });\n\n  it('should suppress field updates', function () {\n    var src = '\\n      var a = {};\\n      rlet b;\\n      rlet c = subscribe(b) (a.prop = true);\\n      window.g = function() { b = true };\\n      subscribe(a) { window.f(a); }';\n    (0, _index.evalR)(src);\n    (0, _chai.expect)(function () {\n      return window.g();\n    }).to.throw(new Error('State updates in reactive variables not allowed'));\n  });\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/immutability.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./test/immutability.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genR = genR;\nexports.genHtml = genHtml;\nexports.evalR = evalR;\n\nvar _parser = __webpack_require__(13);\n\nvar _expander = __webpack_require__(14);\n\nvar _escope = __webpack_require__(54);\n\nvar _escodegen = __webpack_require__(19);\n\nvar _stxcase = __webpack_require__(132);\n\nvar _stxcase2 = _interopRequireDefault(_stxcase);\n\nvar _macros = __webpack_require__(133);\n\nvar _macros2 = _interopRequireDefault(_macros);\n\nvar _signal = __webpack_require__(134);\n\nvar _signal2 = _interopRequireDefault(_signal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction globalVars(self, stx) {\n  var estx = [].concat(_toConsumableArray((0, _expander.expand)(stx)), [{ token: {\n      type: _parser.Token.EOF,\n      range: [0, 0]\n    } }]);\n  var ast = (0, _parser.parse)(estx);\n  var globalScope = (0, _escope.analyze)(ast).globalScope;\n  return globalScope.through.map(function (_ref) {\n    var vname = _ref.identifier.name;\n    return vname;\n  }).filter(function (vname) {\n    return vname.indexOf(\"__S\") === 0 && vname != self;\n  });\n}\n\nfunction genR(src) {\n  window.globalVars = globalVars;\n  var stxcaseCtx = (0, _expander.expandModule)((0, _parser.read)(_stxcase2.default));\n  var expanded = (0, _expander.expand)((0, _parser.read)(_macros2.default + src), [stxcaseCtx]);\n  return '(function() {\\n    ' + _signal2.default + '\\n    ' + (0, _escodegen.generate)((0, _parser.parse)(expanded)) + '\\n  })()';\n}\n\nfunction genHtml(html, src) {\n  var code = genR(src);\n  return '<html>\\n<head>\\n  <title>rlet: Live Page</title>\\n</head>\\n<body>\\n' + html + '\\n<script src=\"https://code.jquery.com/jquery-2.2.0.min.js\"></script>\\n<script>\\n$(function() {\\n' + code + '\\n});\\n</script>\\n</html>';\n}\n\nfunction evalR(src) {\n  eval(genR(src));\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/index.js?");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    'use strict';\n    if (// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n        // Rhino, and plain browser loading.\n        true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            exports,\n            __webpack_require__(14)\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== 'undefined') {\n        factory(exports, require('./expander'));\n    } else {\n        factory(root.esprima = {});\n    }\n}(this, function (exports$2, expander) {\n    'use strict';\n    var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, ClassPropertyType, source, strict, index, lineNumber, lineStart, sm_lineNumber, sm_lineStart, sm_range, sm_index, length, delegate, tokenStream, streamIndex, lookahead, lookaheadIndex, state, extra;\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10,\n        Delimiter: 11\n    };\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Delimiter] = 'Delimiter';\n    // A function following one of those tokens is an expression.\n    FnExprTokens = [\n        '(',\n        '{',\n        '[',\n        'in',\n        'typeof',\n        'instanceof',\n        'new',\n        'return',\n        'case',\n        'delete',\n        'throw',\n        'void',\n        // assignment operators\n        '=',\n        '+=',\n        '-=',\n        '*=',\n        '/=',\n        '%=',\n        '<<=',\n        '>>=',\n        '>>>=',\n        '&=',\n        '|=',\n        '^=',\n        ',',\n        // binary/unary operators\n        '+',\n        '-',\n        '*',\n        '/',\n        '%',\n        '++',\n        '--',\n        '<<',\n        '>>',\n        '>>>',\n        '&',\n        '|',\n        '^',\n        '!',\n        '~',\n        '&&',\n        '||',\n        '?',\n        ':',\n        '===',\n        '==',\n        '>=',\n        '<=',\n        '<',\n        '>',\n        '!=',\n        '!=='\n    ];\n    Syntax = {\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AssignmentExpression: 'AssignmentExpression',\n        BinaryExpression: 'BinaryExpression',\n        BlockStatement: 'BlockStatement',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForStatement: 'ForStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportSpecifier: 'ImportSpecifier',\n        LabeledStatement: 'LabeledStatement',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleDeclaration: 'ModuleDeclaration',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n    ClassPropertyType = {\n        'static': 'static',\n        prototype: 'prototype'\n    };\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n        IllegalReturn: 'Illegal return statement',\n        IllegalYield: 'Illegal yield expression',\n        IllegalSpread: 'Illegal spread element',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n        DefaultRestParameter: 'Rest parameter can not have a default value',\n        ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n        ObjectPatternAsRestParameter: 'Invalid rest parameter',\n        ObjectPatternAsSpread: 'Invalid spread argument',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        NewlineAfterModule: 'Illegal newline after module',\n        NoFromAfterImport: 'Missing from after import',\n        InvalidModuleSpecifier: 'Invalid module specifier',\n        NestedModule: 'Module declaration can not be nested',\n        NoUnintializedConst: 'Const must be initialized',\n        ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n        ComprehensionError: 'Comprehension Error',\n        EachNotAllowed: 'Each is not supported',\n        UnmatchedDelimiter: 'Unmatched Delimiter'\n    };\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n    function isIn(el, list) {\n        return list.indexOf(el) !== -1;\n    }\n    function isDecimalDigit(ch) {\n        return ch >= 48 && ch <= 57;\n    }\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n    function isWhiteSpace(ch) {\n        return ch === 32 || // space\n        ch === 9 || // tab\n        ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0;\n    }\n    function isLineTerminator(ch) {\n        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;\n    }\n    function isIdentifierStart(ch) {\n        return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)\n        ch >= 65 && ch <= 90 || // A..Z\n        ch >= 97 && ch <= 122 || // a..z\n        ch === 92 || // \\ (backslash)\n        ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n    }\n    function isIdentifierPart(ch) {\n        return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)\n        ch >= 65 && ch <= 90 || // A..Z\n        ch >= 97 && ch <= 122 || // a..z\n        ch >= 48 && ch <= 57 || // 0..9\n        ch === 92 || // \\ (backslash)\n        ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n    }\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n        switch (// 'const' is specialized as Keyword in V8.\n            // 'yield' is only treated as a keyword in strict mode.\n            // 'let' is for compatiblity with SpiderMonkey and ES.next.\n            // Some others are from future reserved words.\n            id.length) {\n        case 2:\n            return id === 'if' || id === 'in' || id === 'do';\n        case 3:\n            return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n        case 4:\n            return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n        case 5:\n            return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'class' || id === 'super';\n        case 6:\n            return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n        case 7:\n            return id === 'default' || id === 'finally' || id === 'extends';\n        case 8:\n            return id === 'function' || id === 'continue' || id === 'debugger';\n        case 10:\n            return id === 'instanceof';\n        default:\n            return false;\n        }\n    }\n    function skipComment() {\n        var ch, blockComment, lineComment;\n        blockComment = false;\n        lineComment = false;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (lineComment) {\n                ++index;\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === 13 && source.charCodeAt(index) === 10) {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source.charCodeAt(index++);\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (// Block comment ends with '*/' (char #42, char #47).\n                        ch === 42) {\n                        ch = source.charCodeAt(index);\n                        if (ch === 47) {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === 47) {\n                ch = source.charCodeAt(index + 1);\n                if (// Line comment starts with '//' (char #47, char #47).\n                    ch === 47) {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === 42) {\n                    // Block comment starts with '/*' (char #47, char #42).\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n        len = prefix === 'u' ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n        ch = source[index];\n        code = 0;\n        if (// At least, one hex digit is required.\n            ch === '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n        if (code > 1114111 || ch !== '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        if (// UTF-16 Encoding\n            code <= 65535) {\n            return String.fromCharCode(code);\n        }\n        cu1 = (code - 65536 >> 10) + 55296;\n        cu2 = (code - 65536 & 1023) + 56320;\n        return String.fromCharCode(cu1, cu2);\n    }\n    function getEscapedIdentifier() {\n        var ch, id;\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n        if (// '\\u' (char #92, char #117) denotes an escaped character.\n            ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n            if (// '\\u' (char #92, char #117) denotes an escaped character.\n                ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n        return id;\n    }\n    function getIdentifier() {\n        var start, ch;\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n        return source.slice(start, index);\n    }\n    function scanIdentifier() {\n        var start, id, type;\n        start = index;\n        // Backslash (char #92) starts an escaped character.\n        id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();\n        if (// There is no keyword or literal with only one character.\n            // Thus, it must be an identifier.\n            id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanPunctuator() {\n        var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;\n        switch (code) {\n        // Check for most common single-character punctuators.\n        case 40:\n        // ( open bracket\n        case 41:\n        // ) close bracket\n        case 59:\n        // ; semicolon\n        case 44:\n        // , comma\n        case 123:\n        // { open curly brace\n        case 125:\n        // } close curly brace\n        case 91:\n        // [\n        case 93:\n        // ]\n        case 58:\n        // :\n        case 63:\n        case // ?\n            126:\n            // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 40) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 123) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        default:\n            code2 = source.charCodeAt(index + 1);\n            if (// '=' (char #61) marks an assignment or comparison operator.\n                code2 === 61) {\n                switch (code) {\n                case 37:\n                // %\n                case 38:\n                // &\n                case 42:\n                // *:\n                case 43:\n                // +\n                case 45:\n                // -\n                case 47:\n                // /\n                case 60:\n                // <\n                case 62:\n                // >\n                case 94:\n                case // ^\n                    124:\n                    // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [\n                            start,\n                            index\n                        ]\n                    };\n                case 33:\n                case // !\n                    61:\n                    // =\n                    index += 2;\n                    if (// !== and ===\n                        source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [\n                            start,\n                            index\n                        ]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n        // Peek more characters.\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n        if (// 4-character punctuator: >>>=\n            ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [\n                        start,\n                        index\n                    ]\n                };\n            }\n        }\n        if (// 3-character punctuators: === !== >>> <<= >>=\n            ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '...',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (// Other 2-character punctuators: ++ -- << >> && ||\n            ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (ch1 === '=' && ch2 === '>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: '=>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        if (ch1 === '.') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    function scanHexLiteral(start) {\n        var number = '';\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanNumericLiteral() {\n        var number, start, ch, octal;\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n            if (// Hex number starts with '0x'.\n                // Octal number starts with '0'.\n                // Octal number in ES6 starts with '0o'.\n                // Binary number in ES6 starts with '0b'.\n                number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    number = '';\n                    while (index < length) {\n                        ch = source[index];\n                        if (ch !== '0' && ch !== '1') {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n                    if (number.length === 0) {\n                        // only 0b or 0B\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [\n                            start,\n                            index\n                        ]\n                    };\n                }\n                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n                    return scanOctalLiteral(ch, start);\n                }\n                if (// decimal number starts with '0' such as '09' is illegal.\n                    ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n        quote = source[index];\n        assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n        start = index;\n        ++index;\n        while (index < length) {\n            ch = source[index++];\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n                            if (// \\0 is not octal escape sequence\n                                code !== 0) {\n                                octal = true;\n                            }\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n                                if (// 3 digits are only allowed when string starts\n                                    // with 0, 1, 2, 3\n                                    '0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanTemplate() {\n        var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;\n        terminated = false;\n        tail = false;\n        start = index;\n        ++index;\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\x0B';\n                        break;\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n                            if (// \\0 is not octal escape sequence\n                                code !== 0) {\n                                octal = true;\n                            }\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n                                if (// 3 digits are only allowed when string starts\n                                    // with 0, 1, 2, 3\n                                    '0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            cooked += String.fromCharCode(code);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n        if (!terminated) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - (tail ? 1 : 2))\n            },\n            tail: tail,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function scanTemplateElement(option) {\n        var startsWith, template;\n        lookahead = null;\n        skipComment();\n        startsWith = option.head ? '`' : '}';\n        if (source[index] !== startsWith) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        template = scanTemplate();\n        peek();\n        return template;\n    }\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n        lookahead = null;\n        skipComment();\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '\\\\') {\n                    ch = source[index++];\n                    if (// ECMA-262 7.8.5\n                        isLineTerminator(ch.charCodeAt(0))) {\n                        throwError({}, Messages.UnterminatedRegExp);\n                    }\n                    str += ch;\n                } else if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n        if (// peek();\n            extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    start,\n                    index\n                ]\n            };\n        }\n        return {\n            type: Token.RegularExpression,\n            literal: str,\n            value: value,\n            range: [\n                start,\n                index\n            ]\n        };\n    }\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n    }\n    function advanceSlash() {\n        var prevToken, checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {\n                    return scanRegExp();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                if (// Dividing a function by anything makes little sense,\n                    // but we have to check for that.\n                    extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return scanRegExp();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                if (// checkToken determines whether the function is\n                    // a declaration or an expression.\n                    FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return scanRegExp();\n            }\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Keyword') {\n            return scanRegExp();\n        }\n        return scanPunctuator();\n    }\n    function advance() {\n        var ch;\n        skipComment();\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    index,\n                    index\n                ]\n            };\n        }\n        ch = source.charCodeAt(index);\n        if (// Very common: ( and ) and ;\n            ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n        if (// String literal starts with single quote (#39) or double quote (#34).\n            ch === 39 || ch === 34) {\n            return scanStringLiteral();\n        }\n        if (ch === 96) {\n            return scanTemplate();\n        }\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n        if (// # and @ are allowed for sweet.js\n            ch === 35 || ch === 64) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(ch),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    index - 1,\n                    index\n                ]\n            };\n        }\n        if (// Dot (.) char #46 can also start a floating-point number, hence the need\n            // to check the next character.\n            ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n        if (// Slash (/) char #47 can also start a regex.\n            extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n        return scanPunctuator();\n    }\n    function lex() {\n        var token;\n        token = lookahead;\n        streamIndex = lookaheadIndex;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n        sm_lineNumber = lookahead.sm_lineNumber;\n        sm_lineStart = lookahead.sm_lineStart;\n        sm_range = lookahead.sm_range;\n        sm_index = lookahead.sm_range[0];\n        lookahead = tokenStream[++streamIndex].token;\n        lookaheadIndex = streamIndex;\n        index = lookahead.range[0];\n        if (token.leadingComments) {\n            extra.comments = extra.comments.concat(token.leadingComments);\n            extra.trailingComments = extra.trailingComments.concat(token.leadingComments);\n            extra.leadingComments = extra.leadingComments.concat(token.leadingComments);\n        }\n        return token;\n    }\n    function peek() {\n        lookaheadIndex = streamIndex + 1;\n        if (lookaheadIndex >= length) {\n            lookahead = {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    index,\n                    index\n                ]\n            };\n            return;\n        }\n        lookahead = tokenStream[lookaheadIndex].token;\n        index = lookahead.range[0];\n    }\n    function lookahead2() {\n        var adv, pos, line, start, result;\n        if (streamIndex + 1 >= length || streamIndex + 2 >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [\n                    index,\n                    index\n                ]\n            };\n        }\n        if (// Scan for the next immediate token.\n            lookahead === null) {\n            lookaheadIndex = streamIndex + 1;\n            lookahead = tokenStream[lookaheadIndex].token;\n            index = lookahead.range[0];\n        }\n        result = tokenStream[lookaheadIndex + 1].token;\n        return result;\n    }\n    function markerCreate() {\n        var sm_index$2 = lookahead ? lookahead.sm_range[0] : 0;\n        var sm_lineStart$2 = lookahead ? lookahead.sm_lineStart : 0;\n        var sm_lineNumber$2 = lookahead ? lookahead.sm_lineNumber : 1;\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        return {\n            offset: sm_index$2,\n            line: sm_lineNumber$2,\n            col: sm_index$2 - sm_lineStart$2\n        };\n    }\n    function processComment(node) {\n        var lastChild, trailingComments, bottomRight = extra.bottomRightStack, last = bottomRight[bottomRight.length - 1];\n        if (node.type === Syntax.Program) {\n            if (node.body.length > 0) {\n                return;\n            }\n        }\n        if (extra.trailingComments.length > 0) {\n            if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = extra.trailingComments;\n                extra.trailingComments = [];\n            } else {\n                extra.trailingComments.length = 0;\n            }\n        } else {\n            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = last.trailingComments;\n                delete last.trailingComments;\n            }\n        }\n        if (// Eating the stack.\n            last) {\n            while (last && last.range[0] >= node.range[0]) {\n                lastChild = last;\n                last = bottomRight.pop();\n            }\n        }\n        if (lastChild) {\n            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = lastChild.leadingComments;\n                delete lastChild.leadingComments;\n            }\n        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n            node.leadingComments = extra.leadingComments;\n            extra.leadingComments = [];\n        }\n        if (trailingComments) {\n            node.trailingComments = trailingComments;\n        }\n        bottomRight.push(node);\n    }\n    function markerApply(marker, node) {\n        if (extra.range) {\n            node.range = [\n                marker.offset,\n                sm_index\n            ];\n        }\n        if (extra.loc) {\n            node.loc = {\n                start: {\n                    line: marker.line,\n                    column: marker.col\n                },\n                end: {\n                    line: sm_lineNumber,\n                    column: sm_index - sm_lineStart\n                }\n            };\n            node = delegate.postProcess(node);\n        }\n        if (extra.attachComment) {\n            processComment(node);\n        }\n        return node;\n    }\n    SyntaxTreeDelegate = {\n        name: 'SyntaxTree',\n        postProcess: function (node) {\n            return node;\n        },\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n        createBinaryExpression: function (operator, left, right) {\n            var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n        createDebuggerStatement: function () {\n            return { type: Syntax.DebuggerStatement };\n        },\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n        createEmptyStatement: function () {\n            return { type: Syntax.EmptyStatement };\n        },\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n        createForOfStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForOfStatement,\n                left: left,\n                right: right,\n                body: body\n            };\n        },\n        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression\n            };\n        },\n        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression\n            };\n        },\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: String(token.value)\n            };\n        },\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n        createProperty: function (kind, key, value, method, shorthand, computed) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind,\n                method: method,\n                shorthand: shorthand,\n                computed: computed\n            };\n        },\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n        createThisExpression: function () {\n            return { type: Syntax.ThisExpression };\n        },\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        },\n        createTemplateElement: function (value, tail) {\n            return {\n                type: Syntax.TemplateElement,\n                value: value,\n                tail: tail\n            };\n        },\n        createTemplateLiteral: function (quasis, expressions) {\n            return {\n                type: Syntax.TemplateLiteral,\n                quasis: quasis,\n                expressions: expressions\n            };\n        },\n        createSpreadElement: function (argument) {\n            return {\n                type: Syntax.SpreadElement,\n                argument: argument\n            };\n        },\n        createTaggedTemplateExpression: function (tag, quasi) {\n            return {\n                type: Syntax.TaggedTemplateExpression,\n                tag: tag,\n                quasi: quasi\n            };\n        },\n        createArrowFunctionExpression: function (params, defaults, body, rest, expression) {\n            return {\n                type: Syntax.ArrowFunctionExpression,\n                id: null,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: false,\n                expression: expression\n            };\n        },\n        createMethodDefinition: function (propertyType, kind, key, value) {\n            return {\n                type: Syntax.MethodDefinition,\n                key: key,\n                value: value,\n                kind: kind,\n                'static': propertyType === ClassPropertyType.static\n            };\n        },\n        createClassBody: function (body) {\n            return {\n                type: Syntax.ClassBody,\n                body: body\n            };\n        },\n        createClassExpression: function (id, superClass, body) {\n            return {\n                type: Syntax.ClassExpression,\n                id: id,\n                superClass: superClass,\n                body: body\n            };\n        },\n        createClassDeclaration: function (id, superClass, body) {\n            return {\n                type: Syntax.ClassDeclaration,\n                id: id,\n                superClass: superClass,\n                body: body\n            };\n        },\n        createExportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ExportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n        createExportBatchSpecifier: function () {\n            return { type: Syntax.ExportBatchSpecifier };\n        },\n        createExportDeclaration: function (declaration, specifiers, source$2) {\n            return {\n                type: Syntax.ExportDeclaration,\n                declaration: declaration,\n                specifiers: specifiers,\n                source: source$2\n            };\n        },\n        createImportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ImportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n        createImportDeclaration: function (specifiers, kind, source$2) {\n            return {\n                type: Syntax.ImportDeclaration,\n                specifiers: specifiers,\n                kind: kind,\n                source: source$2\n            };\n        },\n        createYieldExpression: function (argument, delegate$2) {\n            return {\n                type: Syntax.YieldExpression,\n                argument: argument,\n                delegate: delegate$2\n            };\n        },\n        createModuleDeclaration: function (id, source$2, body) {\n            return {\n                type: Syntax.ModuleDeclaration,\n                id: id,\n                source: source$2,\n                body: body\n            };\n        },\n        createComprehensionExpression: function (filter, blocks, body) {\n            return {\n                type: Syntax.ComprehensionExpression,\n                filter: filter,\n                blocks: blocks,\n                body: body\n            };\n        }\n    };\n    function peekLineTerminator() {\n        return lookahead.lineNumber !== lineNumber;\n    }\n    function throwError(token, messageFormat) {\n        var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\\d)/g, function (whole, index$2) {\n                assert(index$2 < args.length, 'Message reference must be in range');\n                return args[index$2];\n            });\n        var startIndex = streamIndex > 3 ? streamIndex - 3 : 0;\n        var toks = '', tailingMsg = '';\n        if (tokenStream) {\n            toks = tokenStream.slice(startIndex, streamIndex + 3).map(function (stx) {\n                return stx.token.value;\n            }).join(' ');\n            tailingMsg = '\\n[... ' + toks + ' ...]';\n        }\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg + tailingMsg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg + tailingMsg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n        error.description = msg;\n        throw error;\n    }\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n        if (token.type === Token.Template) {\n            throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n        }\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n    function matchAssign() {\n        var op;\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n    }\n    function consumeSemicolon() {\n        var line, ch;\n        ch = lookahead.value ? String(lookahead.value).charCodeAt(0) : -1;\n        if (// Catch the very common case first: immediately a semicolon (char #59).\n            ch === 59) {\n            lex();\n            return;\n        }\n        if (lookahead.lineNumber !== lineNumber) {\n            return;\n        }\n        if (match(';')) {\n            lex();\n            return;\n        }\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n    function isAssignableLeftHandSide(expr) {\n        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n    }\n    function parseArrayInitialiser() {\n        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true, body, marker = markerCreate();\n        expect('[');\n        while (!match(']')) {\n            if (lookahead.value === 'for' && lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                matchKeyword('for');\n                tmp = parseForStatement({ ignoreBody: true });\n                tmp.of = tmp.type === Syntax.ForOfStatement;\n                tmp.type = Syntax.ComprehensionBlock;\n                if (tmp.left.kind) {\n                    // can't be let or const\n                    throwError({}, Messages.ComprehensionError);\n                }\n                blocks.push(tmp);\n            } else if (lookahead.value === 'if' && lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                expectKeyword('if');\n                expect('(');\n                filter = parseExpression();\n                expect(')');\n            } else if (lookahead.value === ',' && lookahead.type === Token.Punctuator) {\n                possiblecomprehension = false;\n                // no longer allowed.\n                lex();\n                elements.push(null);\n            } else {\n                tmp = parseSpreadOrAssignmentExpression();\n                elements.push(tmp);\n                if (tmp && tmp.type === Syntax.SpreadElement) {\n                    if (!match(']')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n                    expect(',');\n                    // this lexes.\n                    possiblecomprehension = false;\n                }\n            }\n        }\n        expect(']');\n        if (filter && !blocks.length) {\n            throwError({}, Messages.ComprehensionRequiresBlock);\n        }\n        if (blocks.length) {\n            if (elements.length !== 1) {\n                throwError({}, Messages.ComprehensionError);\n            }\n            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));\n        }\n        return markerApply(marker, delegate.createArrayExpression(elements));\n    }\n    function parsePropertyFunction(options) {\n        var previousStrict, previousYieldAllowed, params, defaults, body, marker = markerCreate();\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = options.generator;\n        params = options.params || [];\n        defaults = options.defaults || [];\n        body = parseConciseBody();\n        if (options.name && strict && isRestrictedWord(params[0].name)) {\n            throwErrorTolerant(options.name, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        return markerApply(marker, delegate.createFunctionExpression(null, params, defaults, body, options.rest || null, options.generator, body.type !== Syntax.BlockStatement));\n    }\n    function parsePropertyMethodFunction(options) {\n        var previousStrict, tmp, method;\n        previousStrict = strict;\n        strict = true;\n        tmp = parseParams();\n        if (tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, tmp.message);\n        }\n        method = parsePropertyFunction({\n            params: tmp.params,\n            defaults: tmp.defaults,\n            rest: tmp.rest,\n            generator: options.generator\n        });\n        strict = previousStrict;\n        return method;\n    }\n    function parseObjectPropertyKey() {\n        var marker = markerCreate(), token = lex(), propertyKey, result;\n        if (// Note: This function is called only from parseObjectProperty(), where\n            // EOF and Punctuator tokens are already filtered out.\n            token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n        if (token.type === Token.Punctuator && token.value === '[') {\n            // For computed properties we should skip the [ and ], and\n            // capture in marker only the assignment expression itself.\n            marker = markerCreate();\n            propertyKey = parseAssignmentExpression();\n            result = markerApply(marker, propertyKey);\n            expect(']');\n            return result;\n        }\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n    function parseObjectProperty() {\n        var token, key, id, value, param, expr, computed, marker = markerCreate();\n        token = lookahead;\n        computed = token.value === '[' && token.type === Token.Punctuator;\n        if (token.type === Token.Identifier || computed) {\n            id = parseObjectPropertyKey();\n            if (// Property Assignment: Getter and Setter.\n                token.value === 'get' && !(match(':') || match('('))) {\n                computed = lookahead.value === '[';\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return markerApply(marker, delegate.createProperty('get', key, parsePropertyFunction({ generator: false }), false, false, computed));\n            }\n            if (token.value === 'set' && !(match(':') || match('('))) {\n                computed = lookahead.value === '[';\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                param = [parseVariableIdentifier()];\n                expect(')');\n                return markerApply(marker, delegate.createProperty('set', key, parsePropertyFunction({\n                    params: param,\n                    generator: false,\n                    name: token\n                }), false, false, computed));\n            }\n            if (match(':')) {\n                lex();\n                return markerApply(marker, delegate.createProperty('init', id, parseAssignmentExpression(), false, false, computed));\n            }\n            if (match('(')) {\n                return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: false }), true, false, computed));\n            }\n            if (computed) {\n                // Computed properties can only be used with full notation.\n                throwUnexpected(lookahead);\n            }\n            return markerApply(marker, delegate.createProperty('init', id, id, false, true, false));\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            if (!match('*')) {\n                throwUnexpected(token);\n            }\n            lex();\n            computed = lookahead.type === Token.Punctuator && lookahead.value === '[';\n            id = parseObjectPropertyKey();\n            if (!match('(')) {\n                throwUnexpected(lex());\n            }\n            return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: true }), true, false, computed));\n        }\n        key = parseObjectPropertyKey();\n        if (match(':')) {\n            lex();\n            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));\n        }\n        if (match('(')) {\n            return markerApply(marker, delegate.createProperty('init', key, parsePropertyMethodFunction({ generator: false }), true, false, false));\n        }\n        throwUnexpected(lex());\n    }\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String, marker = markerCreate();\n        expect('{');\n        while (!match('}')) {\n            property = parseObjectProperty();\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n            properties.push(property);\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n        expect('}');\n        return markerApply(marker, delegate.createObjectExpression(properties));\n    }\n    function parseTemplateElement(option) {\n        var marker = markerCreate(), token = lex();\n        if (strict && token.octal) {\n            throwError(token, Messages.StrictOctalLiteral);\n        }\n        return markerApply(marker, delegate.createTemplateElement({\n            raw: token.value.raw,\n            cooked: token.value.cooked\n        }, token.tail));\n    }\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, marker = markerCreate();\n        quasi = parseTemplateElement({ head: true });\n        quasis = [quasi];\n        expressions = [];\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));\n    }\n    function parseGroupExpression() {\n        var expr;\n        expect('(');\n        ++state.parenthesizedCount;\n        expr = parseExpression();\n        expect(')');\n        return expr;\n    }\n    function parsePrimaryExpression() {\n        var type, token, resolvedIdent, marker, expr;\n        token = lookahead;\n        type = lookahead.type;\n        if (type === Token.Identifier) {\n            marker = markerCreate();\n            resolvedIdent = expander.resolve(tokenStream[lookaheadIndex]);\n            lex();\n            return markerApply(marker, delegate.createIdentifier(resolvedIdent));\n        }\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(lex()));\n        }\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createThisExpression());\n            }\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            if (matchKeyword('super')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createIdentifier('super'));\n            }\n        }\n        if (type === Token.BooleanLiteral) {\n            marker = markerCreate();\n            token = lex();\n            if (typeof token.value !== 'boolean') {\n                assert(token.value === 'true' || token.value === 'false', 'exporting either true or false as a string not: ' + token.value);\n                token.value = token.value === 'true';\n            }\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n        if (type === Token.NullLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = null;\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n        if (lookahead.type === Token.RegularExpression) {\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(lex()));\n        }\n        if (type === Token.Template) {\n            return parseTemplateLiteral();\n        }\n        throwUnexpected(lex());\n    }\n    function parseArguments() {\n        var args = [], arg;\n        expect('(');\n        if (!match(')')) {\n            while (streamIndex < length) {\n                arg = parseSpreadOrAssignmentExpression();\n                args.push(arg);\n                if (match(')')) {\n                    break;\n                } else if (arg.type === Syntax.SpreadElement) {\n                    throwError({}, Messages.ElementAfterSpreadElement);\n                }\n                expect(',');\n            }\n        }\n        expect(')');\n        return args;\n    }\n    function parseSpreadOrAssignmentExpression() {\n        if (match('...')) {\n            var marker = markerCreate();\n            lex();\n            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));\n        }\n        return parseAssignmentExpression();\n    }\n    function parseNonComputedProperty() {\n        var marker = markerCreate(), token = lex();\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n    function parseNonComputedMember() {\n        expect('.');\n        return parseNonComputedProperty();\n    }\n    function parseComputedMember() {\n        var expr;\n        expect('[');\n        expr = parseExpression();\n        expect(']');\n        return expr;\n    }\n    function parseNewExpression() {\n        var callee, args, marker = markerCreate();\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n        return markerApply(marker, delegate.createNewExpression(callee, args));\n    }\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, marker = markerCreate();\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = markerApply(marker, delegate.createCallExpression(expr, args));\n            } else if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n        return expr;\n    }\n    function parseLeftHandSideExpression() {\n        var expr, marker = markerCreate();\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n        while (match('.') || match('[') || lookahead.type === Token.Template) {\n            if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n        return expr;\n    }\n    function parsePostfixExpression() {\n        var marker = markerCreate(), expr = parseLeftHandSideExpressionAllowCall(), token;\n        if (lookahead.type !== Token.Punctuator) {\n            return expr;\n        }\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            if (// 11.3.1, 11.3.2\n                strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n            token = lex();\n            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));\n        }\n        return expr;\n    }\n    function parseUnaryExpression() {\n        var marker, token, expr;\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n        if (match('++') || match('--')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            if (// 11.4.4, 11.4.5\n                strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n        if (match('+') || match('-') || match('~') || match('!')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n            if (expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n        return parsePostfixExpression();\n    }\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n        case '&&':\n            prec = 2;\n            break;\n        case '|':\n            prec = 3;\n            break;\n        case '^':\n            prec = 4;\n            break;\n        case '&':\n            prec = 5;\n            break;\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n        default:\n            break;\n        }\n        return prec;\n    }\n    function parseBinaryExpression() {\n        var expr, token, prec, previousAllowIn, stack, right, operator, left, i, marker, markers;\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n        marker = markerCreate();\n        left = parseUnaryExpression();\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n        markers = [\n            marker,\n            markerCreate()\n        ];\n        right = parseUnaryExpression();\n        stack = [\n            left,\n            token,\n            right\n        ];\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n            while (// Reduce: make a binary expression from the three topmost entries.\n                stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                markerApply(marker, expr);\n                stack.push(expr);\n                markers.push(marker);\n            }\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(markerCreate());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n        state.allowIn = previousAllowIn;\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            markerApply(marker, expr);\n        }\n        return expr;\n    }\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();\n        expr = parseBinaryExpression();\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));\n        }\n        return expr;\n    }\n    function reinterpretAsAssignmentBindingPattern(expr) {\n        var i, len, property, element;\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.kind !== 'init') {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n                reinterpretAsAssignmentBindingPattern(property.value);\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsAssignmentBindingPattern(element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            if (isRestrictedWord(expr.name)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        } else if (expr.type === Syntax.SpreadElement) {\n            reinterpretAsAssignmentBindingPattern(expr.argument);\n            if (expr.argument.type === Syntax.ObjectPattern) {\n                throwError({}, Messages.ObjectPatternAsSpread);\n            }\n        } else {\n            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        }\n    }\n    function reinterpretAsDestructuredParameter(options, expr) {\n        var i, len, property, element;\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.kind !== 'init') {\n                    throwError({}, Messages.InvalidLHSInFormalsList);\n                }\n                reinterpretAsDestructuredParameter(options, property.value);\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsDestructuredParameter(options, element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            validateParam(options, expr, expr.name);\n        } else {\n            if (expr.type !== Syntax.MemberExpression) {\n                throwError({}, Messages.InvalidLHSInFormalsList);\n            }\n        }\n    }\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest;\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = { paramSet: {} };\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n                reinterpretAsDestructuredParameter(options, param);\n                params.push(param);\n                defaults.push(null);\n            } else if (param.type === Syntax.SpreadElement) {\n                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');\n                reinterpretAsDestructuredParameter(options, param.argument);\n                rest = param.argument;\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n        if (options.message === Messages.StrictParamDupe) {\n            throwError(strict ? options.stricted : options.firstRestricted, options.message);\n        }\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n    function parseArrowFunctionExpression(options, marker) {\n        var previousStrict, previousYieldAllowed, body;\n        expect('=>');\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = false;\n        body = parseConciseBody();\n        if (strict && options.firstRestricted) {\n            throwError(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            throwErrorTolerant(options.stricted, options.message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        return markerApply(marker, delegate.createArrowFunctionExpression(options.params, options.defaults, body, options.rest, body.type !== Syntax.BlockStatement));\n    }\n    function parseAssignmentExpression() {\n        var marker, expr, token, params, oldParenthesizedCount;\n        if (// Note that 'yield' is treated as a keyword in strict mode, but a\n            // contextual keyword (identifier) in non-strict mode, so we need\n            // to use matchKeyword and matchContextualKeyword appropriately.\n            state.yieldAllowed && matchContextualKeyword('yield') || strict && matchKeyword('yield')) {\n            return parseYieldExpression();\n        }\n        oldParenthesizedCount = state.parenthesizedCount;\n        marker = markerCreate();\n        if (match('(')) {\n            token = lookahead2();\n            if (token.type === Token.Punctuator && token.value === ')' || token.value === '...') {\n                params = parseParams();\n                if (!match('=>')) {\n                    throwUnexpected(lex());\n                }\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n        token = lookahead;\n        expr = parseConditionalExpression();\n        if (match('=>') && (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === oldParenthesizedCount + 1)) {\n            if (expr.type === Syntax.Identifier) {\n                params = reinterpretAsCoverFormalsList([expr]);\n            } else if (expr.type === Syntax.SequenceExpression) {\n                params = reinterpretAsCoverFormalsList(expr.expressions);\n            }\n            if (params) {\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n        if (matchAssign()) {\n            if (// 11.13.1\n                strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n            if (// ES.next draf 11.13 Runtime Semantics step 1\n                match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n                reinterpretAsAssignmentBindingPattern(expr);\n            } else if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));\n        }\n        return expr;\n    }\n    function parseExpression() {\n        var marker, expr, expressions, sequence, coverFormalsList, spreadFound, oldParenthesizedCount;\n        oldParenthesizedCount = state.parenthesizedCount;\n        marker = markerCreate();\n        expr = parseAssignmentExpression();\n        expressions = [expr];\n        if (match(',')) {\n            while (streamIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr = parseSpreadOrAssignmentExpression();\n                expressions.push(expr);\n                if (expr.type === Syntax.SpreadElement) {\n                    spreadFound = true;\n                    if (!match(')')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                    break;\n                }\n            }\n            sequence = markerApply(marker, delegate.createSequenceExpression(expressions));\n        }\n        if (match('=>')) {\n            if (// Do not allow nested parentheses on the LHS of the =>.\n                state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === oldParenthesizedCount + 1) {\n                expr = expr.type === Syntax.SequenceExpression ? expr.expressions : expressions;\n                coverFormalsList = reinterpretAsCoverFormalsList(expr);\n                if (coverFormalsList) {\n                    return parseArrowFunctionExpression(coverFormalsList, marker);\n                }\n            }\n            throwUnexpected(lex());\n        }\n        if (spreadFound && lookahead2().value !== '=>') {\n            throwError({}, Messages.IllegalSpread);\n        }\n        return sequence || expr;\n    }\n    function parseStatementList() {\n        var list = [], statement;\n        while (streamIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n        return list;\n    }\n    function parseBlock() {\n        var block, marker = markerCreate();\n        expect('{');\n        block = parseStatementList();\n        expect('}');\n        return markerApply(marker, delegate.createBlockStatement(block));\n    }\n    function parseVariableIdentifier() {\n        var token = lookahead, resolvedIdent, marker = markerCreate();\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n        resolvedIdent = expander.resolve(tokenStream[lookaheadIndex]);\n        lex();\n        return markerApply(marker, delegate.createIdentifier(resolvedIdent));\n    }\n    function parseVariableDeclaration(kind) {\n        var id, marker = markerCreate(), init = null;\n        if (match('{')) {\n            id = parseObjectInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n        } else if (match('[')) {\n            id = parseArrayInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n        } else {\n            id = state.allowKeyword ? parseNonComputedProperty() : parseVariableIdentifier();\n            if (// 12.2.1\n                strict && isRestrictedWord(id.name)) {\n                throwErrorTolerant({}, Messages.StrictVarName);\n            }\n        }\n        if (kind === 'const') {\n            if (!match('=')) {\n                throwError({}, Messages.NoUnintializedConst);\n            }\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n        return markerApply(marker, delegate.createVariableDeclarator(id, init));\n    }\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (streamIndex < length);\n        return list;\n    }\n    function parseVariableStatement() {\n        var declarations, marker = markerCreate();\n        expectKeyword('var');\n        declarations = parseVariableDeclarationList();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));\n    }\n    function parseConstLetDeclaration(kind) {\n        var declarations, marker = markerCreate();\n        expectKeyword(kind);\n        declarations = parseVariableDeclarationList(kind);\n        consumeSemicolon();\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));\n    }\n    function parseModuleDeclaration() {\n        var id, src, body, marker = markerCreate();\n        lex();\n        if (// 'module'\n            peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterModule);\n        }\n        switch (lookahead.type) {\n        case Token.StringLiteral:\n            id = parsePrimaryExpression();\n            body = parseModuleBlock();\n            src = null;\n            break;\n        case Token.Identifier:\n            id = parseVariableIdentifier();\n            body = null;\n            if (!matchContextualKeyword('from')) {\n                throwUnexpected(lex());\n            }\n            lex();\n            src = parsePrimaryExpression();\n            if (src.type !== Syntax.Literal) {\n                throwError({}, Messages.InvalidModuleSpecifier);\n            }\n            break;\n        }\n        consumeSemicolon();\n        return markerApply(marker, delegate.createModuleDeclaration(id, src, body));\n    }\n    function parseExportBatchSpecifier() {\n        var marker = markerCreate();\n        expect('*');\n        return markerApply(marker, delegate.createExportBatchSpecifier());\n    }\n    function parseExportSpecifier() {\n        var id, name = null, marker = markerCreate();\n        id = parseVariableIdentifier();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseNonComputedProperty();\n        }\n        return markerApply(marker, delegate.createExportSpecifier(id, name));\n    }\n    function parseExportDeclaration() {\n        var previousAllowKeyword, decl, def, src, specifiers, marker = markerCreate();\n        expectKeyword('export');\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'let':\n            case 'const':\n            case 'var':\n            case 'class':\n            case 'function':\n                return markerApply(marker, delegate.createExportDeclaration(parseSourceElement(), null, null));\n            }\n        }\n        if (isIdentifierName(lookahead)) {\n            previousAllowKeyword = state.allowKeyword;\n            state.allowKeyword = true;\n            decl = parseVariableDeclarationList('let');\n            state.allowKeyword = previousAllowKeyword;\n            return markerApply(marker, delegate.createExportDeclaration(decl, null, null));\n        }\n        specifiers = [];\n        src = null;\n        if (match('*')) {\n            specifiers.push(parseExportBatchSpecifier());\n        } else {\n            expect('{');\n            do {\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n            expect('}');\n        }\n        if (matchContextualKeyword('from')) {\n            lex();\n            src = parsePrimaryExpression();\n            if (src.type !== Syntax.Literal) {\n                throwError({}, Messages.InvalidModuleSpecifier);\n            }\n        }\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExportDeclaration(null, specifiers, src));\n    }\n    function parseImportDeclaration() {\n        var specifiers, kind, src, marker = markerCreate();\n        expectKeyword('import');\n        specifiers = [];\n        if (isIdentifierName(lookahead)) {\n            kind = 'default';\n            specifiers.push(parseImportSpecifier());\n            if (!matchContextualKeyword('from')) {\n                throwError({}, Messages.NoFromAfterImport);\n            }\n            lex();\n        } else if (match('{')) {\n            kind = 'named';\n            lex();\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n            expect('}');\n            if (!matchContextualKeyword('from')) {\n                throwError({}, Messages.NoFromAfterImport);\n            }\n            lex();\n        }\n        src = parsePrimaryExpression();\n        if (src.type !== Syntax.Literal) {\n            throwError({}, Messages.InvalidModuleSpecifier);\n        }\n        consumeSemicolon();\n        return markerApply(marker, delegate.createImportDeclaration(specifiers, kind, src));\n    }\n    function parseImportSpecifier() {\n        var id, name = null, marker = markerCreate();\n        id = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseVariableIdentifier();\n        }\n        return markerApply(marker, delegate.createImportSpecifier(id, name));\n    }\n    function parseEmptyStatement() {\n        var marker = markerCreate();\n        expect(';');\n        return markerApply(marker, delegate.createEmptyStatement());\n    }\n    function parseExpressionStatement() {\n        var marker = markerCreate(), expr = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n    function parseIfStatement() {\n        var test, consequent, alternate, marker = markerCreate();\n        expectKeyword('if');\n        expect('(');\n        test = parseExpression();\n        expect(')');\n        consequent = parseStatement();\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));\n    }\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration, marker = markerCreate();\n        expectKeyword('do');\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n        body = parseStatement();\n        state.inIteration = oldInIteration;\n        expectKeyword('while');\n        expect('(');\n        test = parseExpression();\n        expect(')');\n        if (match(';')) {\n            lex();\n        }\n        return markerApply(marker, delegate.createDoWhileStatement(body, test));\n    }\n    function parseWhileStatement() {\n        var test, body, oldInIteration, marker = markerCreate();\n        expectKeyword('while');\n        expect('(');\n        test = parseExpression();\n        expect(')');\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n        body = parseStatement();\n        state.inIteration = oldInIteration;\n        return markerApply(marker, delegate.createWhileStatement(test, body));\n    }\n    function parseForVariableDeclaration() {\n        var marker = markerCreate(), token = lex(), declarations = parseVariableDeclarationList();\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));\n    }\n    function parseForStatement(opts) {\n        var init, test, update, left, right, body, operator, oldInIteration, marker = markerCreate();\n        init = test = update = null;\n        expectKeyword('for');\n        if (// http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n            matchContextualKeyword('each')) {\n            throwError({}, Messages.EachNotAllowed);\n        }\n        expect('(');\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n                if (init.declarations.length === 1) {\n                    if (matchKeyword('in') || matchContextualKeyword('of')) {\n                        operator = lookahead;\n                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n                            lex();\n                            left = init;\n                            right = parseExpression();\n                            init = null;\n                        }\n                    }\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n                if (matchContextualKeyword('of')) {\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchKeyword('in')) {\n                    if (// LeftHandSideExpression\n                        !isAssignableLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n        if (typeof left === 'undefined') {\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n        expect(')');\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n        if (!(opts !== undefined && opts.ignoreBody)) {\n            body = parseStatement();\n        }\n        state.inIteration = oldInIteration;\n        if (typeof left === 'undefined') {\n            return markerApply(marker, delegate.createForStatement(init, test, update, body));\n        }\n        if (operator.value === 'in') {\n            return markerApply(marker, delegate.createForInStatement(left, right, body));\n        }\n        return markerApply(marker, delegate.createForOfStatement(left, right, body));\n    }\n    function parseContinueStatement() {\n        var label = null, key, marker = markerCreate();\n        expectKeyword('continue');\n        if (// Optimize the most common form: 'continue;'.\n            lookahead.value.charCodeAt(0) === 59) {\n            lex();\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n        consumeSemicolon();\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n        return markerApply(marker, delegate.createContinueStatement(label));\n    }\n    function parseBreakStatement() {\n        var label = null, key, marker = markerCreate();\n        expectKeyword('break');\n        if (// Catch the very common case first: immediately a semicolon (char #59).\n            lookahead.value.charCodeAt(0) === 59) {\n            lex();\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n        consumeSemicolon();\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n        return markerApply(marker, delegate.createBreakStatement(label));\n    }\n    function parseReturnStatement() {\n        var argument = null, marker = markerCreate();\n        expectKeyword('return');\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n        if (// 'return' followed by a space and an identifier is very common.\n            isIdentifierStart(String(lookahead.value).charCodeAt(0))) {\n            argument = parseExpression();\n            consumeSemicolon();\n            return markerApply(marker, delegate.createReturnStatement(argument));\n        }\n        if (peekLineTerminator()) {\n            return markerApply(marker, delegate.createReturnStatement(null));\n        }\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n        consumeSemicolon();\n        return markerApply(marker, delegate.createReturnStatement(argument));\n    }\n    function parseWithStatement() {\n        var object, body, marker = markerCreate();\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n        expectKeyword('with');\n        expect('(');\n        object = parseExpression();\n        expect(')');\n        body = parseStatement();\n        return markerApply(marker, delegate.createWithStatement(object, body));\n    }\n    function parseSwitchCase() {\n        var test, consequent = [], sourceElement, marker = markerCreate();\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n        while (streamIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            consequent.push(sourceElement);\n        }\n        return markerApply(marker, delegate.createSwitchCase(test, consequent));\n    }\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();\n        expectKeyword('switch');\n        expect('(');\n        discriminant = parseExpression();\n        expect(')');\n        expect('{');\n        cases = [];\n        if (match('}')) {\n            lex();\n            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n        }\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n        while (streamIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n        state.inSwitch = oldInSwitch;\n        expect('}');\n        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n    }\n    function parseThrowStatement() {\n        var argument, marker = markerCreate();\n        expectKeyword('throw');\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n        argument = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createThrowStatement(argument));\n    }\n    function parseCatchClause() {\n        var param, body, marker = markerCreate();\n        expectKeyword('catch');\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n        param = parseExpression();\n        if (// 12.14.1\n            strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n        expect(')');\n        body = parseBlock();\n        return markerApply(marker, delegate.createCatchClause(param, body));\n    }\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null, marker = markerCreate();\n        expectKeyword('try');\n        block = parseBlock();\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));\n    }\n    function parseDebuggerStatement() {\n        var marker = markerCreate();\n        expectKeyword('debugger');\n        consumeSemicolon();\n        return markerApply(marker, delegate.createDebuggerStatement());\n    }\n    function parseStatement() {\n        var type = lookahead.type, marker, expr, labeledBody, key;\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'class':\n                return parseClassDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n        marker = markerCreate();\n        expr = parseExpression();\n        if (// 12.12 Labelled Statements\n            expr.type === Syntax.Identifier && match(':')) {\n            lex();\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));\n        }\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount, marker = markerCreate();\n        expect('{');\n        while (streamIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = token.value;\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesizedCount = state.parenthesizedCount;\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n        while (streamIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        expect('}');\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesizedCount;\n        return markerApply(marker, delegate.createBlockStatement(sourceElements));\n    }\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n    function parseParam(options) {\n        var token, rest, param, def;\n        token = lookahead;\n        if (token.value === '...') {\n            token = lex();\n            rest = true;\n        }\n        if (match('[')) {\n            param = parseArrayInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n        } else if (match('{')) {\n            if (rest) {\n                throwError({}, Messages.ObjectPatternAsRestParameter);\n            }\n            param = parseObjectInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n        } else {\n            param = parseVariableIdentifier();\n            validateParam(options, token, token.value);\n        }\n        if (match('=')) {\n            if (rest) {\n                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n            }\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n        if (rest) {\n            if (!match(')')) {\n                throwError({}, Messages.ParameterAfterRestParameter);\n            }\n            options.rest = param;\n            return false;\n        }\n        options.params.push(param);\n        options.defaults.push(def);\n        return !match(')');\n    }\n    function parseParams(firstRestricted) {\n        var options;\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            rest: null,\n            firstRestricted: firstRestricted\n        };\n        expect('(');\n        if (!match(')')) {\n            options.paramSet = {};\n            while (streamIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n        expect(')');\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n        return options;\n    }\n    function parseFunctionDeclaration() {\n        var id, body, token, tmp, firstRestricted, message, previousStrict, previousYieldAllowed, generator, marker = markerCreate();\n        expectKeyword('function');\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        return markerApply(marker, delegate.createFunctionDeclaration(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false));\n    }\n    function parseFunctionExpression() {\n        var token, id = null, firstRestricted, message, tmp, body, previousStrict, previousYieldAllowed, generator, marker = markerCreate();\n        expectKeyword('function');\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        return markerApply(marker, delegate.createFunctionExpression(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false));\n    }\n    function parseYieldExpression() {\n        var yieldToken, delegateFlag, expr, marker = markerCreate();\n        yieldToken = lex();\n        assert(yieldToken.value === 'yield', 'Called parseYieldExpression with non-yield lookahead.');\n        if (!state.yieldAllowed) {\n            throwErrorTolerant({}, Messages.IllegalYield);\n        }\n        delegateFlag = false;\n        if (match('*')) {\n            lex();\n            delegateFlag = true;\n        }\n        expr = parseAssignmentExpression();\n        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));\n    }\n    function parseMethodDefinition(existingPropNames) {\n        var token, key, param, propType, isValidDuplicateProp = false, marker = markerCreate();\n        if (lookahead.value === 'static') {\n            propType = ClassPropertyType.static;\n            lex();\n        } else {\n            propType = ClassPropertyType.prototype;\n        }\n        if (match('*')) {\n            lex();\n            return markerApply(marker, delegate.createMethodDefinition(propType, '', parseObjectPropertyKey(), parsePropertyMethodFunction({ generator: true })));\n        }\n        token = lookahead;\n        key = parseObjectPropertyKey();\n        if (token.value === 'get' && !match('(')) {\n            key = parseObjectPropertyKey();\n            if (// It is a syntax error if any other properties have a name\n                // duplicating this one unless they are a setter\n                existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp = // There isn't already a getter for this prop\n                existingPropNames[propType][key.name].get === undefined && // There isn't already a data prop by this name\n                existingPropNames[propType][key.name].data === undefined && // The only existing prop by this name is a setter\n                existingPropNames[propType][key.name].set !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].get = true;\n            expect('(');\n            expect(')');\n            return markerApply(marker, delegate.createMethodDefinition(propType, 'get', key, parsePropertyFunction({ generator: false })));\n        }\n        if (token.value === 'set' && !match('(')) {\n            key = parseObjectPropertyKey();\n            if (// It is a syntax error if any other properties have a name\n                // duplicating this one unless they are a getter\n                existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp = // There isn't already a setter for this prop\n                existingPropNames[propType][key.name].set === undefined && // There isn't already a data prop by this name\n                existingPropNames[propType][key.name].data === undefined && // The only existing prop by this name is a getter\n                existingPropNames[propType][key.name].get !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].set = true;\n            expect('(');\n            token = lookahead;\n            param = [parseVariableIdentifier()];\n            expect(')');\n            return markerApply(marker, delegate.createMethodDefinition(propType, 'set', key, parsePropertyFunction({\n                params: param,\n                generator: false,\n                name: token\n            })));\n        }\n        if (// It is a syntax error if any other properties have the same name as a\n            // non-getter, non-setter method\n            existingPropNames[propType].hasOwnProperty(key.name)) {\n            throwError(key, Messages.IllegalDuplicateClassProperty);\n        } else {\n            existingPropNames[propType][key.name] = {};\n        }\n        existingPropNames[propType][key.name].data = true;\n        return markerApply(marker, delegate.createMethodDefinition(propType, '', key, parsePropertyMethodFunction({ generator: false })));\n    }\n    function parseClassElement(existingProps) {\n        if (match(';')) {\n            lex();\n            return;\n        }\n        return parseMethodDefinition(existingProps);\n    }\n    function parseClassBody() {\n        var classElement, classElements = [], existingProps = {}, marker = markerCreate();\n        existingProps[ClassPropertyType.static] = {};\n        existingProps[ClassPropertyType.prototype] = {};\n        expect('{');\n        while (streamIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            classElement = parseClassElement(existingProps);\n            if (typeof classElement !== 'undefined') {\n                classElements.push(classElement);\n            }\n        }\n        expect('}');\n        return markerApply(marker, delegate.createClassBody(classElements));\n    }\n    function parseClassExpression() {\n        var id, previousYieldAllowed, superClass = null, marker = markerCreate();\n        expectKeyword('class');\n        if (!matchKeyword('extends') && !match('{')) {\n            id = parseVariableIdentifier();\n        }\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseAssignmentExpression();\n            state.yieldAllowed = previousYieldAllowed;\n        }\n        return markerApply(marker, delegate.createClassExpression(id, superClass, parseClassBody()));\n    }\n    function parseClassDeclaration() {\n        var id, previousYieldAllowed, superClass = null, marker = markerCreate();\n        expectKeyword('class');\n        id = parseVariableIdentifier();\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseAssignmentExpression();\n            state.yieldAllowed = previousYieldAllowed;\n        }\n        return markerApply(marker, delegate.createClassDeclaration(id, superClass, parseClassBody()));\n    }\n    function matchModuleDeclaration() {\n        var id;\n        if (matchContextualKeyword('module')) {\n            id = lookahead2();\n            return id.type === Token.StringLiteral || id.type === Token.Identifier;\n        }\n        return false;\n    }\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n        if (matchModuleDeclaration()) {\n            throwError({}, Messages.NestedModule);\n        }\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n    function parseProgramElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            }\n        }\n        if (matchModuleDeclaration()) {\n            return parseModuleDeclaration();\n        }\n        return parseSourceElement();\n    }\n    function parseProgramElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n        while (streamIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n            sourceElement = parseProgramElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = token.value;\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n        while (streamIndex < length) {\n            sourceElement = parseProgramElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n    function parseModuleElement() {\n        return parseSourceElement();\n    }\n    function parseModuleElements() {\n        var list = [], statement;\n        while (streamIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseModuleElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n        return list;\n    }\n    function parseModuleBlock() {\n        var block, marker = markerCreate();\n        expect('{');\n        block = parseModuleElements();\n        expect('}');\n        return markerApply(marker, delegate.createBlockStatement(block));\n    }\n    function parseProgram() {\n        var body, marker = markerCreate();\n        strict = false;\n        peek();\n        body = parseProgramElements();\n        return markerApply(marker, delegate.createProgram(body));\n    }\n    function addComment(type, value, start, end, loc) {\n        var comment;\n        assert(typeof start === 'number', 'Comment must have valid position');\n        if (// Because the way the actual token is scanned, often the comments\n            // (if any) are skipped twice during the lexical analysis.\n            // Thus, we need to skip adding a comment if the comment array already\n            // handled it.\n            state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [\n                start,\n                end\n            ];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n        while (index < length) {\n            ch = source[index];\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch.charCodeAt(0))) {\n                ++index;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++index;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n    function collectToken() {\n        var start, loc, token, range, value;\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n        if (token.type !== Token.EOF) {\n            range = [\n                token.range[0],\n                token.range[1]\n            ];\n            value = source.slice(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n        return token;\n    }\n    function collectRegex() {\n        var pos, loc, regex, token;\n        skipComment();\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n        if (!extra.tokenize) {\n            if (// Pop the previous token, which is likely '/' or '/='\n                extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [\n                    pos,\n                    index\n                ],\n                loc: loc\n            });\n        }\n        return regex;\n    }\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n        extra.tokens = tokens;\n    }\n    function patch() {\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n    function extend(object, properties) {\n        var entry, result = {};\n        for (entry in object) {\n            if (object.hasOwnProperty(entry)) {\n                result[entry] = object[entry];\n            }\n        }\n        for (entry in properties) {\n            if (properties.hasOwnProperty(entry)) {\n                result[entry] = properties[entry];\n            }\n        }\n        return result;\n    }\n    function tokenize(code, options) {\n        var toString, token, tokens;\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = source.length > 0 ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: true,\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n        extra = {};\n        // Options matching.\n        options = options || {};\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n        extra.range = typeof options.range === 'boolean' && options.range;\n        extra.loc = typeof options.loc === 'boolean' && options.loc;\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                if (// Try first to convert to a string. This is good as fast path\n                    // for old IE which understands string indexing for string\n                    // literals only and not for string object.\n                    code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n        patch();\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return tokens;\n    }\n    function blockAllowed(toks, start, inExprDelim, parentIsBlock) {\n        var assignOps = [\n            '=',\n            '+=',\n            '-=',\n            '*=',\n            '/=',\n            '%=',\n            '<<=',\n            '>>=',\n            '>>>=',\n            '&=',\n            '|=',\n            '^=',\n            ','\n        ];\n        var binaryOps = [\n            '+',\n            '-',\n            '*',\n            '/',\n            '%',\n            '<<',\n            '>>',\n            '>>>',\n            '&',\n            '|',\n            '^',\n            '&&',\n            '||',\n            '?',\n            ':',\n            '===',\n            '==',\n            '>=',\n            '<=',\n            '<',\n            '>',\n            '!=',\n            '!==',\n            'instanceof'\n        ];\n        var unaryOps = [\n            '++',\n            '--',\n            '~',\n            '!',\n            'delete',\n            'void',\n            'typeof',\n            'yield',\n            'throw',\n            'new'\n        ];\n        function back(n) {\n            var idx = toks.length - n > 0 ? toks.length - n : 0;\n            return toks[idx];\n        }\n        if (inExprDelim && toks.length - (start + 2) <= 0) {\n            // ... ({...} ...)\n            return false;\n        } else if (back(start + 2).value === ':' && parentIsBlock) {\n            // ...{a:{b:{...}}}\n            return true;\n        } else if (isIn(back(start + 2).value, unaryOps.concat(binaryOps).concat(assignOps))) {\n            // ... + {...}\n            return false;\n        } else if (back(start + 2).value === 'return') {\n            var // ASI makes `{}` a block in:\n            //\n            //    return\n            //    { ... }\n            //\n            // otherwise an object literal, so it's an\n            // expression and thus / is divide\n            currLineNumber = typeof back(start + 1).startLineNumber !== 'undefined' ? back(start + 1).startLineNumber : back(start + 1).lineNumber;\n            if (back(start + 2).lineNumber !== currLineNumber) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (isIn(back(start + 2).value, [\n                'void',\n                'typeof',\n                'in',\n                'case',\n                'delete'\n            ])) {\n            // ... in {}\n            return false;\n        } else {\n            return true;\n        }\n    }\n    var // Readtables\n    readtables = {\n        currentReadtable: {},\n        // A readtable is invoked within `readToken`, but it can\n        // return multiple tokens. We need to \"queue\" the stream of\n        // tokens so that subsequent calls to `readToken` gets the\n        // rest of the stream.\n        queued: [],\n        // A readtable can only override punctuators\n        punctuators: ';,.:!?~=%&*+-/<>^|#@',\n        has: function (ch) {\n            return readtables.currentReadtable[ch] && readtables.punctuators.indexOf(ch) !== -1;\n        },\n        getQueued: function () {\n            return readtables.queued.length ? readtables.queued.shift() : null;\n        },\n        peekQueued: function (lookahead$2) {\n            lookahead$2 = lookahead$2 ? lookahead$2 : 1;\n            return readtables.queued.length ? readtables.queued[lookahead$2 - 1] : null;\n        },\n        invoke: function (ch, toks) {\n            var prevState = snapshotParserState();\n            var newStream = readtables.currentReadtable[ch](ch, readtables.readerAPI, toks, source, index);\n            if (!newStream) {\n                // Reset the state\n                restoreParserState(prevState);\n                return null;\n            } else if (!Array.isArray(newStream)) {\n                newStream = [newStream];\n            }\n            this.queued = this.queued.concat(newStream);\n            return this.getQueued();\n        }\n    };\n    function snapshotParserState() {\n        return {\n            index: index,\n            lineNumber: lineNumber,\n            lineStart: lineStart\n        };\n    }\n    function restoreParserState(prevState) {\n        index = prevState.index;\n        lineNumber = prevState.lineNumber;\n        lineStart = prevState.lineStart;\n    }\n    function suppressReadError(func) {\n        var prevState = snapshotParserState();\n        try {\n            return func();\n        } catch (e) {\n            if (!(e instanceof SyntaxError) && !(e instanceof TypeError)) {\n                restoreParserState(prevState);\n                return null;\n            }\n            throw e;\n        }\n    }\n    function makeIdentifier(value, opts) {\n        opts = opts || {};\n        var type = Token.Identifier;\n        if (isKeyword(value)) {\n            type = Token.Keyword;\n        } else if (value === 'null') {\n            type = Token.NullLiteral;\n        } else if (value === 'true' || value === 'false') {\n            type = Token.BooleanLiteral;\n        }\n        return {\n            type: type,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                opts.start || index,\n                index\n            ]\n        };\n    }\n    function makePunctuator(value, opts) {\n        opts = opts || {};\n        return {\n            type: Token.Punctuator,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                opts.start || index,\n                index\n            ]\n        };\n    }\n    function makeStringLiteral(value, opts) {\n        opts = opts || {};\n        return {\n            type: Token.StringLiteral,\n            value: value,\n            octal: !!opts.octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                opts.start || index,\n                index\n            ]\n        };\n    }\n    function makeNumericLiteral(value, opts) {\n        opts = opts || {};\n        return {\n            type: Token.NumericLiteral,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                opts.start || index,\n                index\n            ]\n        };\n    }\n    function makeRegExp(value, opts) {\n        opts = opts || {};\n        return {\n            type: Token.RegularExpression,\n            value: value,\n            literal: value.toString(),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                opts.start || index,\n                index\n            ]\n        };\n    }\n    function makeDelimiter(value, inner) {\n        var current = {\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [\n                index,\n                index\n            ]\n        };\n        var firstTok = inner.length ? inner[0] : current;\n        var lastTok = inner.length ? inner[inner.length - 1] : current;\n        return {\n            type: Token.Delimiter,\n            value: value,\n            inner: inner,\n            startLineNumber: firstTok.lineNumber,\n            startLineStart: firstTok.lineStart,\n            startRange: firstTok.range,\n            endLineNumber: lastTok.lineNumber,\n            endLineStart: lastTok.lineStart,\n            endRange: lastTok.range\n        };\n    }\n    var // Since an actual parser object doesn't exist and we want to\n    // introduce our own API anyway, we create a special reader object\n    // for reader extensions\n    readerAPI = {\n        Token: Token,\n        get source() {\n            return source;\n        },\n        get index() {\n            return index;\n        },\n        set index(x) {\n            index = x;\n        },\n        get length() {\n            return length;\n        },\n        set length(x) {\n            length = x;\n        },\n        get lineNumber() {\n            return lineNumber;\n        },\n        set lineNumber(x) {\n            lineNumber = x;\n        },\n        get lineStart() {\n            return lineStart;\n        },\n        set lineStart(x) {\n            lineStart = x;\n        },\n        get extra() {\n            return extra;\n        },\n        isIdentifierStart: isIdentifierStart,\n        isIdentifierPart: isIdentifierPart,\n        isLineTerminator: isLineTerminator,\n        readIdentifier: scanIdentifier,\n        readPunctuator: scanPunctuator,\n        readStringLiteral: scanStringLiteral,\n        readNumericLiteral: scanNumericLiteral,\n        readRegExp: scanRegExp,\n        readToken: function () {\n            return readToken([], false, false);\n        },\n        readDelimiter: function () {\n            return readDelim([], false, false);\n        },\n        skipComment: scanComment,\n        makeIdentifier: makeIdentifier,\n        makePunctuator: makePunctuator,\n        makeStringLiteral: makeStringLiteral,\n        makeNumericLiteral: makeNumericLiteral,\n        makeRegExp: makeRegExp,\n        makeDelimiter: makeDelimiter,\n        suppressReadError: suppressReadError,\n        peekQueued: readtables.peekQueued,\n        getQueued: readtables.getQueued\n    };\n    readtables.readerAPI = readerAPI;\n    function readToken(toks, inExprDelim, parentIsBlock) {\n        var delimiters = [\n            '(',\n            '{',\n            '['\n        ];\n        var parenIdents = [\n            'if',\n            'while',\n            'for',\n            'with'\n        ];\n        var last = toks.length - 1;\n        var comments, commentsLen = extra.comments.length;\n        function back(n) {\n            var idx = toks.length - n > 0 ? toks.length - n : 0;\n            return toks[idx];\n        }\n        function attachComments(token) {\n            if (comments) {\n                token.leadingComments = comments;\n            }\n            return token;\n        }\n        function _advance() {\n            return attachComments(advance());\n        }\n        function _scanRegExp() {\n            return attachComments(scanRegExp());\n        }\n        skipComment();\n        var ch = source[index];\n        if (extra.comments.length > commentsLen) {\n            comments = extra.comments.slice(commentsLen);\n        }\n        if (isIn(source[index], delimiters)) {\n            return attachComments(readDelim(toks, inExprDelim, parentIsBlock));\n        }\n        // Check if we should get the token from the readtable\n        var readtableToken;\n        if ((readtableToken = readtables.getQueued()) || readtables.has(ch) && (readtableToken = readtables.invoke(ch, toks))) {\n            return readtableToken;\n        }\n        if (ch === '/') {\n            var prev = back(1);\n            if (prev) {\n                if (prev.value === '()') {\n                    if (isIn(back(2).value, parenIdents)) {\n                        // ... if (...) / ...\n                        return _scanRegExp();\n                    }\n                    // ... (...) / ...\n                    return _advance();\n                }\n                if (prev.value === '{}') {\n                    if (blockAllowed(toks, 0, inExprDelim, parentIsBlock)) {\n                        if (back(2).value === '()') {\n                            if (// named function\n                                back(4).value === 'function') {\n                                if (!blockAllowed(toks, 3, inExprDelim, parentIsBlock)) {\n                                    // new function foo (...) {...} / ...\n                                    return _advance();\n                                }\n                                if (toks.length - 5 <= 0 && inExprDelim) {\n                                    // (function foo (...) {...} /...)\n                                    // [function foo (...) {...} /...]\n                                    return _advance();\n                                }\n                            }\n                            if (// unnamed function\n                                back(3).value === 'function') {\n                                if (!blockAllowed(toks, 2, inExprDelim, parentIsBlock)) {\n                                    // new function (...) {...} / ...\n                                    return _advance();\n                                }\n                                if (toks.length - 4 <= 0 && inExprDelim) {\n                                    // (function (...) {...} /...)\n                                    // [function (...) {...} /...]\n                                    return _advance();\n                                }\n                            }\n                        }\n                        // ...; {...} /...\n                        return _scanRegExp();\n                    } else {\n                        // ... + {...} / ...\n                        return _advance();\n                    }\n                }\n                if (prev.type === Token.Punctuator) {\n                    // ... + /...\n                    return _scanRegExp();\n                }\n                if (isKeyword(prev.value) && prev.value !== 'this' && prev.value !== 'let' && prev.value !== 'export') {\n                    // typeof /...\n                    return _scanRegExp();\n                }\n                return _advance();\n            }\n            return _scanRegExp();\n        }\n        return _advance();\n    }\n    function readDelim(toks, inExprDelim, parentIsBlock) {\n        var startDelim = advance(), matchDelim = {\n                '(': ')',\n                '{': '}',\n                '[': ']'\n            }, inner = [];\n        var delimiters = [\n            '(',\n            '{',\n            '['\n        ];\n        assert(delimiters.indexOf(startDelim.value) !== -1, 'Need to begin at the delimiter');\n        var token = startDelim;\n        var startLineNumber = token.lineNumber;\n        var startLineStart = token.lineStart;\n        var startRange = token.range;\n        var delimToken = {};\n        delimToken.type = Token.Delimiter;\n        delimToken.value = startDelim.value + matchDelim[startDelim.value];\n        delimToken.startLineNumber = startLineNumber;\n        delimToken.startLineStart = startLineStart;\n        delimToken.startRange = startRange;\n        var delimIsBlock = false;\n        if (startDelim.value === '{') {\n            delimIsBlock = blockAllowed(toks.concat(delimToken), 0, inExprDelim, parentIsBlock);\n        }\n        while (index <= length) {\n            token = readToken(inner, startDelim.value === '(' || startDelim.value === '[', delimIsBlock);\n            if (token.type === Token.Punctuator && token.value === matchDelim[startDelim.value]) {\n                if (token.leadingComments) {\n                    delimToken.trailingComments = token.leadingComments;\n                }\n                break;\n            } else if (token.type === Token.EOF) {\n                throwError({}, Messages.UnexpectedEOS);\n            } else {\n                inner.push(token);\n            }\n        }\n        if (// at the end of the stream but the very last char wasn't the closing delimiter\n            index >= length && matchDelim[startDelim.value] !== source[length - 1]) {\n            throwError({}, Messages.UnexpectedEOS);\n        }\n        var endLineNumber = token.lineNumber;\n        var endLineStart = token.lineStart;\n        var endRange = token.range;\n        delimToken.inner = inner;\n        delimToken.endLineNumber = endLineNumber;\n        delimToken.endLineStart = endLineStart;\n        delimToken.endRange = endRange;\n        return delimToken;\n    }\n    function setReadtable(readtable, syn) {\n        readtables.currentReadtable = readtable;\n        if (syn) {\n            readtables.readerAPI.throwSyntaxError = function (name, message, tok) {\n                var sx = syn.syntaxFromToken(tok);\n                var err = new syn.MacroSyntaxError(name, message, sx);\n                throw new SyntaxError(syn.printSyntaxError(source, err));\n            };\n        }\n    }\n    function currentReadtable() {\n        return readtables.currentReadtable;\n    }\n    function read(code) {\n        var token, tokenTree = [];\n        extra = {};\n        extra.comments = [];\n        extra.range = true;\n        extra.loc = true;\n        patch();\n        source = code;\n        index = 0;\n        lineNumber = source.length > 0 ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            lastParenthesized: null,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n        while (index < length || readtables.peekQueued()) {\n            tokenTree.push(readToken(tokenTree, false, false));\n        }\n        var last = tokenTree[tokenTree.length - 1];\n        if (last && last.type !== Token.EOF) {\n            tokenTree.push({\n                type: Token.EOF,\n                value: '',\n                lineNumber: last.lineNumber,\n                lineStart: last.lineStart,\n                range: [\n                    index,\n                    index\n                ]\n            });\n        }\n        return expander.tokensToSyntax(tokenTree);\n    }\n    function parse(code, options) {\n        var program, toString;\n        extra = {};\n        if (// given an array of tokens instead of a string\n            Array.isArray(code)) {\n            tokenStream = code;\n            length = tokenStream.length;\n            lineNumber = tokenStream.length > 0 ? 1 : 0;\n            source = undefined;\n        } else {\n            toString = String;\n            if (typeof code !== 'string' && !(code instanceof String)) {\n                code = toString(code);\n            }\n            source = code;\n            length = source.length;\n            lineNumber = source.length > 0 ? 1 : 0;\n        }\n        delegate = SyntaxTreeDelegate;\n        streamIndex = -1;\n        index = 0;\n        lineStart = 0;\n        sm_lineStart = 0;\n        sm_lineNumber = lineNumber;\n        sm_index = 0;\n        sm_range = [\n            0,\n            0\n        ];\n        lookahead = null;\n        state = {\n            allowKeyword: false,\n            allowIn: true,\n            labelSet: {},\n            parenthesizedCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            yieldAllowed: false\n        };\n        extra.attachComment = true;\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n        if (typeof options !== 'undefined') {\n            extra.range = typeof options.range === 'boolean' && options.range;\n            extra.loc = typeof options.loc === 'boolean' && options.loc;\n            extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                delegate = extend(delegate, {\n                    'postProcess': function (node) {\n                        node.loc.source = toString(options.source);\n                        return node;\n                    }\n                });\n            }\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n        if (length > 0) {\n            if (source && typeof source[0] === 'undefined') {\n                if (// Try first to convert to a string. This is good as fast path\n                    // for old IE which understands string indexing for string\n                    // literals only and not for string object.\n                    code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n        extra.loc = true;\n        extra.errors = [];\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return program;\n    }\n    exports$2.tokenize = tokenize;\n    exports$2.read = read;\n    exports$2.Token = Token;\n    exports$2.setReadtable = setReadtable;\n    exports$2.currentReadtable = currentReadtable;\n    exports$2.parse = parse;\n    // Deep copy.\n    exports$2.Syntax = function () {\n        var name, types = {};\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n        return types;\n    }();\n}));\n//# sourceMappingURL=parser.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/parser.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/parser.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("(function (root, factory) {\n    if (true) {\n        // CommonJS\n        factory(exports, __webpack_require__(15), __webpack_require__(13), __webpack_require__(16), __webpack_require__(17), __webpack_require__(18), __webpack_require__(19));\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([\n            'exports',\n            'underscore',\n            'parser',\n            'syntax',\n            'scopedEval',\n            'patterns'\n        ], factory);\n    }\n}(this, function (exports$2, _, parser, syn, se, patternModule, gen) {\n    'use strict';\n    var // escodegen still doesn't quite support AMD: https://github.com/Constellation/escodegen/issues/115\n    codegen = typeof escodegen !== 'undefined' ? escodegen : gen;\n    var assert = syn.assert;\n    var throwSyntaxError = syn.throwSyntaxError;\n    var throwSyntaxCaseError = syn.throwSyntaxCaseError;\n    var SyntaxCaseError = syn.SyntaxCaseError;\n    var unwrapSyntax = syn.unwrapSyntax;\n    // used to export \"private\" methods for unit testing\n    exports$2._test = {};\n    function StringMap(o) {\n        this.__data = o || {};\n    }\n    StringMap.prototype = {\n        has: function (key) {\n            return Object.prototype.hasOwnProperty.call(this.__data, key);\n        },\n        get: function (key) {\n            return this.has(key) ? this.__data[key] : void 0;\n        },\n        set: function (key, value) {\n            this.__data[key] = value;\n        },\n        extend: function () {\n            var args = _.map(_.toArray(arguments), function (x) {\n                return x.__data;\n            });\n            _.extend.apply(_, [this.__data].concat(args));\n            return this;\n        }\n    };\n    var scopedEval = se.scopedEval;\n    var Rename = syn.Rename;\n    var Mark = syn.Mark;\n    var Def = syn.Def;\n    var syntaxFromToken = syn.syntaxFromToken;\n    var joinSyntax = syn.joinSyntax;\n    var builtinMode = false;\n    var expandCount = 0;\n    var maxExpands;\n    var push = Array.prototype.push;\n    function remdup(mark, mlist) {\n        if (mark === _.first(mlist)) {\n            return _.rest(mlist, 1);\n        }\n        return [mark].concat(mlist);\n    }\n    function marksof(ctx, stopName, originalName) {\n        while (ctx) {\n            if (ctx.constructor === Mark) {\n                return remdup(ctx.mark, marksof(ctx.context, stopName, originalName));\n            }\n            if (ctx.constructor === Def) {\n                ctx = ctx.context;\n                continue;\n            }\n            if (ctx.constructor === Rename) {\n                if (stopName === originalName + '$' + ctx.name) {\n                    return [];\n                }\n                ctx = ctx.context;\n                continue;\n            }\n        }\n        return [];\n    }\n    function resolve(stx) {\n        return resolveCtx(stx.token.value, stx.context, [], [], {});\n    }\n    function resolveCtx(originalName, ctx, stop_spine, stop_branch, cache) {\n        if (!ctx) {\n            return originalName;\n        }\n        var key = ctx.instNum;\n        return cache[key] || (cache[key] = resolveCtxFull(originalName, ctx, stop_spine, stop_branch, cache));\n    }\n    function resolveCtxFull(originalName, ctx, stop_spine, stop_branch, cache) {\n        while (true) {\n            if (!ctx) {\n                return originalName;\n            }\n            if (ctx.constructor === Mark) {\n                ctx = ctx.context;\n                continue;\n            }\n            if (ctx.constructor === Def) {\n                if (stop_spine.indexOf(ctx.defctx) !== -1) {\n                    ctx = ctx.context;\n                    continue;\n                } else {\n                    stop_branch = unionEl(stop_branch, ctx.defctx);\n                    ctx = renames(ctx.defctx, ctx.context, originalName);\n                    continue;\n                }\n            }\n            if (ctx.constructor === Rename) {\n                if (originalName === ctx.id.token.value) {\n                    var idName = resolveCtx(ctx.id.token.value, ctx.id.context, stop_branch, stop_branch, cache);\n                    var subName = resolveCtx(originalName, ctx.context, unionEl(stop_spine, ctx.def), stop_branch, cache);\n                    if (idName === subName) {\n                        var idMarks = marksof(ctx.id.context, originalName + '$' + ctx.name, originalName);\n                        var subMarks = marksof(ctx.context, originalName + '$' + ctx.name, originalName);\n                        if (arraysEqual(idMarks, subMarks)) {\n                            return originalName + '$' + ctx.name;\n                        }\n                    }\n                }\n                ctx = ctx.context;\n                continue;\n            }\n            return originalName;\n        }\n    }\n    function arraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function renames(defctx, oldctx, originalName) {\n        var acc = oldctx;\n        for (var i = 0; i < defctx.length; i++) {\n            if (defctx[i].id.token.value === originalName) {\n                acc = new Rename(defctx[i].id, defctx[i].name, acc, defctx);\n            }\n        }\n        return acc;\n    }\n    function unionEl(arr, el) {\n        if (arr.indexOf(el) === -1) {\n            var res = arr.slice(0);\n            res.push(el);\n            return res;\n        }\n        return arr;\n    }\n    var nextFresh = 0;\n    function fresh() {\n        return nextFresh++;\n    }\n    function wrapDelim(towrap, delimSyntax) {\n        assert(delimSyntax.token.type === parser.Token.Delimiter, 'expecting a delimiter token');\n        return syntaxFromToken({\n            type: parser.Token.Delimiter,\n            value: delimSyntax.token.value,\n            inner: towrap,\n            range: delimSyntax.token.range,\n            startLineNumber: delimSyntax.token.startLineNumber,\n            lineStart: delimSyntax.token.lineStart\n        }, delimSyntax);\n    }\n    function getParamIdentifiers(argSyntax) {\n        if (argSyntax.token.type === parser.Token.Delimiter) {\n            return _.filter(argSyntax.token.inner, function (stx) {\n                return stx.token.value !== ',';\n            });\n        } else if (argSyntax.token.type === parser.Token.Identifier) {\n            return [argSyntax];\n        } else {\n            assert(false, 'expecting a delimiter or a single identifier for function parameters');\n        }\n    }\n    function inherit(parent, child, methods) {\n        var P = function () {\n        };\n        P.prototype = parent.prototype;\n        child.prototype = new P();\n        child.prototype.constructor = child;\n        _.extend(child.prototype, methods);\n    }\n    function TermTree() {\n    }\n    TermTree.properties = [];\n    TermTree.create = function () {\n        return new TermTree();\n    };\n    TermTree.prototype = {\n        'isTermTree': true,\n        'destruct': function () {\n            var self = this;\n            return _.reduce(this.constructor.properties, function (acc, prop) {\n                if (self[prop] && self[prop].isTermTree) {\n                    push.apply(acc, self[prop].destruct());\n                    return acc;\n                } else if (self[prop] && self[prop].token && self[prop].token.inner) {\n                    var src = self[prop].token;\n                    var keys = Object.keys(src);\n                    var newtok = {};\n                    for (var i = 0, len = keys.length, key; i < len; i++) {\n                        key = keys[i];\n                        newtok[key] = src[key];\n                    }\n                    var clone = syntaxFromToken(newtok, self[prop]);\n                    clone.token.inner = _.reduce(clone.token.inner, function (acc$2, t) {\n                        if (t && t.isTermTree) {\n                            push.apply(acc$2, t.destruct());\n                            return acc$2;\n                        }\n                        acc$2.push(t);\n                        return acc$2;\n                    }, []);\n                    acc.push(clone);\n                    return acc;\n                } else if (Array.isArray(self[prop])) {\n                    var destArr = _.reduce(self[prop], function (acc$2, t) {\n                        if (t && t.isTermTree) {\n                            push.apply(acc$2, t.destruct());\n                            return acc$2;\n                        }\n                        acc$2.push(t);\n                        return acc$2;\n                    }, []);\n                    push.apply(acc, destArr);\n                    return acc;\n                } else if (self[prop]) {\n                    acc.push(self[prop]);\n                    return acc;\n                } else {\n                    return acc;\n                }\n            }, []);\n        },\n        'addDefCtx': function (def) {\n            var self = this;\n            _.each(this.constructor.properties, function (prop) {\n                if (Array.isArray(self[prop])) {\n                    self[prop] = _.map(self[prop], function (item) {\n                        return item.addDefCtx(def);\n                    });\n                } else if (self[prop]) {\n                    self[prop] = self[prop].addDefCtx(def);\n                }\n            });\n            return this;\n        },\n        'rename': function (id, name) {\n            var self = this;\n            _.each(this.constructor.properties, function (prop) {\n                if (Array.isArray(self[prop])) {\n                    self[prop] = _.map(self[prop], function (item) {\n                        return item.rename(id, name);\n                    });\n                } else if (self[prop]) {\n                    self[prop] = self[prop].rename(id, name);\n                }\n            });\n            return this;\n        }\n    };\n    function EOF(eof) {\n        this.eof = eof;\n    }\n    EOF.properties = ['eof'];\n    EOF.create = function (eof) {\n        return new EOF(eof);\n    };\n    inherit(TermTree, EOF, { 'isEOF': true });\n    function Keyword(keyword) {\n        this.keyword = keyword;\n    }\n    Keyword.properties = ['keyword'];\n    Keyword.create = function (keyword) {\n        return new Keyword(keyword);\n    };\n    inherit(TermTree, Keyword, { 'isKeyword': true });\n    function Punc(punc) {\n        this.punc = punc;\n    }\n    Punc.properties = ['punc'];\n    Punc.create = function (punc) {\n        return new Punc(punc);\n    };\n    inherit(TermTree, Punc, { 'isPunc': true });\n    function Delimiter(delim) {\n        this.delim = delim;\n    }\n    Delimiter.properties = ['delim'];\n    Delimiter.create = function (delim) {\n        return new Delimiter(delim);\n    };\n    inherit(TermTree, Delimiter, { 'isDelimiter': true });\n    function LetMacro(name, body) {\n        this.name = name;\n        this.body = body;\n    }\n    LetMacro.properties = [\n        'name',\n        'body'\n    ];\n    LetMacro.create = function (name, body) {\n        return new LetMacro(name, body);\n    };\n    inherit(TermTree, LetMacro, { 'isLetMacro': true });\n    function Macro(name, body) {\n        this.name = name;\n        this.body = body;\n    }\n    Macro.properties = [\n        'name',\n        'body'\n    ];\n    Macro.create = function (name, body) {\n        return new Macro(name, body);\n    };\n    inherit(TermTree, Macro, { 'isMacro': true });\n    function AnonMacro(body) {\n        this.body = body;\n    }\n    AnonMacro.properties = ['body'];\n    AnonMacro.create = function (body) {\n        return new AnonMacro(body);\n    };\n    inherit(TermTree, AnonMacro, { 'isAnonMacro': true });\n    function OperatorDefinition(type, name, prec, assoc, body) {\n        this.type = type;\n        this.name = name;\n        this.prec = prec;\n        this.assoc = assoc;\n        this.body = body;\n    }\n    OperatorDefinition.properties = [\n        'type',\n        'name',\n        'prec',\n        'assoc',\n        'body'\n    ];\n    OperatorDefinition.create = function (type, name, prec, assoc, body) {\n        return new OperatorDefinition(type, name, prec, assoc, body);\n    };\n    inherit(TermTree, OperatorDefinition, { 'isOperatorDefinition': true });\n    function Module(body, exports$3) {\n        this.body = body;\n        this.exports = exports$3;\n    }\n    Module.properties = [\n        'body',\n        'exports'\n    ];\n    Module.create = function (body, exports$3) {\n        return new Module(body, exports$3);\n    };\n    inherit(TermTree, Module, { 'isModule': true });\n    function Export(name) {\n        this.name = name;\n    }\n    Export.properties = ['name'];\n    Export.create = function (name) {\n        return new Export(name);\n    };\n    inherit(TermTree, Export, { 'isExport': true });\n    function VariableDeclaration(ident, eq, init, comma) {\n        this.ident = ident;\n        this.eq = eq;\n        this.init = init;\n        this.comma = comma;\n    }\n    VariableDeclaration.properties = [\n        'ident',\n        'eq',\n        'init',\n        'comma'\n    ];\n    VariableDeclaration.create = function (ident, eq, init, comma) {\n        return new VariableDeclaration(ident, eq, init, comma);\n    };\n    inherit(TermTree, VariableDeclaration, { 'isVariableDeclaration': true });\n    function Statement() {\n    }\n    Statement.properties = [];\n    Statement.create = function () {\n        return new Statement();\n    };\n    inherit(TermTree, Statement, { 'isStatement': true });\n    function Empty() {\n    }\n    Empty.properties = [];\n    Empty.create = function () {\n        return new Empty();\n    };\n    inherit(Statement, Empty, { 'isEmpty': true });\n    function CatchClause(keyword, params, body) {\n        this.keyword = keyword;\n        this.params = params;\n        this.body = body;\n    }\n    CatchClause.properties = [\n        'keyword',\n        'params',\n        'body'\n    ];\n    CatchClause.create = function (keyword, params, body) {\n        return new CatchClause(keyword, params, body);\n    };\n    inherit(Statement, CatchClause, { 'isCatchClause': true });\n    function ForStatement(keyword, cond) {\n        this.keyword = keyword;\n        this.cond = cond;\n    }\n    ForStatement.properties = [\n        'keyword',\n        'cond'\n    ];\n    ForStatement.create = function (keyword, cond) {\n        return new ForStatement(keyword, cond);\n    };\n    inherit(Statement, ForStatement, { 'isForStatement': true });\n    function ReturnStatement(keyword, expr) {\n        this.keyword = keyword;\n        this.expr = expr;\n    }\n    ReturnStatement.properties = [\n        'keyword',\n        'expr'\n    ];\n    ReturnStatement.create = function (keyword, expr) {\n        return new ReturnStatement(keyword, expr);\n    };\n    inherit(Statement, ReturnStatement, {\n        'isReturnStatement': true,\n        'destruct': function () {\n            var expr = this.expr.destruct();\n            // need to adjust the line numbers to make sure that the expr\n            // starts on the same line as the return keyword. This might\n            // not be the case if an operator or infix macro perturbed the\n            // line numbers during expansion.\n            expr = adjustLineContext(expr, this.keyword.keyword);\n            return this.keyword.destruct().concat(expr);\n        }\n    });\n    function Expr() {\n    }\n    Expr.properties = [];\n    Expr.create = function () {\n        return new Expr();\n    };\n    inherit(Statement, Expr, { 'isExpr': true });\n    function UnaryOp(op, expr) {\n        this.op = op;\n        this.expr = expr;\n    }\n    UnaryOp.properties = [\n        'op',\n        'expr'\n    ];\n    UnaryOp.create = function (op, expr) {\n        return new UnaryOp(op, expr);\n    };\n    inherit(Expr, UnaryOp, { 'isUnaryOp': true });\n    function PostfixOp(expr, op) {\n        this.expr = expr;\n        this.op = op;\n    }\n    PostfixOp.properties = [\n        'expr',\n        'op'\n    ];\n    PostfixOp.create = function (expr, op) {\n        return new PostfixOp(expr, op);\n    };\n    inherit(Expr, PostfixOp, { 'isPostfixOp': true });\n    function BinOp(left, op, right) {\n        this.left = left;\n        this.op = op;\n        this.right = right;\n    }\n    BinOp.properties = [\n        'left',\n        'op',\n        'right'\n    ];\n    BinOp.create = function (left, op, right) {\n        return new BinOp(left, op, right);\n    };\n    inherit(Expr, BinOp, { 'isBinOp': true });\n    function AssignmentExpression(left, op, right) {\n        this.left = left;\n        this.op = op;\n        this.right = right;\n    }\n    AssignmentExpression.properties = [\n        'left',\n        'op',\n        'right'\n    ];\n    AssignmentExpression.create = function (left, op, right) {\n        return new AssignmentExpression(left, op, right);\n    };\n    inherit(Expr, AssignmentExpression, { 'isAssignmentExpression': true });\n    function ConditionalExpression(cond, question, tru, colon, fls) {\n        this.cond = cond;\n        this.question = question;\n        this.tru = tru;\n        this.colon = colon;\n        this.fls = fls;\n    }\n    ConditionalExpression.properties = [\n        'cond',\n        'question',\n        'tru',\n        'colon',\n        'fls'\n    ];\n    ConditionalExpression.create = function (cond, question, tru, colon, fls) {\n        return new ConditionalExpression(cond, question, tru, colon, fls);\n    };\n    inherit(Expr, ConditionalExpression, { 'isConditionalExpression': true });\n    function NamedFun(keyword, star, name, params, body) {\n        this.keyword = keyword;\n        this.star = star;\n        this.name = name;\n        this.params = params;\n        this.body = body;\n    }\n    NamedFun.properties = [\n        'keyword',\n        'star',\n        'name',\n        'params',\n        'body'\n    ];\n    NamedFun.create = function (keyword, star, name, params, body) {\n        return new NamedFun(keyword, star, name, params, body);\n    };\n    inherit(Expr, NamedFun, { 'isNamedFun': true });\n    function AnonFun(keyword, star, params, body) {\n        this.keyword = keyword;\n        this.star = star;\n        this.params = params;\n        this.body = body;\n    }\n    AnonFun.properties = [\n        'keyword',\n        'star',\n        'params',\n        'body'\n    ];\n    AnonFun.create = function (keyword, star, params, body) {\n        return new AnonFun(keyword, star, params, body);\n    };\n    inherit(Expr, AnonFun, { 'isAnonFun': true });\n    function ArrowFun(params, arrow, body) {\n        this.params = params;\n        this.arrow = arrow;\n        this.body = body;\n    }\n    ArrowFun.properties = [\n        'params',\n        'arrow',\n        'body'\n    ];\n    ArrowFun.create = function (params, arrow, body) {\n        return new ArrowFun(params, arrow, body);\n    };\n    inherit(Expr, ArrowFun, { 'isArrowFun': true });\n    function ObjDotGet(left, dot, right) {\n        this.left = left;\n        this.dot = dot;\n        this.right = right;\n    }\n    ObjDotGet.properties = [\n        'left',\n        'dot',\n        'right'\n    ];\n    ObjDotGet.create = function (left, dot, right) {\n        return new ObjDotGet(left, dot, right);\n    };\n    inherit(Expr, ObjDotGet, { 'isObjDotGet': true });\n    function ObjGet(left, right) {\n        this.left = left;\n        this.right = right;\n    }\n    ObjGet.properties = [\n        'left',\n        'right'\n    ];\n    ObjGet.create = function (left, right) {\n        return new ObjGet(left, right);\n    };\n    inherit(Expr, ObjGet, { 'isObjGet': true });\n    function Template(template) {\n        this.template = template;\n    }\n    Template.properties = ['template'];\n    Template.create = function (template) {\n        return new Template(template);\n    };\n    inherit(Expr, Template, { 'isTemplate': true });\n    function Call(fun, args) {\n        this.fun = fun;\n        this.args = args;\n    }\n    Call.properties = [\n        'fun',\n        'args'\n    ];\n    Call.create = function (fun, args) {\n        return new Call(fun, args);\n    };\n    inherit(Expr, Call, { 'isCall': true });\n    function PrimaryExpression() {\n    }\n    PrimaryExpression.properties = [];\n    PrimaryExpression.create = function () {\n        return new PrimaryExpression();\n    };\n    inherit(Expr, PrimaryExpression, { 'isPrimaryExpression': true });\n    function ThisExpression(keyword) {\n        this.keyword = keyword;\n    }\n    ThisExpression.properties = ['keyword'];\n    ThisExpression.create = function (keyword) {\n        return new ThisExpression(keyword);\n    };\n    inherit(PrimaryExpression, ThisExpression, { 'isThisExpression': true });\n    function Lit(lit) {\n        this.lit = lit;\n    }\n    Lit.properties = ['lit'];\n    Lit.create = function (lit) {\n        return new Lit(lit);\n    };\n    inherit(PrimaryExpression, Lit, { 'isLit': true });\n    function Block(body) {\n        this.body = body;\n    }\n    Block.properties = ['body'];\n    Block.create = function (body) {\n        return new Block(body);\n    };\n    inherit(PrimaryExpression, Block, { 'isBlock': true });\n    function ArrayLiteral(array) {\n        this.array = array;\n    }\n    ArrayLiteral.properties = ['array'];\n    ArrayLiteral.create = function (array) {\n        return new ArrayLiteral(array);\n    };\n    inherit(PrimaryExpression, ArrayLiteral, { 'isArrayLiteral': true });\n    function Id(id) {\n        this.id = id;\n    }\n    Id.properties = ['id'];\n    Id.create = function (id) {\n        return new Id(id);\n    };\n    inherit(PrimaryExpression, Id, { 'isId': true });\n    function Partial() {\n    }\n    Partial.properties = [];\n    Partial.create = function () {\n        return new Partial();\n    };\n    inherit(TermTree, Partial, { 'isPartial': true });\n    function PartialOperation(stx, left) {\n        this.stx = stx;\n        this.left = left;\n    }\n    PartialOperation.properties = [\n        'stx',\n        'left'\n    ];\n    PartialOperation.create = function (stx, left) {\n        return new PartialOperation(stx, left);\n    };\n    inherit(Partial, PartialOperation, { 'isPartialOperation': true });\n    function PartialExpression(stx, left, combine) {\n        this.stx = stx;\n        this.left = left;\n        this.combine = combine;\n    }\n    PartialExpression.properties = [\n        'stx',\n        'left',\n        'combine'\n    ];\n    PartialExpression.create = function (stx, left, combine) {\n        return new PartialExpression(stx, left, combine);\n    };\n    inherit(Partial, PartialExpression, { 'isPartialExpression': true });\n    function BindingStatement(keyword, decls) {\n        this.keyword = keyword;\n        this.decls = decls;\n    }\n    BindingStatement.properties = [\n        'keyword',\n        'decls'\n    ];\n    BindingStatement.create = function (keyword, decls) {\n        return new BindingStatement(keyword, decls);\n    };\n    inherit(Statement, BindingStatement, {\n        'isBindingStatement': true,\n        'destruct': function () {\n            return this.keyword.destruct().concat(_.reduce(this.decls, function (acc, decl) {\n                push.apply(acc, decl.destruct());\n                return acc;\n            }, []));\n        }\n    });\n    function VariableStatement(keyword, decls) {\n        this.keyword = keyword;\n        this.decls = decls;\n    }\n    VariableStatement.properties = [\n        'keyword',\n        'decls'\n    ];\n    VariableStatement.create = function (keyword, decls) {\n        return new VariableStatement(keyword, decls);\n    };\n    inherit(BindingStatement, VariableStatement, { 'isVariableStatement': true });\n    function LetStatement(keyword, decls) {\n        this.keyword = keyword;\n        this.decls = decls;\n    }\n    LetStatement.properties = [\n        'keyword',\n        'decls'\n    ];\n    LetStatement.create = function (keyword, decls) {\n        return new LetStatement(keyword, decls);\n    };\n    inherit(BindingStatement, LetStatement, { 'isLetStatement': true });\n    function ConstStatement(keyword, decls) {\n        this.keyword = keyword;\n        this.decls = decls;\n    }\n    ConstStatement.properties = [\n        'keyword',\n        'decls'\n    ];\n    ConstStatement.create = function (keyword, decls) {\n        return new ConstStatement(keyword, decls);\n    };\n    inherit(BindingStatement, ConstStatement, { 'isConstStatement': true });\n    function ParenExpression(args, delim, commas) {\n        this.args = args;\n        this.delim = delim;\n        this.commas = commas;\n    }\n    ParenExpression.properties = [\n        'args',\n        'delim',\n        'commas'\n    ];\n    ParenExpression.create = function (args, delim, commas) {\n        return new ParenExpression(args, delim, commas);\n    };\n    inherit(PrimaryExpression, ParenExpression, {\n        'isParenExpression': true,\n        'destruct': function () {\n            var commas = this.commas.slice();\n            var src = this.delim.token;\n            var keys = Object.keys(src);\n            var newtok = {};\n            for (var i = 0, len = keys.length, key; i < len; i++) {\n                key = keys[i];\n                newtok[key] = src[key];\n            }\n            var delim = syntaxFromToken(newtok, this.delim);\n            delim.token.inner = _.reduce(this.args, function (acc, term) {\n                assert(term && term.isTermTree, 'expecting term trees in destruct of ParenExpression');\n                push.apply(acc, term.destruct());\n                if (// add all commas except for the last one\n                    commas.length > 0) {\n                    acc.push(commas.shift());\n                }\n                return acc;\n            }, []);\n            return Delimiter.create(delim).destruct();\n        }\n    });\n    function stxIsUnaryOp(stx) {\n        var staticOperators = [\n            '+',\n            '-',\n            '~',\n            '!',\n            'delete',\n            'void',\n            'typeof',\n            'yield',\n            'new',\n            '++',\n            '--'\n        ];\n        return _.contains(staticOperators, unwrapSyntax(stx));\n    }\n    function stxIsBinOp(stx) {\n        var staticOperators = [\n            '+',\n            '-',\n            '*',\n            '/',\n            '%',\n            '||',\n            '&&',\n            '|',\n            '&',\n            '^',\n            '==',\n            '!=',\n            '===',\n            '!==',\n            '<',\n            '>',\n            '<=',\n            '>=',\n            'in',\n            'instanceof',\n            '<<',\n            '>>',\n            '>>>'\n        ];\n        return _.contains(staticOperators, unwrapSyntax(stx));\n    }\n    function getUnaryOpPrec(op) {\n        var operatorPrecedence = {\n            'new': 16,\n            '++': 15,\n            '--': 15,\n            '!': 14,\n            '~': 14,\n            '+': 14,\n            '-': 14,\n            'typeof': 14,\n            'void': 14,\n            'delete': 14,\n            'yield': 2\n        };\n        return operatorPrecedence[op];\n    }\n    function getBinaryOpPrec(op) {\n        var operatorPrecedence = {\n            '*': 13,\n            '/': 13,\n            '%': 13,\n            '+': 12,\n            '-': 12,\n            '>>': 11,\n            '<<': 11,\n            '>>>': 11,\n            '<': 10,\n            '<=': 10,\n            '>': 10,\n            '>=': 10,\n            'in': 10,\n            'instanceof': 10,\n            '==': 9,\n            '!=': 9,\n            '===': 9,\n            '!==': 9,\n            '&': 8,\n            '^': 7,\n            '|': 6,\n            '&&': 5,\n            '||': 4\n        };\n        return operatorPrecedence[op];\n    }\n    function getBinaryOpAssoc(op) {\n        var operatorAssoc = {\n            '*': 'left',\n            '/': 'left',\n            '%': 'left',\n            '+': 'left',\n            '-': 'left',\n            '>>': 'left',\n            '<<': 'left',\n            '>>>': 'left',\n            '<': 'left',\n            '<=': 'left',\n            '>': 'left',\n            '>=': 'left',\n            'in': 'left',\n            'instanceof': 'left',\n            '==': 'left',\n            '!=': 'left',\n            '===': 'left',\n            '!==': 'left',\n            '&': 'left',\n            '^': 'left',\n            '|': 'left',\n            '&&': 'left',\n            '||': 'left'\n        };\n        return operatorAssoc[op];\n    }\n    function stxIsAssignOp(stx) {\n        var staticOperators = [\n            '=',\n            '+=',\n            '-=',\n            '*=',\n            '/=',\n            '%=',\n            '<<=',\n            '>>=',\n            '>>>=',\n            '|=',\n            '^=',\n            '&='\n        ];\n        return _.contains(staticOperators, unwrapSyntax(stx));\n    }\n    function enforestVarStatement(stx, context, varStx) {\n        var decls = [];\n        var rest = stx;\n        var rhs;\n        if (!rest.length) {\n            throwSyntaxError('enforest', 'Unexpected end of input', varStx);\n        }\n        if (expandCount >= maxExpands) {\n            return null;\n        }\n        while (rest.length) {\n            if (rest[0].token.type === parser.Token.Identifier) {\n                if (rest[1] && rest[1].token.type === parser.Token.Punctuator && rest[1].token.value === '=') {\n                    rhs = get_expression(rest.slice(2), context);\n                    if (rhs.result == null) {\n                        throwSyntaxError('enforest', 'Unexpected token', rhs.rest[0]);\n                    }\n                    if (rhs.rest[0] && rhs.rest[0].token.type === parser.Token.Punctuator && rhs.rest[0].token.value === ',') {\n                        decls.push(VariableDeclaration.create(rest[0], rest[1], rhs.result, rhs.rest[0]));\n                        rest = rhs.rest.slice(1);\n                        continue;\n                    } else {\n                        decls.push(VariableDeclaration.create(rest[0], rest[1], rhs.result, null));\n                        rest = rhs.rest;\n                        break;\n                    }\n                } else if (rest[1] && rest[1].token.type === parser.Token.Punctuator && rest[1].token.value === ',') {\n                    decls.push(VariableDeclaration.create(rest[0], null, null, rest[1]));\n                    rest = rest.slice(2);\n                } else {\n                    decls.push(VariableDeclaration.create(rest[0], null, null, null));\n                    rest = rest.slice(1);\n                    break;\n                }\n            } else {\n                throwSyntaxError('enforest', 'Unexpected token', rest[0]);\n            }\n        }\n        return {\n            result: decls,\n            rest: rest\n        };\n    }\n    function enforestAssignment(stx, context, left, prevStx, prevTerms) {\n        var op = stx[0];\n        var rightStx = stx.slice(1);\n        var opTerm = Punc.create(stx[0]);\n        var opPrevStx = tagWithTerm(opTerm, [stx[0]]).concat(tagWithTerm(left, left.destruct().reverse()), prevStx);\n        var opPrevTerms = [\n            opTerm,\n            left\n        ].concat(prevTerms);\n        var opRes = enforest(rightStx, context, opPrevStx, opPrevTerms);\n        if (opRes.result) {\n            if (// Lookbehind was matched, so it may not even be a binop anymore.\n                opRes.prevTerms.length < opPrevTerms.length) {\n                return opRes;\n            }\n            var right = opRes.result;\n            if (// only a binop if the right is a real expression\n                // so 2+2++ will only match 2+2\n                right.isExpr) {\n                var term = AssignmentExpression.create(left, op, right);\n                return {\n                    result: term,\n                    rest: opRes.rest,\n                    prevStx: prevStx,\n                    prevTerms: prevTerms\n                };\n            }\n        } else {\n            return opRes;\n        }\n    }\n    function enforestParenExpression(parens, context) {\n        var argRes, enforestedArgs = [], commas = [];\n        var innerTokens = parens.expose().token.inner;\n        while (innerTokens.length > 0) {\n            argRes = enforest(innerTokens, context);\n            if (!argRes.result || !argRes.result.isExpr) {\n                return null;\n            }\n            enforestedArgs.push(argRes.result);\n            innerTokens = argRes.rest;\n            if (innerTokens[0] && innerTokens[0].token.value === ',') {\n                // record the comma for later\n                commas.push(innerTokens[0]);\n                // but dump it for the next loop turn\n                innerTokens = innerTokens.slice(1);\n            } else {\n                // either there are no more tokens or\n                // they aren't a comma, either way we\n                // are done with the loop\n                break;\n            }\n        }\n        return innerTokens.length ? null : ParenExpression.create(enforestedArgs, parens, commas);\n    }\n    function adjustLineContext(stx, original, current) {\n        if (// short circuit when the array is empty;\n            stx.length === 0) {\n            return stx;\n        }\n        current = current || {\n            lastLineNumber: stx[0].token.lineNumber || stx[0].token.startLineNumber,\n            lineNumber: original.token.lineNumber\n        };\n        return _.map(stx, function (stx$2) {\n            if (stx$2.token.type === parser.Token.Delimiter) {\n                // handle tokens with missing line info\n                stx$2.token.startLineNumber = typeof stx$2.token.startLineNumber == 'undefined' ? original.token.lineNumber : stx$2.token.startLineNumber;\n                stx$2.token.endLineNumber = typeof stx$2.token.endLineNumber == 'undefined' ? original.token.lineNumber : stx$2.token.endLineNumber;\n                stx$2.token.startLineStart = typeof stx$2.token.startLineStart == 'undefined' ? original.token.lineStart : stx$2.token.startLineStart;\n                stx$2.token.endLineStart = typeof stx$2.token.endLineStart == 'undefined' ? original.token.lineStart : stx$2.token.endLineStart;\n                stx$2.token.startRange = typeof stx$2.token.startRange == 'undefined' ? original.token.range : stx$2.token.startRange;\n                stx$2.token.endRange = typeof stx$2.token.endRange == 'undefined' ? original.token.range : stx$2.token.endRange;\n                stx$2.token.sm_startLineNumber = typeof stx$2.token.sm_startLineNumber == 'undefined' ? stx$2.token.startLineNumber : stx$2.token.sm_startLineNumber;\n                stx$2.token.sm_endLineNumber = typeof stx$2.token.sm_endLineNumber == 'undefined' ? stx$2.token.endLineNumber : stx$2.token.sm_endLineNumber;\n                stx$2.token.sm_startLineStart = typeof stx$2.token.sm_startLineStart == 'undefined' ? stx$2.token.startLineStart : stx$2.token.sm_startLineStart;\n                stx$2.token.sm_endLineStart = typeof stx$2.token.sm_endLineStart == 'undefined' ? stx$2.token.endLineStart : stx$2.token.sm_endLineStart;\n                stx$2.token.sm_startRange = typeof stx$2.token.sm_startRange == 'undefined' ? stx$2.token.startRange : stx$2.token.sm_startRange;\n                stx$2.token.sm_endRange = typeof stx$2.token.sm_endRange == 'undefined' ? stx$2.token.endRange : stx$2.token.sm_endRange;\n                if (stx$2.token.startLineNumber !== current.lineNumber) {\n                    if (stx$2.token.startLineNumber !== current.lastLineNumber) {\n                        current.lineNumber++;\n                        current.lastLineNumber = stx$2.token.startLineNumber;\n                        stx$2.token.startLineNumber = current.lineNumber;\n                    } else {\n                        current.lastLineNumber = stx$2.token.startLineNumber;\n                        stx$2.token.startLineNumber = current.lineNumber;\n                    }\n                }\n                return stx$2;\n            }\n            // handle tokens with missing line info\n            stx$2.token.lineNumber = typeof stx$2.token.lineNumber == 'undefined' ? original.token.lineNumber : stx$2.token.lineNumber;\n            stx$2.token.lineStart = typeof stx$2.token.lineStart == 'undefined' ? original.token.lineStart : stx$2.token.lineStart;\n            stx$2.token.range = typeof stx$2.token.range == 'undefined' ? original.token.range : stx$2.token.range;\n            // Only set the sourcemap line info once. Necessary because a single\n            // syntax object can go through expansion multiple times. If at some point\n            // we want to write an expansion stepper this might be a good place to store\n            // intermediate expansion line info (ie push to a stack instead of\n            // just write once).\n            stx$2.token.sm_lineNumber = typeof stx$2.token.sm_lineNumber == 'undefined' ? stx$2.token.lineNumber : stx$2.token.sm_lineNumber;\n            stx$2.token.sm_lineStart = typeof stx$2.token.sm_lineStart == 'undefined' ? stx$2.token.lineStart : stx$2.token.sm_lineStart;\n            stx$2.token.sm_range = typeof stx$2.token.sm_range == 'undefined' ? stx$2.token.range.slice() : stx$2.token.sm_range;\n            if (// move the line info to line up with the macro name\n                // (line info starting from the macro name)\n                stx$2.token.lineNumber !== current.lineNumber) {\n                if (stx$2.token.lineNumber !== current.lastLineNumber) {\n                    current.lineNumber++;\n                    current.lastLineNumber = stx$2.token.lineNumber;\n                    stx$2.token.lineNumber = current.lineNumber;\n                } else {\n                    current.lastLineNumber = stx$2.token.lineNumber;\n                    stx$2.token.lineNumber = current.lineNumber;\n                }\n            }\n            return stx$2;\n        });\n    }\n    function getName(head, rest) {\n        var idx = 0;\n        var curr = head;\n        var next = rest[idx];\n        var name = [head];\n        while (true) {\n            if (next && (next.token.type === parser.Token.Punctuator || next.token.type === parser.Token.Identifier || next.token.type === parser.Token.Keyword) && (curr.token.sm_range && next.token.sm_range && curr.token.sm_range[1] === next.token.sm_range[0] || curr.token.range[1] === next.token.range[0])) {\n                name.push(next);\n                curr = next;\n                next = rest[++idx];\n            } else {\n                return name;\n            }\n        }\n    }\n    function getMacroInEnv(head, rest, env) {\n        if (!(head.token.type === parser.Token.Identifier || head.token.type === parser.Token.Keyword || head.token.type === parser.Token.Punctuator)) {\n            return null;\n        }\n        var name = getName(head, rest);\n        if (// simple case, don't need to create a new syntax object\n            name.length === 1) {\n            if (env.names.get(unwrapSyntax(name[0]))) {\n                var resolvedName = resolve(name[0]);\n                if (env.has(resolvedName) && !env.get(resolvedName).varTransform) {\n                    return env.get(resolvedName);\n                }\n            }\n            return null;\n        } else {\n            while (name.length > 0) {\n                var nameStr = name.map(unwrapSyntax).join('');\n                if (env.names.get(nameStr)) {\n                    var nameStx = syn.makeIdent(nameStr, name[0]);\n                    var resolvedName = resolve(nameStx);\n                    if (env.has(resolvedName) && !env.get(resolvedName).varTransform) {\n                        return env.get(resolvedName);\n                    }\n                }\n                name.pop();\n            }\n            return null;\n        }\n    }\n    function nameInEnv(head, rest, env) {\n        return getMacroInEnv(head, rest, env) !== null;\n    }\n    function resolveFast(stx, env) {\n        var name = unwrapSyntax(stx);\n        return env.names.get(name) ? resolve(stx) : name;\n    }\n    function expandMacro(stx, context, opCtx, opType, macroObj) {\n        var // pull the macro transformer out the environment\n        head = stx[0];\n        var rest = stx.slice(1);\n        macroObj = macroObj || getMacroInEnv(head, rest, context.env);\n        var stxArg = rest.slice(macroObj.fullName.length - 1);\n        var transformer;\n        if (opType != null) {\n            assert(opType === 'binary' || opType === 'unary', 'operator type should be either unary or binary: ' + opType);\n            transformer = macroObj[opType].fn;\n        } else {\n            transformer = macroObj.fn;\n        }\n        assert(typeof transformer === 'function', 'Macro transformer not bound for: ' + head.token.value);\n        var // create a new mark to be used for the input to\n        // the macro\n        newMark = fresh();\n        var transformerContext = makeExpanderContext(_.defaults({ mark: newMark }, context));\n        // apply the transformer\n        var rt;\n        try {\n            rt = transformer([head].concat(stxArg), transformerContext, opCtx.prevStx, opCtx.prevTerms);\n        } catch (e) {\n            if (e instanceof SyntaxCaseError) {\n                var // add a nicer error for syntax case\n                nameStr = macroObj.fullName.map(function (stx$2) {\n                    return stx$2.token.value;\n                }).join('');\n                if (opType != null) {\n                    var argumentString = '`' + stxArg.slice(0, 5).map(function (stx$2) {\n                        return stx$2.token.value;\n                    }).join(' ') + '...`';\n                    throwSyntaxError('operator', 'Operator `' + nameStr + '` could not be matched with ' + argumentString, head);\n                } else {\n                    var argumentString = '`' + stxArg.slice(0, 5).map(function (stx$2) {\n                        return stx$2.token.value;\n                    }).join(' ') + '...`';\n                    throwSyntaxError('macro', 'Macro `' + nameStr + '` could not be matched with ' + argumentString, head);\n                }\n            } else {\n                // just rethrow it\n                throw e;\n            }\n        }\n        if (!builtinMode && !macroObj.builtin) {\n            expandCount++;\n        }\n        if (!Array.isArray(rt.result)) {\n            throwSyntaxError('enforest', 'Macro must return a syntax array', stx[0]);\n        }\n        if (rt.result.length > 0) {\n            var adjustedResult = adjustLineContext(rt.result, head);\n            if (stx[0].token.leadingComments) {\n                if (adjustedResult[0].token.leadingComments) {\n                    adjustedResult[0].token.leadingComments = adjustedResult[0].token.leadingComments.concat(head.token.leadingComments);\n                } else {\n                    adjustedResult[0].token.leadingComments = head.token.leadingComments;\n                }\n            }\n            rt.result = adjustedResult;\n        }\n        return rt;\n    }\n    function comparePrec(left, right, assoc) {\n        if (assoc === 'left') {\n            return left <= right;\n        }\n        return left < right;\n    }\n    function enforest(toks, context, prevStx, prevTerms) {\n        assert(toks.length > 0, 'enforest assumes there are tokens to work with');\n        prevStx = prevStx || [];\n        prevTerms = prevTerms || [];\n        if (expandCount >= maxExpands) {\n            return {\n                result: null,\n                rest: toks\n            };\n        }\n        function step(head, rest, opCtx) {\n            var innerTokens;\n            assert(Array.isArray(rest), 'result must at least be an empty array');\n            if (head.isTermTree) {\n                var isCustomOp = false;\n                var uopMacroObj;\n                var uopSyntax;\n                if (head.isPunc || head.isKeyword || head.isId) {\n                    if (head.isPunc) {\n                        uopSyntax = head.punc;\n                    } else if (head.isKeyword) {\n                        uopSyntax = head.keyword;\n                    } else if (head.isId) {\n                        uopSyntax = head.id;\n                    }\n                    uopMacroObj = getMacroInEnv(uopSyntax, rest, context.env);\n                    isCustomOp = uopMacroObj && uopMacroObj.isOp;\n                }\n                // look up once (we want to check multiple properties on bopMacroObj\n                // without repeatedly calling getMacroInEnv)\n                var bopMacroObj;\n                if (rest[0] && rest[1]) {\n                    bopMacroObj = getMacroInEnv(rest[0], rest.slice(1), context.env);\n                }\n                if (// unary operator\n                    isCustomOp && uopMacroObj.unary || uopSyntax && stxIsUnaryOp(uopSyntax)) {\n                    var uopPrec;\n                    if (isCustomOp && uopMacroObj.unary) {\n                        uopPrec = uopMacroObj.unary.prec;\n                    } else {\n                        uopPrec = getUnaryOpPrec(unwrapSyntax(uopSyntax));\n                    }\n                    var opRest = rest;\n                    var uopMacroName;\n                    if (uopMacroObj) {\n                        uopMacroName = [uopSyntax].concat(rest.slice(0, uopMacroObj.fullName.length - 1));\n                        opRest = rest.slice(uopMacroObj.fullName.length - 1);\n                    } else if (unwrapSyntax(uopSyntax) === 'yield' && unwrapSyntax(opRest[0]) === '*') {\n                        uopSyntax = [\n                            uopSyntax,\n                            opRest[0]\n                        ];\n                        opRest = opRest.slice(1);\n                    }\n                    var leftLeft = opCtx.prevTerms[0] && opCtx.prevTerms[0].isPartial ? opCtx.prevTerms[0] : null;\n                    var unopTerm = PartialOperation.create(head, leftLeft);\n                    var unopPrevStx = tagWithTerm(unopTerm, head.destruct().reverse()).concat(opCtx.prevStx);\n                    var unopPrevTerms = [unopTerm].concat(opCtx.prevTerms);\n                    var unopOpCtx = _.extend({}, opCtx, {\n                        combine: function (t) {\n                            if (t.isExpr) {\n                                if (isCustomOp && uopMacroObj.unary) {\n                                    var rt$2 = expandMacro(uopMacroName.concat(t.destruct()), context, opCtx, 'unary');\n                                    var newt = get_expression(rt$2.result, context);\n                                    assert(newt.rest.length === 0, 'should never have left over syntax');\n                                    return opCtx.combine(newt.result);\n                                }\n                                return opCtx.combine(UnaryOp.create(uopSyntax, t));\n                            } else {\n                                // not actually an expression so don't create\n                                // a UnaryOp term just return with the punctuator\n                                return opCtx.combine(head);\n                            }\n                        },\n                        prec: uopPrec,\n                        prevStx: unopPrevStx,\n                        prevTerms: unopPrevTerms,\n                        op: unopTerm\n                    });\n                    return step(opRest[0], opRest.slice(1), unopOpCtx);\n                } else if (head.isExpr && (rest[0] && rest[1] && (stxIsBinOp(rest[0]) && !bopMacroObj || bopMacroObj && bopMacroObj.isOp && bopMacroObj.binary))) {\n                    var opRes;\n                    var op = rest[0];\n                    var left = head;\n                    var rightStx = rest.slice(1);\n                    var leftLeft = opCtx.prevTerms[0] && opCtx.prevTerms[0].isPartial ? opCtx.prevTerms[0] : null;\n                    var leftTerm = PartialExpression.create(head.destruct(), leftLeft, function () {\n                        return step(head, [], opCtx);\n                    });\n                    var opTerm = PartialOperation.create(op, leftTerm);\n                    var opPrevStx = tagWithTerm(opTerm, [rest[0]]).concat(tagWithTerm(leftTerm, head.destruct()).reverse(), opCtx.prevStx);\n                    var opPrevTerms = [\n                        opTerm,\n                        leftTerm\n                    ].concat(opCtx.prevTerms);\n                    var isCustomOp = bopMacroObj && bopMacroObj.isOp && bopMacroObj.binary;\n                    var bopPrec;\n                    var bopAssoc;\n                    if (isCustomOp && bopMacroObj.binary) {\n                        bopPrec = bopMacroObj.binary.prec;\n                        bopAssoc = bopMacroObj.binary.assoc;\n                    } else {\n                        bopPrec = getBinaryOpPrec(unwrapSyntax(op));\n                        bopAssoc = getBinaryOpAssoc(unwrapSyntax(op));\n                    }\n                    assert(bopPrec !== undefined, 'expecting a precedence for operator: ' + op);\n                    var newStack;\n                    if (comparePrec(bopPrec, opCtx.prec, bopAssoc)) {\n                        var bopCtx = opCtx;\n                        var combResult = opCtx.combine(head);\n                        if (opCtx.stack.length > 0) {\n                            return step(combResult.term, rest, opCtx.stack[0]);\n                        }\n                        left = combResult.term;\n                        newStack = opCtx.stack;\n                        opPrevStx = combResult.prevStx;\n                        opPrevTerms = combResult.prevTerms;\n                    } else {\n                        newStack = [opCtx].concat(opCtx.stack);\n                    }\n                    assert(opCtx.combine !== undefined, 'expecting a combine function');\n                    var opRightStx = rightStx;\n                    var bopMacroName;\n                    if (isCustomOp) {\n                        bopMacroName = rest.slice(0, bopMacroObj.fullName.length);\n                        opRightStx = rightStx.slice(bopMacroObj.fullName.length - 1);\n                    }\n                    var bopOpCtx = _.extend({}, opCtx, {\n                        combine: function (right) {\n                            if (right.isExpr) {\n                                if (isCustomOp && bopMacroObj.binary) {\n                                    var leftStx = left.destruct();\n                                    var rightStx$2 = right.destruct();\n                                    var rt$2 = expandMacro(bopMacroName.concat(syn.makeDelim('()', leftStx, leftStx[0]), syn.makeDelim('()', rightStx$2, rightStx$2[0])), context, opCtx, 'binary');\n                                    var newt = get_expression(rt$2.result, context);\n                                    assert(newt.rest.length === 0, 'should never have left over syntax');\n                                    return {\n                                        term: newt.result,\n                                        prevStx: opPrevStx,\n                                        prevTerms: opPrevTerms\n                                    };\n                                }\n                                return {\n                                    term: BinOp.create(left, op, right),\n                                    prevStx: opPrevStx,\n                                    prevTerms: opPrevTerms\n                                };\n                            } else {\n                                return {\n                                    term: head,\n                                    prevStx: opPrevStx,\n                                    prevTerms: opPrevTerms\n                                };\n                            }\n                        },\n                        prec: bopPrec,\n                        op: opTerm,\n                        stack: newStack,\n                        prevStx: opPrevStx,\n                        prevTerms: opPrevTerms\n                    });\n                    return step(opRightStx[0], opRightStx.slice(1), bopOpCtx);\n                } else if (head.isExpr && (rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()')) {\n                    var parenRes = enforestParenExpression(rest[0], context);\n                    if (parenRes) {\n                        return step(Call.create(head, parenRes), rest.slice(1), opCtx);\n                    }\n                } else if (head.isExpr && (rest[0] && resolveFast(rest[0], context.env) === '?')) {\n                    var question = rest[0];\n                    var condRes = enforest(rest.slice(1), context);\n                    if (condRes.result) {\n                        var truExpr = condRes.result;\n                        var condRight = condRes.rest;\n                        if (truExpr.isExpr && condRight[0] && resolveFast(condRight[0], context.env) === ':') {\n                            var colon = condRight[0];\n                            var flsRes = enforest(condRight.slice(1), context);\n                            var flsExpr = flsRes.result;\n                            if (flsExpr.isExpr) {\n                                if (// operators are combined before the ternary\n                                    opCtx.prec >= 4) {\n                                    var // ternary is like a operator with prec 4\n                                    headResult = opCtx.combine(head);\n                                    var condTerm = ConditionalExpression.create(headResult.term, question, truExpr, colon, flsExpr);\n                                    if (opCtx.stack.length > 0) {\n                                        return step(condTerm, flsRes.rest, opCtx.stack[0]);\n                                    } else {\n                                        return {\n                                            result: condTerm,\n                                            rest: flsRes.rest,\n                                            prevStx: headResult.prevStx,\n                                            prevTerms: headResult.prevTerms\n                                        };\n                                    }\n                                } else {\n                                    var condTerm = ConditionalExpression.create(head, question, truExpr, colon, flsExpr);\n                                    return step(condTerm, flsRes.rest, opCtx);\n                                }\n                            }\n                        }\n                    }\n                } else if (head.isDelimiter && head.delim.token.value === '()' && rest[0] && rest[0].token.type === parser.Token.Punctuator && resolveFast(rest[0], context.env) === '=>') {\n                    var arrowRes = enforest(rest.slice(1), context);\n                    if (arrowRes.result && arrowRes.result.isExpr) {\n                        return step(ArrowFun.create(head.delim, rest[0], arrowRes.result.destruct()), arrowRes.rest, opCtx);\n                    } else {\n                        throwSyntaxError('enforest', 'Body of arrow function must be an expression', rest.slice(1));\n                    }\n                } else if (head.isId && rest[0] && rest[0].token.type === parser.Token.Punctuator && resolveFast(rest[0], context.env) === '=>') {\n                    var res = enforest(rest.slice(1), context);\n                    if (res.result && res.result.isExpr) {\n                        return step(ArrowFun.create(head.id, rest[0], res.result.destruct()), res.rest, opCtx);\n                    } else {\n                        throwSyntaxError('enforest', 'Body of arrow function must be an expression', rest.slice(1));\n                    }\n                } else if (head.isDelimiter && head.delim.token.value === '()') {\n                    if (// empty parens are acceptable but enforest\n                        // doesn't accept empty arrays so short\n                        // circuit here\n                        head.delim.token.inner.length === 0) {\n                        return step(ParenExpression.create([Empty.create()], head.delim.expose(), []), rest, opCtx);\n                    } else {\n                        var parenRes = enforestParenExpression(head.delim, context);\n                        if (parenRes) {\n                            return step(parenRes, rest, opCtx);\n                        }\n                    }\n                } else if (head.isExpr && ((head.isId || head.isObjGet || head.isObjDotGet || head.isThisExpression) && rest[0] && rest[1] && !bopMacroObj && opCtx.op === null && stxIsAssignOp(rest[0]))) {\n                    var opRes = enforestAssignment(rest, context, head, prevStx, prevTerms);\n                    if (opRes && opRes.result) {\n                        return step(opRes.result, opRes.rest, _.extend({}, opCtx, {\n                            prevStx: opRes.prevStx,\n                            prevTerms: opRes.prevTerms\n                        }));\n                    }\n                } else if (head.isExpr && (rest[0] && (unwrapSyntax(rest[0]) === '++' || unwrapSyntax(rest[0]) === '--'))) {\n                    if (// Check if the operator is a macro first.\n                        context.env.has(resolveFast(rest[0], context.env))) {\n                        var headStx = tagWithTerm(head, head.destruct().reverse());\n                        var opPrevStx = headStx.concat(prevStx);\n                        var opPrevTerms = [head].concat(prevTerms);\n                        var opRes = enforest(rest, context, opPrevStx, opPrevTerms);\n                        if (opRes.prevTerms.length < opPrevTerms.length) {\n                            return opRes;\n                        } else if (opRes.result) {\n                            return step(head, opRes.result.destruct().concat(opRes.rest), opCtx);\n                        }\n                    }\n                    return step(PostfixOp.create(head, rest[0]), rest.slice(1), opCtx);\n                } else if (head.isExpr && (rest[0] && rest[0].token.value === '[]')) {\n                    return step(ObjGet.create(head, Delimiter.create(rest[0].expose())), rest.slice(1), opCtx);\n                } else if (head.isExpr && (rest[0] && unwrapSyntax(rest[0]) === '.' && !context.env.has(resolveFast(rest[0], context.env)) && rest[1] && (rest[1].token.type === parser.Token.Identifier || rest[1].token.type === parser.Token.Keyword))) {\n                    if (// Check if the identifier is a macro first.\n                        context.env.has(resolveFast(rest[1], context.env)) && nameInEnv(rest[1], [], context.env)) {\n                        var headStx = tagWithTerm(head, head.destruct().reverse());\n                        var dotTerm = Punc.create(rest[0]);\n                        var dotTerms = [dotTerm].concat(head, prevTerms);\n                        var dotStx = tagWithTerm(dotTerm, [rest[0]]).concat(headStx, prevStx);\n                        var dotRes = enforest(rest.slice(1), context, dotStx, dotTerms);\n                        if (dotRes.prevTerms.length < dotTerms.length) {\n                            return dotRes;\n                        } else if (dotRes.result) {\n                            return step(head, [rest[0]].concat(dotRes.result.destruct(), dotRes.rest), opCtx);\n                        }\n                    }\n                    return step(ObjDotGet.create(head, rest[0], rest[1]), rest.slice(2), opCtx);\n                } else if (head.isDelimiter && head.delim.token.value === '[]') {\n                    return step(ArrayLiteral.create(head), rest, opCtx);\n                } else if (head.isDelimiter && head.delim.token.value === '{}') {\n                    return step(Block.create(head), rest, opCtx);\n                } else if (head.isId && unwrapSyntax(head.id) === '#quoteSyntax' && rest[0] && rest[0].token.value === '{}') {\n                    var tempId = fresh();\n                    context.templateMap.set(tempId, rest[0].token.inner);\n                    return step(syn.makeIdent('getTemplate', head.id), [syn.makeDelim('()', [syn.makeValue(tempId, head.id)], head.id)].concat(rest.slice(1)), opCtx);\n                } else if (head.isKeyword && unwrapSyntax(head.keyword) === 'return') {\n                    if (rest[0] && rest[0].token.lineNumber === head.keyword.token.lineNumber) {\n                        var returnPrevStx = tagWithTerm(head, head.destruct()).concat(opCtx.prevStx);\n                        var returnPrevTerms = [head].concat(opCtx.prevTerms);\n                        var returnExpr = enforest(rest, context, returnPrevStx, returnPrevTerms);\n                        if (returnExpr.prevTerms.length < opCtx.prevTerms.length) {\n                            return returnExpr;\n                        }\n                        if (returnExpr.result.isExpr) {\n                            return step(ReturnStatement.create(head, returnExpr.result), returnExpr.rest, opCtx);\n                        }\n                    } else {\n                        return step(ReturnStatement.create(head, Empty.create()), rest, opCtx);\n                    }\n                } else if (head.isKeyword && unwrapSyntax(head.keyword) === 'let') {\n                    var nameTokens = [];\n                    if (rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()') {\n                        nameTokens = rest[0].token.inner;\n                    } else {\n                        nameTokens.push(rest[0]);\n                    }\n                    if (// Let macro\n                        rest[1] && rest[1].token.value === '=' && rest[2] && rest[2].token.value === 'macro') {\n                        var mac = enforest(rest.slice(2), context);\n                        if (mac.result) {\n                            if (!mac.result.isAnonMacro) {\n                                throwSyntaxError('enforest', 'expecting an anonymous macro definition in syntax let binding', rest.slice(2));\n                            }\n                            return step(LetMacro.create(nameTokens, mac.result.body), mac.rest, opCtx);\n                        }\n                    } else {\n                        var lsRes = enforestVarStatement(rest, context, head.keyword);\n                        if (lsRes && lsRes.result) {\n                            return step(LetStatement.create(head, lsRes.result), lsRes.rest, opCtx);\n                        }\n                    }\n                } else if (head.isKeyword && unwrapSyntax(head.keyword) === 'var' && rest[0]) {\n                    var vsRes = enforestVarStatement(rest, context, head.keyword);\n                    if (vsRes && vsRes.result) {\n                        return step(VariableStatement.create(head, vsRes.result), vsRes.rest, opCtx);\n                    }\n                } else if (head.isKeyword && unwrapSyntax(head.keyword) === 'const' && rest[0]) {\n                    var csRes = enforestVarStatement(rest, context, head.keyword);\n                    if (csRes && csRes.result) {\n                        return step(ConstStatement.create(head, csRes.result), csRes.rest, opCtx);\n                    }\n                } else if (head.isKeyword && unwrapSyntax(head.keyword) === 'for' && rest[0] && rest[0].token.value === '()') {\n                    return step(ForStatement.create(head.keyword, rest[0]), rest.slice(1), opCtx);\n                }\n            } else {\n                assert(head && head.token, 'assuming head is a syntax object');\n                var macroObj = expandCount < maxExpands && getMacroInEnv(head, rest, context.env);\n                if (// macro invocation\n                    macroObj && !macroObj.isOp) {\n                    var rt = expandMacro([head].concat(rest), context, opCtx, null, macroObj);\n                    var newOpCtx = opCtx;\n                    if (rt.prevTerms && rt.prevTerms.length < opCtx.prevTerms.length) {\n                        newOpCtx = rewindOpCtx(opCtx, rt);\n                    }\n                    if (rt.result.length > 0) {\n                        return step(rt.result[0], rt.result.slice(1).concat(rt.rest), newOpCtx);\n                    } else {\n                        return step(Empty.create(), rt.rest, newOpCtx);\n                    }\n                } else if (head.token.type === parser.Token.Identifier && resolve(head) === 'macro' && rest[0] && rest[0].token.value === '{}') {\n                    return step(AnonMacro.create(rest[0].expose().token.inner), rest.slice(1), opCtx);\n                } else if (head.token.type === parser.Token.Identifier && resolve(head) === 'macro') {\n                    var nameTokens = [];\n                    if (rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()') {\n                        nameTokens = rest[0].expose().token.inner;\n                    } else {\n                        nameTokens.push(rest[0]);\n                    }\n                    if (rest[1] && rest[1].token.type === parser.Token.Delimiter) {\n                        return step(Macro.create(nameTokens, rest[1].expose().token.inner), rest.slice(2), opCtx);\n                    } else {\n                        throwSyntaxError('enforest', 'Macro declaration must include body', rest[1]);\n                    }\n                } else if (head.token.type === parser.Token.Identifier && head.token.value === 'unaryop' && rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()' && rest[1] && rest[1].token.type === parser.Token.NumericLiteral && rest[2] && rest[2].token.type === parser.Token.Delimiter && rest[2] && rest[2].token.value === '{}') {\n                    var trans = enforest(rest[2].expose().token.inner, context);\n                    return step(OperatorDefinition.create('unary', rest[0].expose().token.inner, rest[1], null, trans.result.body), rest.slice(3), opCtx);\n                } else if (head.token.type === parser.Token.Identifier && head.token.value === 'binaryop' && rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()' && rest[1] && rest[1].token.type === parser.Token.NumericLiteral && rest[2] && rest[2].token.type === parser.Token.Identifier && rest[3] && rest[3].token.type === parser.Token.Delimiter && rest[3] && rest[3].token.value === '{}') {\n                    var trans = enforest(rest[3].expose().token.inner, context);\n                    return step(OperatorDefinition.create('binary', rest[0].expose().token.inner, rest[1], rest[2], trans.result.body), rest.slice(4), opCtx);\n                } else if (unwrapSyntax(head) === 'module' && rest[0] && rest[0].token.value === '{}') {\n                    return step(Module.create(rest[0], []), rest.slice(1), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'function' && rest[0] && rest[0].token.type === parser.Token.Identifier && rest[1] && rest[1].token.type === parser.Token.Delimiter && rest[1].token.value === '()' && rest[2] && rest[2].token.type === parser.Token.Delimiter && rest[2].token.value === '{}') {\n                    rest[1].token.inner = rest[1].expose().token.inner;\n                    rest[2].token.inner = rest[2].expose().token.inner;\n                    return step(NamedFun.create(head, null, rest[0], rest[1], rest[2]), rest.slice(3), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'function' && rest[0] && rest[0].token.type === parser.Token.Punctuator && rest[0].token.value === '*' && rest[1] && rest[1].token.type === parser.Token.Identifier && rest[2] && rest[2].token.type === parser.Token.Delimiter && rest[2].token.value === '()' && rest[3] && rest[3].token.type === parser.Token.Delimiter && rest[3].token.value === '{}') {\n                    rest[2].token.inner = rest[2].expose().token.inner;\n                    rest[3].token.inner = rest[3].expose().token.inner;\n                    return step(NamedFun.create(head, rest[0], rest[1], rest[2], rest[3]), rest.slice(4), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'function' && rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()' && rest[1] && rest[1].token.type === parser.Token.Delimiter && rest[1].token.value === '{}') {\n                    rest[0].token.inner = rest[0].expose().token.inner;\n                    rest[1].token.inner = rest[1].expose().token.inner;\n                    return step(AnonFun.create(head, null, rest[0], rest[1]), rest.slice(2), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'function' && rest[0] && rest[0].token.type === parser.Token.Punctuator && rest[0].token.value === '*' && rest[1] && rest[1].token.type === parser.Token.Delimiter && rest[1].token.value === '()' && rest[2] && rest[2].token.type === parser.Token.Delimiter && rest[2].token.value === '{}') {\n                    rest[1].token.inner = rest[1].expose().token.inner;\n                    rest[2].token.inner = rest[2].expose().token.inner;\n                    return step(AnonFun.create(head, rest[0], rest[1], rest[2]), rest.slice(3), opCtx);\n                } else if ((head.token.type === parser.Token.Delimiter && head.token.value === '()' || head.token.type === parser.Token.Identifier) && rest[0] && rest[0].token.type === parser.Token.Punctuator && resolveFast(rest[0], context.env) === '=>' && rest[1] && rest[1].token.type === parser.Token.Delimiter && rest[1].token.value === '{}') {\n                    return step(ArrowFun.create(head, rest[0], rest[1]), rest.slice(2), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'catch' && rest[0] && rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()' && rest[1] && rest[1].token.type === parser.Token.Delimiter && rest[1].token.value === '{}') {\n                    rest[0].token.inner = rest[0].expose().token.inner;\n                    rest[1].token.inner = rest[1].expose().token.inner;\n                    return step(CatchClause.create(head, rest[0], rest[1]), rest.slice(2), opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'this') {\n                    return step(ThisExpression.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.NumericLiteral || head.token.type === parser.Token.StringLiteral || head.token.type === parser.Token.BooleanLiteral || head.token.type === parser.Token.RegularExpression || head.token.type === parser.Token.NullLiteral) {\n                    return step(Lit.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'export' && rest[0] && (rest[0].token.type === parser.Token.Identifier || rest[0].token.type === parser.Token.Keyword || rest[0].token.type === parser.Token.Punctuator || rest[0].token.type === parser.Token.Delimiter && rest[0].token.value === '()')) {\n                    if (// Consume optional semicolon\n                        unwrapSyntax(rest[1]) === ';') {\n                        rest.splice(1, 1);\n                    }\n                    return step(Export.create(rest[0]), rest.slice(1), opCtx);\n                } else if (head.token.type === parser.Token.Identifier) {\n                    return step(Id.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.Punctuator) {\n                    return step(Punc.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.Keyword && unwrapSyntax(head) === 'with') {\n                    throwSyntaxError('enforest', 'with is not supported in sweet.js', head);\n                } else if (head.token.type === parser.Token.Keyword) {\n                    return step(Keyword.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.Delimiter) {\n                    return step(Delimiter.create(head.expose()), rest, opCtx);\n                } else if (head.token.type === parser.Token.Template) {\n                    return step(Template.create(head), rest, opCtx);\n                } else if (head.token.type === parser.Token.EOF) {\n                    assert(rest.length === 0, 'nothing should be after an EOF');\n                    return step(EOF.create(head), [], opCtx);\n                } else {\n                    // todo: are we missing cases?\n                    assert(false, 'not implemented');\n                }\n            }\n            if (// Potentially an infix macro\n                // This should only be invoked on runtime syntax terms\n                !head.isMacro && !head.isLetMacro && !head.isAnonMacro && !head.isOperatorDefinition && rest.length && nameInEnv(rest[0], rest.slice(1), context.env) && getMacroInEnv(rest[0], rest.slice(1), context.env).isOp === false) {\n                var infLeftTerm = opCtx.prevTerms[0] && opCtx.prevTerms[0].isPartial ? opCtx.prevTerms[0] : null;\n                var infTerm = PartialExpression.create(head.destruct(), infLeftTerm, function () {\n                    return step(head, [], opCtx);\n                });\n                var infPrevStx = tagWithTerm(infTerm, head.destruct()).reverse().concat(opCtx.prevStx);\n                var infPrevTerms = [infTerm].concat(opCtx.prevTerms);\n                var infRes = expandMacro(rest, context, {\n                    prevStx: infPrevStx,\n                    prevTerms: infPrevTerms\n                });\n                if (infRes.prevTerms && infRes.prevTerms.length < infPrevTerms.length) {\n                    var infOpCtx = rewindOpCtx(opCtx, infRes);\n                    return step(infRes.result[0], infRes.result.slice(1).concat(infRes.rest), infOpCtx);\n                } else {\n                    return step(head, infRes.result.concat(infRes.rest), opCtx);\n                }\n            }\n            var // done with current step so combine and continue on\n            combResult = opCtx.combine(head);\n            if (opCtx.stack.length === 0) {\n                return {\n                    result: combResult.term,\n                    rest: rest,\n                    prevStx: combResult.prevStx,\n                    prevTerms: combResult.prevTerms\n                };\n            } else {\n                return step(combResult.term, rest, opCtx.stack[0]);\n            }\n        }\n        return step(toks[0], toks.slice(1), {\n            combine: function (t) {\n                return {\n                    term: t,\n                    prevStx: prevStx,\n                    prevTerms: prevTerms\n                };\n            },\n            prec: 0,\n            stack: [],\n            op: null,\n            prevStx: prevStx,\n            prevTerms: prevTerms\n        });\n    }\n    function rewindOpCtx(opCtx, res) {\n        if (// If we've consumed all pending operators, we can just start over.\n            // It's important that we always thread the new prevStx and prevTerms\n            // through, otherwise the old ones will still persist.\n            !res.prevTerms.length || !res.prevTerms[0].isPartial) {\n            return _.extend({}, opCtx, {\n                combine: function (t) {\n                    return {\n                        term: t,\n                        prevStx: res.prevStx,\n                        prevTerms: res.prevTerms\n                    };\n                },\n                prec: 0,\n                op: null,\n                stack: [],\n                prevStx: res.prevStx,\n                prevTerms: res.prevTerms\n            });\n        }\n        // To rewind, we need to find the first (previous) pending operator. It\n        // acts as a marker in the opCtx to let us know how far we need to go\n        // back.\n        var op = null;\n        for (var i = 0; i < res.prevTerms.length; i++) {\n            if (!res.prevTerms[i].isPartial) {\n                break;\n            }\n            if (res.prevTerms[i].isPartialOperation) {\n                op = res.prevTerms[i];\n                break;\n            }\n        }\n        if (// If the op matches the current opCtx, we don't need to rewind\n            // anything, but we still need to persist the prevStx and prevTerms.\n            opCtx.op === op) {\n            return _.extend({}, opCtx, {\n                prevStx: res.prevStx,\n                prevTerms: res.prevTerms\n            });\n        }\n        for (var i = 0; i < opCtx.stack.length; i++) {\n            if (opCtx.stack[i].op === op) {\n                return _.extend({}, opCtx.stack[i], {\n                    prevStx: res.prevStx,\n                    prevTerms: res.prevTerms\n                });\n            }\n        }\n        assert(false, 'Rewind failed.');\n    }\n    function get_expression(stx, context) {\n        if (stx[0].term) {\n            for (var termLen = 1; termLen < stx.length; termLen++) {\n                if (stx[termLen].term !== stx[0].term) {\n                    break;\n                }\n            }\n            if (// Guard the termLen because we can have a multi-token term that\n                // we don't want to split. TODO: is there something we can do to\n                // get around this safely?\n                stx[0].term.isPartialExpression && termLen === stx[0].term.stx.length) {\n                var expr = stx[0].term.combine().result;\n                for (var i = 1, term = stx[0].term; i < stx.length; i++) {\n                    if (stx[i].term !== term) {\n                        if (term && term.isPartial) {\n                            term = term.left;\n                            i--;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                return {\n                    result: expr,\n                    rest: stx.slice(i)\n                };\n            } else if (stx[0].term.isExpr) {\n                return {\n                    result: stx[0].term,\n                    rest: stx.slice(termLen)\n                };\n            } else {\n                return {\n                    result: null,\n                    rest: stx\n                };\n            }\n        }\n        var res = enforest(stx, context);\n        if (!res.result || !res.result.isExpr) {\n            return {\n                result: null,\n                rest: stx\n            };\n        }\n        return res;\n    }\n    function tagWithTerm(term, stx) {\n        return stx.map(function (s) {\n            var src = s.token;\n            var keys = Object.keys(src);\n            var newtok = {};\n            for (var i = 0, len = keys.length, key; i < len; i++) {\n                key = keys[i];\n                newtok[key] = src[key];\n            }\n            s = syntaxFromToken(newtok, s);\n            s.term = term;\n            return s;\n        });\n    }\n    function applyMarkToPatternEnv(newMark, env) {\n        function dfs(match) {\n            if (match.level === 0) {\n                // replace the match property with the marked syntax\n                match.match = _.map(match.match, function (stx) {\n                    return stx.mark(newMark);\n                });\n            } else {\n                _.each(match.match, function (match$2) {\n                    dfs(match$2);\n                });\n            }\n        }\n        _.keys(env).forEach(function (key) {\n            dfs(env[key]);\n        });\n    }\n    function markIn(arr, mark) {\n        return arr.map(function (stx) {\n            return stx.mark(mark);\n        });\n    }\n    function markDefOut(arr, mark, def) {\n        return arr.map(function (stx) {\n            return stx.mark(mark).addDefCtx(def);\n        });\n    }\n    function loadMacroDef(def, context, rest) {\n        var body = def.body;\n        if (!(// raw function primitive form\n            body[0] && body[0].token.type === parser.Token.Keyword && body[0].token.value === 'function')) {\n            throwSyntaxError('load macro', 'Primitive macro form must contain a function for the macro body', body);\n        }\n        var stub = parser.read('()');\n        stub[0].token.inner = body;\n        var expanded = expand(stub, context);\n        expanded = expanded[0].destruct().concat(expanded[1].eof);\n        var flattend = flatten(expanded);\n        var bodyCode = codegen.generate(parser.parse(flattend));\n        var localCtx, matchedTokens;\n        var macroFn = scopedEval(bodyCode, {\n            makeValue: syn.makeValue,\n            makeRegex: syn.makeRegex,\n            makeIdent: syn.makeIdent,\n            makeKeyword: syn.makeKeyword,\n            makePunc: syn.makePunc,\n            makeDelim: syn.makeDelim,\n            filename: context.filename,\n            require: function (id) {\n                if (context.requireModule) {\n                    return context.requireModule(id, context.filename);\n                }\n                return __webpack_require__(36)(id);\n            },\n            localExpand: function (stx, stop) {\n                assert(!stop || stop.length === 0, 'localExpand stop lists are not currently supported');\n                var markedStx = markIn(stx, localCtx.mark);\n                var terms = expand(markedStx, localCtx);\n                var newStx = terms.reduce(function (acc, term) {\n                    acc.push.apply(acc, term.destruct());\n                    return acc;\n                }, []);\n                return markDefOut(newStx, localCtx.mark, localCtx.defscope);\n            },\n            getExpr: function (stx) {\n                if (stx.length === 0) {\n                    return {\n                        success: false,\n                        result: [],\n                        rest: []\n                    };\n                }\n                var markedStx = markIn(stx, localCtx.mark);\n                var r = get_expression(markedStx, localCtx);\n                return {\n                    success: r.result !== null,\n                    result: r.result === null ? [] : markDefOut(r.result.destruct(), localCtx.mark, localCtx.defscope),\n                    rest: markDefOut(r.rest, localCtx.mark, localCtx.defscope)\n                };\n            },\n            getIdent: function (stx) {\n                if (stx[0] && stx[0].token.type === parser.Token.Identifier) {\n                    return {\n                        success: true,\n                        result: [stx[0]],\n                        rest: stx.slice(1)\n                    };\n                }\n                return {\n                    success: false,\n                    result: [],\n                    rest: stx\n                };\n            },\n            getLit: function (stx) {\n                if (stx[0] && patternModule.typeIsLiteral(stx[0].token.type)) {\n                    return {\n                        success: true,\n                        result: [stx[0]],\n                        rest: stx.slice(1)\n                    };\n                }\n                return {\n                    success: false,\n                    result: [],\n                    rest: stx\n                };\n            },\n            matchPatterns: function (syntax, topLevel, reverse) {\n                function flatMap(input, selector) {\n                    var output = [], outputCount = 0, index$2 = -1, count$2 = input.length, elem, index2, count2;\n                    while (++index$2 < count$2) {\n                        elem = selector(input[index$2], index$2, input);\n                        index2 = -1;\n                        count2 = elem.length;\n                        while (++index2 < count2) {\n                            output[outputCount++] = elem[index2];\n                        }\n                    }\n                    return output;\n                }\n                var patterns = Array.prototype.slice.call(arguments, 1 + // 1 if topLevel is boolean, else 0\n                Number(typeof topLevel !== 'boolean' === false) + // 1 if reverse is boolean, else 0\n                Number(typeof reverse !== 'boolean' === false));\n                // Default topLevel to true\n                topLevel = topLevel === false ? false : true;\n                // Default reverse to false\n                reverse = reverse === true || false;\n                patterns = flatMap(patterns, function flatten$2(pattern$2) {\n                    if (Array.isArray(pattern$2)) {\n                        if (Array.isArray(pattern$2[0])) {\n                            return flatMap(pattern$2, flatten$2);\n                        }\n                        return [pattern$2];\n                    }\n                    return pattern$2;\n                }).map(function (pattern$2) {\n                    return patternModule.loadPattern(pattern$2, reverse);\n                });\n                var result, pattern, index = -1, count = patterns.length;\n                while (++index < count) {\n                    result = patternModule.matchPatterns(patterns[index], syntax, localCtx, topLevel);\n                    if (result.success) {\n                        return result;\n                    }\n                }\n                return {\n                    success: false,\n                    result: [],\n                    rest: [],\n                    patternEnv: {}\n                };\n            },\n            unwrapSyntax: syn.unwrapSyntax,\n            throwSyntaxError: throwSyntaxError,\n            throwSyntaxCaseError: throwSyntaxCaseError,\n            prettyPrint: syn.prettyPrint,\n            parser: parser,\n            __fresh: fresh,\n            _: _,\n            patternModule: patternModule,\n            getPattern: function (id) {\n                return context.patternMap.get(id);\n            },\n            getTemplate: function (id) {\n                return syn.cloneSyntaxArray(context.templateMap.get(id));\n            },\n            applyMarkToPatternEnv: applyMarkToPatternEnv,\n            mergeMatches: function (newMatch, oldMatch) {\n                newMatch.patternEnv = _.extend({}, oldMatch.patternEnv, newMatch.patternEnv);\n                return newMatch;\n            }\n        });\n        if (context.log) {\n            context.log.push({\n                name: def.name[0].token,\n                matchedTokens: matchedTokens = [],\n                next: rest[0] && rest[0].token || undefined\n            });\n        }\n        return function (stx, context$2, prevStx, prevTerms) {\n            localCtx = context$2;\n            var result = macroFn(stx, context$2, prevStx, prevTerms);\n            if (matchedTokens) {\n                var\n                    // from = stx.takeUntil (x) -> x == rest[0]\n                    i = 0, next = result.rest[0];\n                while (stx[i] !== next)\n                    matchedTokens.push(stx[i++].token);\n            }\n            return result;\n        };\n    }\n    function expandToTermTree(stx, context) {\n        assert(context, 'expander context is required');\n        var f, head, prevStx, restStx, prevTerms, macroDefinition;\n        var rest = stx;\n        while (rest.length > 0) {\n            assert(rest[0].token, 'expecting a syntax object');\n            f = enforest(rest, context, prevStx, prevTerms);\n            // head :: TermTree\n            head = f.result;\n            // rest :: [Syntax]\n            rest = f.rest;\n            if (!head) {\n                // no head means the expansions stopped prematurely (for stepping)\n                restStx = rest;\n                break;\n            }\n            if (head.isMacro && expandCount < maxExpands) {\n                // load the macro definition into the environment and continue expanding\n                macroDefinition = loadMacroDef(head, context, rest);\n                var name = head.name.map(unwrapSyntax).join('');\n                var nameStx = syn.makeIdent(name, head.name[0]);\n                addToDefinitionCtx([nameStx], context.defscope, false, context.paramscope);\n                context.env.names.set(name, true);\n                context.env.set(resolve(nameStx), {\n                    fn: macroDefinition,\n                    isOp: false,\n                    builtin: builtinMode,\n                    fullName: head.name\n                });\n                continue;\n            }\n            if (head.isLetMacro && expandCount < maxExpands) {\n                // load the macro definition into the environment and continue expanding\n                macroDefinition = loadMacroDef(head, context, rest);\n                var freshName = fresh();\n                var name = head.name.map(unwrapSyntax).join('');\n                var nameStx = syn.makeIdent(name, head.name[0]);\n                var renamedName = nameStx.rename(nameStx, freshName);\n                rest = _.map(rest, function (stx$2) {\n                    return stx$2.rename(nameStx, freshName);\n                });\n                context.env.names.set(name, true);\n                context.env.set(resolve(renamedName), {\n                    fn: macroDefinition,\n                    isOp: false,\n                    builtin: builtinMode,\n                    fullName: head.name\n                });\n                continue;\n            }\n            if (head.isOperatorDefinition) {\n                var opDefinition = loadMacroDef(head, context, rest);\n                var name = head.name.map(unwrapSyntax).join('');\n                var nameStx = syn.makeIdent(name, head.name[0]);\n                addToDefinitionCtx([nameStx], context.defscope, false, context.paramscope);\n                var resolvedName = resolve(nameStx);\n                var opObj = context.env.get(resolvedName);\n                if (!opObj) {\n                    opObj = {\n                        isOp: true,\n                        builtin: builtinMode,\n                        fullName: head.name\n                    };\n                }\n                assert(head.type === 'binary' || head.type === 'unary', 'operator must either be binary or unary');\n                opObj[head.type] = {\n                    fn: opDefinition,\n                    prec: head.prec.token.value,\n                    assoc: head.assoc ? head.assoc.token.value : null\n                };\n                context.env.names.set(name, true);\n                context.env.set(resolvedName, opObj);\n                continue;\n            }\n            var // We build the newPrevTerms/Stx here (instead of at the beginning) so\n            // that macro definitions don't get added to it.\n            destructed = tagWithTerm(head, f.result.destruct());\n            prevTerms = [head].concat(f.prevTerms);\n            prevStx = destructed.reverse().concat(f.prevStx);\n            if (head.isNamedFun) {\n                addToDefinitionCtx([head.name], context.defscope, true, context.paramscope);\n            }\n            if (head.isVariableStatement || head.isLetStatement || head.isConstStatement) {\n                addToDefinitionCtx(_.map(head.decls, function (decl) {\n                    return decl.ident;\n                }), context.defscope, true, context.paramscope);\n            }\n            if (head.isBlock && head.body.isDelimiter) {\n                head.body.delim.token.inner.forEach(function (term) {\n                    if (term.isVariableStatement) {\n                        addToDefinitionCtx(_.map(term.decls, function (decl) {\n                            return decl.ident;\n                        }), context.defscope, true, context.paramscope);\n                    }\n                });\n            }\n            if (head.isDelimiter) {\n                head.delim.token.inner.forEach(function (term) {\n                    if (term.isVariableStatement) {\n                        addToDefinitionCtx(_.map(term.decls, function (decl) {\n                            return decl.ident;\n                        }), context.defscope, true, context.paramscope);\n                    }\n                });\n            }\n            if (head.isForStatement) {\n                head.cond.expose();\n                var forCond = head.cond.token.inner;\n                if (forCond[0] && resolve(forCond[0]) === 'let' && forCond[1] && forCond[1].token.type === parser.Token.Identifier) {\n                    var letNew = fresh();\n                    var letId = forCond[1];\n                    forCond = forCond.map(function (stx$2) {\n                        return stx$2.rename(letId, letNew);\n                    });\n                    // hack: we want to do the let renaming here, not\n                    // in the expansion of `for (...)` so just remove the `let`\n                    // keyword\n                    head.cond.token.inner = expand([forCond[0]], context).concat(expand(forCond.slice(1), context));\n                    if (// nice and easy case: `for (...) { ... }`\n                        rest[0] && rest[0].token.value === '{}') {\n                        rest[0] = rest[0].rename(letId, letNew);\n                    } else {\n                        var // need to deal with things like `for (...) if (...) log(...)`\n                        bodyEnf = enforest(rest, context);\n                        var bodyDestructed = bodyEnf.result.destruct();\n                        var renamedBodyTerm = bodyEnf.result.rename(letId, letNew);\n                        tagWithTerm(renamedBodyTerm, bodyDestructed);\n                        rest = bodyEnf.rest;\n                        prevStx = bodyDestructed.reverse().concat(prevStx);\n                        prevTerms = [renamedBodyTerm].concat(prevTerms);\n                    }\n                } else {\n                    head.cond.token.inner = expand(head.cond.token.inner, context);\n                }\n            }\n        }\n        return {\n            // prevTerms are stored in reverse for the purposes of infix\n            // lookbehind matching, so we need to re-reverse them.\n            terms: prevTerms ? prevTerms.reverse() : [],\n            restStx: restStx,\n            context: context\n        };\n    }\n    function addToDefinitionCtx(idents, defscope, skipRep, paramscope) {\n        assert(idents && idents.length > 0, 'expecting some variable identifiers');\n        // flag for skipping repeats since we reuse this function to place both\n        // variables declarations (which need to skip redeclarations) and\n        // macro definitions which don't\n        skipRep = skipRep || false;\n        _.chain(idents).filter(function (id) {\n            if (skipRep) {\n                var /*\n                       When var declarations repeat in the same function scope:\n\n                       var x = 24;\n                       ...\n                       var x = 42;\n\n                       we just need to use the first renaming and leave the\n                       definition context as is.\n                    */\n                varDeclRep = _.find(defscope, function (def) {\n                    return def.id.token.value === id.token.value && arraysEqual(marksof(def.id.context), marksof(id.context));\n                });\n                var /*\n                        When var declaration repeat one of the function parameters:\n\n                        function foo(x) {\n                            var x;\n                        }\n\n                        we don't need to add the var to the definition context.\n                    */\n                paramDeclRep = _.find(paramscope, function (param) {\n                    return param.token.value === id.token.value && arraysEqual(marksof(param.context), marksof(id.context));\n                });\n                return typeof varDeclRep === 'undefined' && typeof paramDeclRep === 'undefined';\n            }\n            return true;\n        }).each(function (id) {\n            var name = fresh();\n            defscope.push({\n                id: id,\n                name: name\n            });\n        });\n    }\n    function expandTermTreeToFinal(term, context) {\n        assert(context && context.env, 'environment map is required');\n        if (term.isArrayLiteral) {\n            term.array.delim.token.inner = expand(term.array.delim.expose().token.inner, context);\n            return term;\n        } else if (term.isBlock) {\n            term.body.delim.token.inner = expand(term.body.delim.expose().token.inner, context);\n            return term;\n        } else if (term.isParenExpression) {\n            term.args = _.map(term.args, function (arg) {\n                return expandTermTreeToFinal(arg, context);\n            });\n            return term;\n        } else if (term.isCall) {\n            term.fun = expandTermTreeToFinal(term.fun, context);\n            term.args = expandTermTreeToFinal(term.args, context);\n            return term;\n        } else if (term.isReturnStatement) {\n            term.expr = expandTermTreeToFinal(term.expr, context);\n            return term;\n        } else if (term.isUnaryOp) {\n            term.expr = expandTermTreeToFinal(term.expr, context);\n            return term;\n        } else if (term.isBinOp || term.isAssignmentExpression) {\n            term.left = expandTermTreeToFinal(term.left, context);\n            term.right = expandTermTreeToFinal(term.right, context);\n            return term;\n        } else if (term.isObjGet) {\n            term.left = expandTermTreeToFinal(term.left, context);\n            term.right.delim.token.inner = expand(term.right.delim.expose().token.inner, context);\n            return term;\n        } else if (term.isObjDotGet) {\n            term.left = expandTermTreeToFinal(term.left, context);\n            term.right = expandTermTreeToFinal(term.right, context);\n            return term;\n        } else if (term.isConditionalExpression) {\n            term.cond = expandTermTreeToFinal(term.cond, context);\n            term.tru = expandTermTreeToFinal(term.tru, context);\n            term.fls = expandTermTreeToFinal(term.fls, context);\n            return term;\n        } else if (term.isVariableDeclaration) {\n            if (term.init) {\n                term.init = expandTermTreeToFinal(term.init, context);\n            }\n            return term;\n        } else if (term.isVariableStatement || term.isLetStatement || term.isConstStatement) {\n            term.decls = _.map(term.decls, function (decl) {\n                return expandTermTreeToFinal(decl, context);\n            });\n            return term;\n        } else if (term.isDelimiter) {\n            // expand inside the delimiter and then continue on\n            term.delim.token.inner = expand(term.delim.expose().token.inner, context);\n            return term;\n        } else if (term.isId) {\n            var trans = context.env.get(resolve(term.id));\n            if (trans && trans.varTransform) {\n                term.id = syntaxFromToken(term.id.token, trans.varTransform);\n            }\n            return term;\n        } else if (term.isNamedFun || term.isAnonFun || term.isCatchClause || term.isArrowFun || term.isModule) {\n            // function definitions need a bunch of hygiene logic\n            // push down a fresh definition context\n            var newDef = [];\n            var paramSingleIdent = term.params && term.params.token.type === parser.Token.Identifier;\n            var params;\n            if (term.params && term.params.token.type === parser.Token.Delimiter) {\n                params = term.params.expose();\n            } else if (paramSingleIdent) {\n                params = term.params;\n            } else {\n                params = syn.makeDelim('()', [], null);\n            }\n            var bodies;\n            if (Array.isArray(term.body)) {\n                bodies = syn.makeDelim('{}', term.body, null);\n            } else {\n                bodies = term.body;\n            }\n            bodies = bodies.addDefCtx(newDef);\n            var paramNames = _.map(getParamIdentifiers(params), function (param) {\n                var freshName = fresh();\n                var renamed = param.rename(param, freshName);\n                context.env.names.set(renamed.token.value, true);\n                context.env.set(resolve(renamed), { varTransform: renamed });\n                return {\n                    freshName: freshName,\n                    originalParam: param,\n                    renamedParam: renamed\n                };\n            });\n            var bodyContext = makeExpanderContext(_.defaults({\n                defscope: newDef,\n                // paramscope is used to filter out var redeclarations\n                paramscope: paramNames.map(function (p) {\n                    return p.renamedParam;\n                })\n            }, context));\n            var // rename the function body for each of the parameters\n            renamedBody = _.reduce(paramNames, function (accBody, p) {\n                return accBody.rename(p.originalParam, p.freshName);\n            }, bodies);\n            renamedBody = renamedBody.expose();\n            var expandedResult = expandToTermTree(renamedBody.token.inner, bodyContext);\n            var bodyTerms = expandedResult.terms;\n            if (expandedResult.restStx) {\n                // The expansion was halted prematurely. Just stop and\n                // return what we have so far, along with the rest of the syntax\n                renamedBody.token.inner = expandedResult.terms.concat(expandedResult.restStx);\n                if (Array.isArray(term.body)) {\n                    term.body = renamedBody.token.inner;\n                } else {\n                    term.body = renamedBody;\n                }\n                return term;\n            }\n            var renamedParams = _.map(paramNames, function (p) {\n                return p.renamedParam;\n            });\n            var flatArgs;\n            if (paramSingleIdent) {\n                flatArgs = renamedParams[0];\n            } else {\n                var puncCtx = term.params || null;\n                flatArgs = syn.makeDelim('()', joinSyntax(renamedParams, syn.makePunc(',', puncCtx)), puncCtx);\n            }\n            var expandedArgs = expand([flatArgs], bodyContext);\n            assert(expandedArgs.length === 1, 'should only get back one result');\n            if (// stitch up the function with all the renamings\n                term.params) {\n                term.params = expandedArgs[0];\n            }\n            bodyTerms = _.map(bodyTerms, function (bodyTerm) {\n                if (// add the definition context to the result of\n                    // expansion (this makes sure that syntax objects\n                    // introduced by expansion have the def context)\n                    bodyTerm.isBlock) {\n                    var // we need to expand blocks before adding the defctx since\n                    // blocks defer macro expansion.\n                    blockFinal = expandTermTreeToFinal(bodyTerm, expandedResult.context);\n                    return blockFinal.addDefCtx(newDef);\n                } else {\n                    var termWithCtx = bodyTerm.addDefCtx(newDef);\n                    // finish expansion\n                    return expandTermTreeToFinal(termWithCtx, expandedResult.context);\n                }\n            });\n            if (term.isModule) {\n                bodyTerms = _.filter(bodyTerms, function (bodyTerm) {\n                    if (bodyTerm.isExport) {\n                        term.exports.push(bodyTerm);\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            renamedBody.token.inner = bodyTerms;\n            if (Array.isArray(term.body)) {\n                term.body = renamedBody.token.inner;\n            } else {\n                term.body = renamedBody;\n            }\n            // and continue expand the rest\n            return term;\n        }\n        // the term is fine as is\n        return term;\n    }\n    function expand(stx, context) {\n        assert(context, 'must provide an expander context');\n        var trees = expandToTermTree(stx, context);\n        var terms = _.map(trees.terms, function (term) {\n            return expandTermTreeToFinal(term, trees.context);\n        });\n        if (trees.restStx) {\n            terms.push.apply(terms, trees.restStx);\n        }\n        return terms;\n    }\n    function makeExpanderContext(o) {\n        o = o || {};\n        var env = o.env || new StringMap();\n        if (!env.names) {\n            env.names = new StringMap();\n        }\n        return Object.create(Object.prototype, {\n            filename: {\n                value: o.filename,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            requireModule: {\n                value: o.requireModule,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            env: {\n                value: env,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            defscope: {\n                value: o.defscope,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            paramscope: {\n                value: o.paramscope,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            templateMap: {\n                value: o.templateMap || new StringMap(),\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            patternMap: {\n                value: o.patternMap || new StringMap(),\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            mark: {\n                value: o.mark,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            },\n            log: {\n                value: o.log,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            }\n        });\n    }\n    function makeTopLevelExpanderContext(options) {\n        var requireModule = options ? options.requireModule : undefined;\n        var filename = options && options.filename ? options.filename : '<anonymous module>';\n        return makeExpanderContext({\n            filename: filename,\n            requireModule: requireModule,\n            log: options ? options.log : undefined\n        });\n    }\n    function expandTopLevel(stx, moduleContexts, options) {\n        moduleContexts = moduleContexts || [];\n        options = options || {};\n        options.flatten = options.flatten != null ? options.flatten : true;\n        maxExpands = options.maxExpands || Infinity;\n        expandCount = 0;\n        var context = makeTopLevelExpanderContext(options);\n        var modBody = syn.makeDelim('{}', stx, null);\n        modBody = _.reduce(moduleContexts, function (acc, mod) {\n            context.env.extend(mod.env);\n            context.env.names.extend(mod.env.names);\n            return loadModuleExports(acc, context.env, mod.exports, mod.env);\n        }, modBody);\n        var res = expand([\n            syn.makeIdent('module', null),\n            modBody\n        ], context);\n        res = res[0].destruct();\n        res = res[0].token.inner;\n        return options.flatten ? flatten(res) : res;\n    }\n    function expandModule(stx, moduleContexts, options) {\n        moduleContexts = moduleContexts || [];\n        maxExpands = Infinity;\n        expandCount = 0;\n        var context = makeTopLevelExpanderContext(options);\n        var modBody = syn.makeDelim('{}', stx, null);\n        modBody = _.reduce(moduleContexts, function (acc, mod) {\n            context.env.extend(mod.env);\n            context.env.names.extend(mod.env.names);\n            return loadModuleExports(acc, context.env, mod.exports, mod.env);\n        }, modBody);\n        builtinMode = true;\n        var moduleRes = expand([\n            syn.makeIdent('module', null),\n            modBody\n        ], context);\n        builtinMode = false;\n        context.exports = _.map(moduleRes[0].exports, function (term) {\n            var nameStr, name;\n            if (term.name.token.type === parser.Token.Delimiter) {\n                nameStr = term.name.token.inner.map(unwrapSyntax).join('');\n                name = syn.makeIdent(nameStr, term.name);\n            } else {\n                name = term.name;\n                nameStr = unwrapSyntax(name);\n            }\n            return {\n                oldExport: name,\n                newParam: syn.makeIdent(nameStr, null)\n            };\n        });\n        return context;\n    }\n    function loadModuleExports(stx, newEnv, exports$3, oldEnv) {\n        return _.reduce(exports$3, function (acc, param) {\n            var newName = fresh();\n            var transformer = oldEnv.get(resolve(param.oldExport));\n            if (transformer) {\n                newEnv.set(resolve(param.newParam.rename(param.newParam, newName)), transformer);\n                return acc.rename(param.newParam, newName);\n            } else {\n                return acc;\n            }\n        }, stx);\n    }\n    function flatten(stxs) {\n        var acc = [], accLen = 0;\n        var stack = [], frame;\n        var depth = 0;\n        var index = -1;\n        var count = stxs.length;\n        var stx, tok, exposed, openParen, closeParen;\n        flattening:\n            while (depth > -1) {\n                while (++index < count) {\n                    if ((tok = (stx = stxs[index]) && stx.token) && tok.type === parser.Token.Delimiter) {\n                        exposed = stx.expose();\n                        openParen = syntaxFromToken({\n                            type: parser.Token.Punctuator,\n                            value: tok.value[0],\n                            range: tok.startRange,\n                            sm_range: typeof tok.sm_startRange == 'undefined' ? tok.startRange : tok.sm_startRange,\n                            lineNumber: tok.startLineNumber,\n                            sm_lineNumber: typeof tok.sm_startLineNumber == 'undefined' ? tok.startLineNumber : tok.sm_startLineNumber,\n                            lineStart: tok.startLineStart,\n                            sm_lineStart: typeof tok.sm_startLineStart == 'undefined' ? tok.startLineStart : tok.sm_startLineStart\n                        }, exposed);\n                        closeParen = syntaxFromToken({\n                            type: parser.Token.Punctuator,\n                            value: tok.value[1],\n                            range: tok.endRange,\n                            sm_range: typeof tok.sm_endRange == 'undefined' ? tok.endRange : tok.sm_endRange,\n                            lineNumber: tok.endLineNumber,\n                            sm_lineNumber: typeof tok.sm_endLineNumber == 'undefined' ? tok.endLineNumber : tok.sm_endLineNumber,\n                            lineStart: tok.endLineStart,\n                            sm_lineStart: typeof tok.sm_endLineStart == 'undefined' ? tok.endLineStart : tok.sm_endLineStart\n                        }, exposed);\n                        if (tok.leadingComments) {\n                            openParen.token.leadingComments = tok.leadingComments;\n                        }\n                        if (tok.trailingComments) {\n                            openParen.token.trailingComments = tok.trailingComments;\n                        }\n                        acc[accLen++] = openParen;\n                        stack[depth++] = [\n                            tok,\n                            closeParen,\n                            stxs,\n                            index\n                        ];\n                        stxs = exposed.token.inner;\n                        index = -1;\n                        count = stxs.length;\n                        continue;\n                    }\n                    tok.sm_lineNumber = typeof tok.sm_lineNumber != 'undefined' ? tok.sm_lineNumber : tok.lineNumber;\n                    tok.sm_lineStart = typeof tok.sm_lineStart != 'undefined' ? tok.sm_lineStart : tok.lineStart;\n                    tok.sm_range = typeof tok.sm_range != 'undefined' ? tok.sm_range : tok.range;\n                    acc[accLen++] = stx;\n                }\n                if (--depth > -1) {\n                    frame = stack[depth];\n                    tok = frame[0];\n                    closeParen = frame[1];\n                    acc[accLen++] = closeParen;\n                    tok.sm_lineNumber = typeof tok.sm_lineNumber != 'undefined' ? tok.sm_lineNumber : tok.lineNumber;\n                    tok.sm_lineStart = typeof tok.sm_lineStart != 'undefined' ? tok.sm_lineStart : tok.lineStart;\n                    tok.sm_range = typeof tok.sm_range != 'undefined' ? tok.sm_range : tok.range;\n                    stxs = frame[2];\n                    index = frame[3];\n                    count = stxs.length;\n                    continue flattening;\n                }\n            }\n        return acc;\n    }\n    exports$2.StringMap = StringMap;\n    exports$2.enforest = enforest;\n    exports$2.expand = expandTopLevel;\n    exports$2.expandModule = expandModule;\n    exports$2.resolve = resolve;\n    exports$2.get_expression = get_expression;\n    exports$2.getName = getName;\n    exports$2.getMacroInEnv = getMacroInEnv;\n    exports$2.nameInEnv = nameInEnv;\n    exports$2.makeExpanderContext = makeExpanderContext;\n    exports$2.Expr = Expr;\n    exports$2.VariableStatement = VariableStatement;\n    exports$2.tokensToSyntax = syn.tokensToSyntax;\n    exports$2.syntaxToTokens = syn.syntaxToTokens;\n}));\n//# sourceMappingURL=expander.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/expander.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/expander.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/underscore/underscore.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/underscore/underscore.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("(function (root, factory) {\n    if (true) {\n        // CommonJS\n        factory(exports, __webpack_require__(15), __webpack_require__(13), __webpack_require__(14));\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([\n            'exports',\n            'underscore',\n            'parser',\n            'expander'\n        ], factory);\n    }\n}(this, function (exports$2, _, parser, expander) {\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n    // Keep an incrementing global counter so that a particular\n    // each new context object is assigned a unique \"instance number\"\n    // that it can be identified by. This helps with the memoization\n    // of the recursive resolveCtx implementation in expander.js.\n    // The memoization addresses issue #232.\n    var globalContextInstanceNumber = 1;\n    function Rename(id, name, ctx, defctx) {\n        defctx = defctx || null;\n        this.id = id;\n        this.name = name;\n        this.context = ctx;\n        this.def = defctx;\n        this.instNum = globalContextInstanceNumber++;\n    }\n    function Mark(mark, ctx) {\n        this.mark = mark;\n        this.context = ctx;\n        this.instNum = globalContextInstanceNumber++;\n    }\n    function Def(defctx, ctx) {\n        this.defctx = defctx;\n        this.context = ctx;\n        this.instNum = globalContextInstanceNumber++;\n    }\n    function Syntax(token, oldstx) {\n        this.token = token;\n        this.context = oldstx && oldstx.context ? oldstx.context : null;\n        this.deferredContext = oldstx && oldstx.deferredContext ? oldstx.deferredContext : null;\n    }\n    Syntax.prototype = {\n        // (Int) -> CSyntax\n        // non mutating\n        mark: function (newMark) {\n            if (this.token.inner) {\n                return syntaxFromToken(this.token, {\n                    deferredContext: new Mark(newMark, this.deferredContext),\n                    context: new Mark(newMark, this.context)\n                });\n            }\n            return syntaxFromToken(this.token, { context: new Mark(newMark, this.context) });\n        },\n        // (CSyntax or [...CSyntax], Str) -> CSyntax\n        // non mutating\n        rename: function (id, name, defctx) {\n            if (// defer renaming of delimiters\n                this.token.inner) {\n                return syntaxFromToken(this.token, {\n                    deferredContext: new Rename(id, name, this.deferredContext, defctx),\n                    context: new Rename(id, name, this.context, defctx)\n                });\n            }\n            return syntaxFromToken(this.token, { context: new Rename(id, name, this.context, defctx) });\n        },\n        addDefCtx: function (defctx) {\n            if (this.token.inner) {\n                return syntaxFromToken(this.token, {\n                    deferredContext: new Def(defctx, this.deferredContext),\n                    context: new Def(defctx, this.context)\n                });\n            }\n            return syntaxFromToken(this.token, { context: new Def(defctx, this.context) });\n        },\n        getDefCtx: function () {\n            var ctx = this.context;\n            while (ctx !== null) {\n                if (ctx instanceof Def) {\n                    return ctx.defctx;\n                }\n                ctx = ctx.context;\n            }\n            return null;\n        },\n        expose: function () {\n            assert(this.token.type === parser.Token.Delimiter, 'Only delimiters can be exposed');\n            function applyContext(stxCtx, ctx) {\n                if (ctx == null) {\n                    return stxCtx;\n                } else if (ctx instanceof Rename) {\n                    return new Rename(ctx.id, ctx.name, applyContext(stxCtx, ctx.context), ctx.def);\n                } else if (ctx instanceof Mark) {\n                    return new Mark(ctx.mark, applyContext(stxCtx, ctx.context));\n                } else if (ctx instanceof Def) {\n                    return new Def(ctx.defctx, applyContext(stxCtx, ctx.context));\n                } else {\n                    assert(false, 'unknown context type');\n                }\n            }\n            var self = this;\n            this.token.inner = _.map(this.token.inner, function (stx) {\n                if (// when not a syntax object (aka a TermTree) then no need to push down the expose\n                    !stx.token) {\n                    return stx;\n                }\n                if (stx.token.inner) {\n                    return syntaxFromToken(stx.token, {\n                        deferredContext: applyContext(stx.deferredContext, self.deferredContext),\n                        context: applyContext(stx.context, self.deferredContext)\n                    });\n                } else {\n                    return syntaxFromToken(stx.token, { context: applyContext(stx.context, self.deferredContext) });\n                }\n            });\n            this.deferredContext = null;\n            return this;\n        },\n        toString: function () {\n            var val = this.token.type === parser.Token.EOF ? 'EOF' : this.token.value;\n            return '[Syntax: ' + val + ']';\n        }\n    };\n    function syntaxFromToken(token, oldstx) {\n        return new Syntax(token, oldstx);\n    }\n    function mkSyntax(stx, value, type, inner) {\n        if (stx && Array.isArray(stx) && stx.length === 1) {\n            stx = stx[0];\n        } else if (stx && Array.isArray(stx)) {\n            throwSyntaxError('mkSyntax', 'Expecting a syntax object or an array with a single syntax object');\n        } else if (stx === undefined) {\n            throwSyntaxError('mkSyntax', 'You must provide an old syntax object context (or null) when creating a new syntax object.');\n        }\n        if (type === parser.Token.Delimiter) {\n            var startLineNumber, startLineStart, endLineNumber, endLineStart, startRange, endRange;\n            if (!Array.isArray(inner)) {\n                throwSyntaxError('mkSyntax', 'Must provide inner array of syntax objects when creating a delimiter');\n            }\n            if (stx && stx.token.type === parser.Token.Delimiter) {\n                startLineNumber = stx.token.startLineNumber;\n                startLineStart = stx.token.startLineStart;\n                endLineNumber = stx.token.endLineNumber;\n                endLineStart = stx.token.endLineStart;\n                startRange = stx.token.startRange;\n                endRange = stx.token.endRange;\n            } else if (stx && stx.token) {\n                startLineNumber = stx.token.lineNumber;\n                startLineStart = stx.token.lineStart;\n                endLineNumber = stx.token.lineNumber;\n                endLineStart = stx.token.lineStart;\n                startRange = stx.token.range;\n                endRange = stx.token.range;\n            }\n            return syntaxFromToken({\n                type: parser.Token.Delimiter,\n                value: value,\n                inner: inner,\n                startLineStart: startLineStart,\n                startLineNumber: startLineNumber,\n                endLineStart: endLineStart,\n                endLineNumber: endLineNumber,\n                startRange: startRange,\n                endRange: endRange\n            }, stx);\n        } else {\n            var lineStart, lineNumber, range;\n            if (stx && stx.token.type === parser.Token.Delimiter) {\n                lineStart = stx.token.startLineStart;\n                lineNumber = stx.token.startLineNumber;\n                range = stx.token.startRange;\n            } else if (stx && stx.token) {\n                lineStart = stx.token.lineStart;\n                lineNumber = stx.token.lineNumber;\n                range = stx.token.range;\n            }\n            return syntaxFromToken({\n                type: type,\n                value: value,\n                lineStart: lineStart,\n                lineNumber: lineNumber,\n                range: range\n            }, stx);\n        }\n    }\n    function makeValue(val, stx) {\n        if (typeof val === 'boolean') {\n            return mkSyntax(stx, val ? 'true' : 'false', parser.Token.BooleanLiteral);\n        } else if (typeof val === 'number') {\n            if (val !== val) {\n                return makeDelim('()', [\n                    makeValue(0, stx),\n                    makePunc('/', stx),\n                    makeValue(0, stx)\n                ], stx);\n            }\n            if (val < 0) {\n                return makeDelim('()', [\n                    makePunc('-', stx),\n                    makeValue(Math.abs(val), stx)\n                ], stx);\n            } else {\n                return mkSyntax(stx, val, parser.Token.NumericLiteral);\n            }\n        } else if (typeof val === 'string') {\n            return mkSyntax(stx, val, parser.Token.StringLiteral);\n        } else if (val === null) {\n            return mkSyntax(stx, 'null', parser.Token.NullLiteral);\n        } else {\n            throwSyntaxError('makeValue', 'Cannot make value syntax object from: ' + val);\n        }\n    }\n    function makeRegex(val, flags, stx) {\n        var newstx = mkSyntax(stx, new RegExp(val, flags), parser.Token.RegexLiteral);\n        // regex tokens need the extra field literal on token\n        newstx.token.literal = val;\n        return newstx;\n    }\n    function makeIdent(val, stx) {\n        return mkSyntax(stx, val, parser.Token.Identifier);\n    }\n    function makeKeyword(val, stx) {\n        return mkSyntax(stx, val, parser.Token.Keyword);\n    }\n    function makePunc(val, stx) {\n        return mkSyntax(stx, val, parser.Token.Punctuator);\n    }\n    function makeDelim(val, inner, stx) {\n        return mkSyntax(stx, val, parser.Token.Delimiter, inner);\n    }\n    function unwrapSyntax(stx) {\n        if (Array.isArray(stx) && stx.length === 1) {\n            // pull stx out of single element arrays for convenience\n            stx = stx[0];\n        }\n        if (stx.token) {\n            if (stx.token.type === parser.Token.Delimiter) {\n                return stx.token;\n            } else {\n                return stx.token.value;\n            }\n        } else {\n            throw new Error('Not a syntax object: ' + stx);\n        }\n    }\n    function syntaxToTokens(stx) {\n        return _.map(stx, function (stx$2) {\n            if (stx$2.token.inner) {\n                stx$2.token.inner = syntaxToTokens(stx$2.token.inner);\n            }\n            return stx$2.token;\n        });\n    }\n    function tokensToSyntax(tokens) {\n        if (!_.isArray(tokens)) {\n            tokens = [tokens];\n        }\n        return _.map(tokens, function (token) {\n            if (token.inner) {\n                token.inner = tokensToSyntax(token.inner);\n            }\n            return syntaxFromToken(token);\n        });\n    }\n    function joinSyntax(tojoin, punc) {\n        if (tojoin.length === 0) {\n            return [];\n        }\n        if (punc === ' ') {\n            return tojoin;\n        }\n        return _.reduce(_.rest(tojoin, 1), function (acc, join) {\n            acc.push(cloneSyntax(punc), join);\n            return acc;\n        }, [_.first(tojoin)]);\n    }\n    function joinSyntaxArray(tojoin, punc) {\n        if (tojoin.length === 0) {\n            return [];\n        }\n        if (punc === ' ') {\n            return _.flatten(tojoin, true);\n        }\n        return _.reduce(_.rest(tojoin, 1), function (acc, join) {\n            acc.push(cloneSyntax(punc));\n            Array.prototype.push.apply(acc, join);\n            return acc;\n        }, _.first(tojoin));\n    }\n    function cloneSyntax(stx) {\n        return syntaxFromToken(_.clone(stx.token), stx);\n    }\n    function cloneSyntaxArray(arr) {\n        return arr.map(function (stx) {\n            var o = cloneSyntax(stx);\n            if (o.token.type === parser.Token.Delimiter) {\n                o.token.inner = cloneSyntaxArray(o.token.inner);\n            }\n            return o;\n        });\n    }\n    function MacroSyntaxError(name, message, stx) {\n        this.name = name;\n        this.message = message;\n        this.stx = stx;\n    }\n    function throwSyntaxError(name, message, stx) {\n        if (stx && Array.isArray(stx)) {\n            stx = stx[0];\n        }\n        throw new MacroSyntaxError(name, message, stx);\n    }\n    function SyntaxCaseError(message) {\n        this.message = message;\n    }\n    function throwSyntaxCaseError(message) {\n        throw new SyntaxCaseError(message);\n    }\n    function printSyntaxError(code, err) {\n        if (!err.stx) {\n            return '[' + err.name + '] ' + err.message;\n        }\n        var token = err.stx.token;\n        var lineNumber = _.find([\n            token.sm_startLineNumber,\n            token.sm_lineNumber,\n            token.startLineNumber,\n            token.lineNumber\n        ], _.isNumber);\n        var lineStart = _.find([\n            token.sm_startLineStart,\n            token.sm_lineStart,\n            token.startLineStart,\n            token.lineStart\n        ], _.isNumber);\n        var start = (token.sm_startRange || token.sm_range || token.startRange || token.range)[0];\n        var offset = start - lineStart;\n        var line = '';\n        var pre = lineNumber + ': ';\n        var ch;\n        while (ch = code.charAt(lineStart++)) {\n            if (ch == '\\r' || ch == '\\n') {\n                break;\n            }\n            line += ch;\n        }\n        return '[' + err.name + '] ' + err.message + '\\n' + pre + line + '\\n' + Array(offset + pre.length).join(' ') + ' ^';\n    }\n    function prettyPrint(stxarr, shouldResolve) {\n        var indent = 0;\n        var unparsedLines = stxarr.reduce(function (acc, stx) {\n            var s = shouldResolve ? expander.resolve(stx) : stx.token.value;\n            if (// skip the end of file token\n                stx.token.type === parser.Token.EOF) {\n                return acc;\n            }\n            if (stx.token.type === parser.Token.StringLiteral) {\n                s = '\"' + s + '\"';\n            }\n            if (s == '{') {\n                acc[0].str += ' ' + s;\n                indent++;\n                acc.unshift({\n                    indent: indent,\n                    str: ''\n                });\n            } else if (s == '}') {\n                indent--;\n                acc.unshift({\n                    indent: indent,\n                    str: s\n                });\n                acc.unshift({\n                    indent: indent,\n                    str: ''\n                });\n            } else if (s == ';') {\n                acc[0].str += s;\n                acc.unshift({\n                    indent: indent,\n                    str: ''\n                });\n            } else {\n                acc[0].str += (acc[0].str ? ' ' : '') + s;\n            }\n            return acc;\n        }, [{\n                indent: 0,\n                str: ''\n            }]);\n        return unparsedLines.reduce(function (acc, line) {\n            var ind = '';\n            while (ind.length < line.indent * 2) {\n                ind += ' ';\n            }\n            return ind + line.str + '\\n' + acc;\n        }, '');\n    }\n    exports$2.assert = assert;\n    exports$2.unwrapSyntax = unwrapSyntax;\n    exports$2.makeDelim = makeDelim;\n    exports$2.makePunc = makePunc;\n    exports$2.makeKeyword = makeKeyword;\n    exports$2.makeIdent = makeIdent;\n    exports$2.makeRegex = makeRegex;\n    exports$2.makeValue = makeValue;\n    exports$2.Rename = Rename;\n    exports$2.Mark = Mark;\n    exports$2.Def = Def;\n    exports$2.syntaxFromToken = syntaxFromToken;\n    exports$2.tokensToSyntax = tokensToSyntax;\n    exports$2.syntaxToTokens = syntaxToTokens;\n    exports$2.isSyntax = function (obj) {\n        obj = Array.isArray(obj) ? obj[0] : obj;\n        return obj instanceof Syntax;\n    };\n    exports$2.joinSyntax = joinSyntax;\n    exports$2.joinSyntaxArray = joinSyntaxArray;\n    exports$2.cloneSyntax = cloneSyntax;\n    exports$2.cloneSyntaxArray = cloneSyntaxArray;\n    exports$2.prettyPrint = prettyPrint;\n    exports$2.MacroSyntaxError = MacroSyntaxError;\n    exports$2.throwSyntaxError = throwSyntaxError;\n    exports$2.SyntaxCaseError = SyntaxCaseError;\n    exports$2.throwSyntaxCaseError = throwSyntaxCaseError;\n    exports$2.printSyntaxError = printSyntaxError;\n}));\n//# sourceMappingURL=syntax.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/syntax.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/syntax.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("// thou shalt not macro expand me...all kinds of hygiene hackary\n// with strings and `with`.\n\n\n(function (root, factory) {\n    if (true) {\n        // CommonJS\n        factory(exports);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    }\n}(this, function(exports) {\n\n    exports.scopedEval = function(source, global) {\n        return eval('(function() { with(global) { return ' + source + ' } }).call(global, global);');\n    };\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/scopedEval.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/scopedEval.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("(function (root, factory) {\n    if (true) {\n        // CommonJS\n        factory(exports, __webpack_require__(15), __webpack_require__(13), __webpack_require__(14), __webpack_require__(16));\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([\n            'exports',\n            'underscore',\n            'parser',\n            'expander',\n            'syntax'\n        ], factory);\n    }\n}(this, function (exports$2, _, parser, expander, syntax) {\n    var get_expression = expander.get_expression;\n    var syntaxFromToken = syntax.syntaxFromToken;\n    var makePunc = syntax.makePunc;\n    var makeIdent = syntax.makeIdent;\n    var makeDelim = syntax.makeDelim;\n    var joinSyntax = syntax.joinSyntax;\n    var joinSyntaxArray = syntax.joinSyntaxArray;\n    var cloneSyntax = syntax.cloneSyntax;\n    var cloneSyntaxArray = syntax.cloneSyntaxArray;\n    var assert = syntax.assert;\n    var throwSyntaxError = syntax.throwSyntaxError;\n    var push = Array.prototype.push;\n    function freeVarsInPattern(pattern) {\n        var fv = [];\n        _.each(pattern, function (pat) {\n            if (isPatternVar(pat)) {\n                fv.push(pat.token.value);\n            } else if (pat.token.type === parser.Token.Delimiter) {\n                push.apply(fv, freeVarsInPattern(pat.token.inner));\n            }\n        });\n        return fv;\n    }\n    function typeIsLiteral(type) {\n        return type === parser.Token.NullLiteral || type === parser.Token.NumericLiteral || type === parser.Token.StringLiteral || type === parser.Token.RegexLiteral || type === parser.Token.BooleanLiteral;\n    }\n    function containsPatternVar(patterns) {\n        return _.any(patterns, function (pat) {\n            if (pat.token.type === parser.Token.Delimiter) {\n                return containsPatternVar(pat.token.inner);\n            }\n            return isPatternVar(pat);\n        });\n    }\n    function delimIsSeparator(delim) {\n        return delim && delim.token && delim.token.type === parser.Token.Delimiter && delim.token.value === '()' && delim.token.inner.length === 1 && delim.token.inner[0].token.type !== parser.Token.Delimiter && !containsPatternVar(delim.token.inner);\n    }\n    function isPatternVar(stx) {\n        return stx.token.value[0] === '$' && stx.token.value !== '$';\n    }\n    function joinRepeatedMatch(tojoin, punc) {\n        return _.reduce(_.rest(tojoin, 1), function (acc, join) {\n            if (punc === ' ') {\n                return acc.concat(cloneSyntaxArray(join.match));\n            }\n            return acc.concat(cloneSyntax(punc), cloneSyntaxArray(join.match));\n        }, cloneSyntaxArray(_.first(tojoin).match));\n    }\n    function takeLineContext(from, to) {\n        return _.map(to, function (stx) {\n            return takeLine(from, stx);\n        });\n    }\n    function takeLine(from, to) {\n        var next;\n        if (to.token.type === parser.Token.Delimiter) {\n            var sm_startLineNumber = typeof to.token.sm_startLineNumber !== 'undefined' ? to.token.sm_startLineNumber : to.token.startLineNumber;\n            var sm_endLineNumber = typeof to.token.sm_endLineNumber !== 'undefined' ? to.token.sm_endLineNumber : to.token.endLineNumber;\n            var sm_startLineStart = typeof to.token.sm_startLineStart !== 'undefined' ? to.token.sm_startLineStart : to.token.startLineStart;\n            var sm_endLineStart = typeof to.token.sm_endLineStart !== 'undefined' ? to.token.sm_endLineStart : to.token.endLineStart;\n            var sm_startRange = typeof to.token.sm_startRange !== 'undefined' ? to.token.sm_startRange : to.token.startRange;\n            var sm_endRange = typeof to.token.sm_endRange !== 'undefined' ? to.token.sm_endRange : to.token.endRange;\n            if (from.token.type === parser.Token.Delimiter) {\n                next = syntaxFromToken({\n                    type: parser.Token.Delimiter,\n                    value: to.token.value,\n                    inner: takeLineContext(from, to.token.inner),\n                    startRange: from.token.startRange,\n                    endRange: from.token.endRange,\n                    startLineNumber: from.token.startLineNumber,\n                    startLineStart: from.token.startLineStart,\n                    endLineNumber: from.token.endLineNumber,\n                    endLineStart: from.token.endLineStart,\n                    sm_startLineNumber: sm_startLineNumber,\n                    sm_endLineNumber: sm_endLineNumber,\n                    sm_startLineStart: sm_startLineStart,\n                    sm_endLineStart: sm_endLineStart,\n                    sm_startRange: sm_startRange,\n                    sm_endRange: sm_endRange\n                }, to);\n            } else {\n                next = syntaxFromToken({\n                    type: parser.Token.Delimiter,\n                    value: to.token.value,\n                    inner: takeLineContext(from, to.token.inner),\n                    startRange: from.token.range,\n                    endRange: from.token.range,\n                    startLineNumber: from.token.lineNumber,\n                    startLineStart: from.token.lineStart,\n                    endLineNumber: from.token.lineNumber,\n                    endLineStart: from.token.lineStart,\n                    sm_startLineNumber: sm_startLineNumber,\n                    sm_endLineNumber: sm_endLineNumber,\n                    sm_startLineStart: sm_startLineStart,\n                    sm_endLineStart: sm_endLineStart,\n                    sm_startRange: sm_startRange,\n                    sm_endRange: sm_endRange\n                }, to);\n            }\n        } else {\n            var sm_lineNumber = typeof to.token.sm_lineNumber !== 'undefined' ? to.token.sm_lineNumber : to.token.lineNumber;\n            var sm_lineStart = typeof to.token.sm_lineStart !== 'undefined' ? to.token.sm_lineStart : to.token.lineStart;\n            var sm_range = typeof to.token.sm_range !== 'undefined' ? to.token.sm_range : to.token.range;\n            if (from.token.type === parser.Token.Delimiter) {\n                next = syntaxFromToken({\n                    value: to.token.value,\n                    type: to.token.type,\n                    lineNumber: from.token.startLineNumber,\n                    lineStart: from.token.startLineStart,\n                    range: from.token.startRange,\n                    sm_lineNumber: sm_lineNumber,\n                    sm_lineStart: sm_lineStart,\n                    sm_range: sm_range\n                }, to);\n            } else {\n                next = syntaxFromToken({\n                    value: to.token.value,\n                    type: to.token.type,\n                    lineNumber: from.token.lineNumber,\n                    lineStart: from.token.lineStart,\n                    range: from.token.range,\n                    sm_lineNumber: sm_lineNumber,\n                    sm_lineStart: sm_lineStart,\n                    sm_range: sm_range\n                }, to);\n            }\n        }\n        if (to.token.leadingComments) {\n            next.token.leadingComments = to.token.leadingComments;\n        }\n        if (to.token.trailingComments) {\n            next.token.trailingComments = to.token.trailingComments;\n        }\n        return next;\n    }\n    function reversePattern(patterns) {\n        var len = patterns.length;\n        var pat;\n        return _.reduceRight(patterns, function (acc, pat$2) {\n            if (pat$2.class === 'pattern_group' || pat$2.class === 'named_group') {\n                pat$2.inner = reversePattern(pat$2.inner);\n            }\n            if (pat$2.repeat) {\n                pat$2.leading = !pat$2.leading;\n            }\n            acc.push(pat$2);\n            return acc;\n        }, []);\n    }\n    function loadLiteralGroup(patterns) {\n        return patterns.map(function (patStx) {\n            var pat = patternToObject(patStx);\n            if (pat.inner) {\n                pat.inner = loadLiteralGroup(pat.inner);\n            } else {\n                pat.class = 'pattern_literal';\n            }\n            return pat;\n        });\n    }\n    function patternToObject(pat) {\n        var obj = {\n            type: pat.token.type,\n            value: pat.token.value\n        };\n        if (pat.token.inner) {\n            obj.inner = pat.token.inner;\n        }\n        return obj;\n    }\n    function isPrimaryClass(name) {\n        return [\n            'expr',\n            'lit',\n            'ident',\n            'token',\n            'invoke',\n            'invokeRec'\n        ].indexOf(name) > -1;\n    }\n    function loadPattern(patterns, reverse) {\n        var patts = [];\n        for (var i = 0; i < patterns.length; i++) {\n            var tok1 = patterns[i];\n            var tok2 = patterns[i + 1];\n            var tok3 = patterns[i + 2];\n            var tok4 = patterns[i + 3];\n            var last = patts[patts.length - 1];\n            var patt;\n            assert(tok1, 'Expecting syntax object');\n            if (// Repeaters\n                tok1.token.type === parser.Token.Delimiter && tok1.token.value === '()' && tok2 && tok2.token.type === parser.Token.Punctuator && tok2.token.value === '...' && last) {\n                assert(tok1.token.inner.length === 1, 'currently assuming all separators are a single token');\n                i += 1;\n                last.repeat = true;\n                last.separator = tok1.token.inner[0];\n                continue;\n            } else if (tok1.token.type === parser.Token.Punctuator && tok1.token.value === '...' && last) {\n                last.repeat = true;\n                last.separator = ' ';\n                continue;\n            } else if (isPatternVar(tok1)) {\n                patt = patternToObject(tok1);\n                if (tok2 && tok2.token.type === parser.Token.Punctuator && tok2.token.value === ':' && tok3 && (tok3.token.type === parser.Token.Identifier || tok3.token.type === parser.Token.Delimiter && (tok3.token.value === '[]' || tok3.token.value === '()'))) {\n                    i += 2;\n                    if (tok3.token.value === '[]') {\n                        patt.class = 'named_group';\n                        patt.inner = loadLiteralGroup(tok3.expose().token.inner);\n                    } else if (tok3.token.value === '()') {\n                        patt.class = 'named_group';\n                        patt.inner = loadPattern(tok3.expose().token.inner);\n                    } else if (isPrimaryClass(tok3.token.value)) {\n                        patt.class = tok3.token.value;\n                        if (patt.class === 'invokeRec' || patt.class === 'invoke') {\n                            i += 1;\n                            if (tok4.token.value === '()' && tok4.token.inner.length) {\n                                patt.macroName = tok4.expose().token.inner;\n                            } else {\n                                throwSyntaxError(patt.class, 'Expected macro parameter', tok3);\n                            }\n                        }\n                    } else {\n                        patt.class = 'invoke';\n                        patt.macroName = [tok3];\n                    }\n                } else {\n                    patt.class = 'token';\n                }\n            } else if (tok1.token.type === parser.Token.Identifier && tok1.token.value === '$' && tok2.token.type === parser.Token.Delimiter) {\n                i += 1;\n                patt = patternToObject(tok2);\n                patt.class = 'pattern_group';\n                if (patt.value === '[]') {\n                    patt.inner = loadLiteralGroup(patt.inner);\n                } else {\n                    patt.inner = loadPattern(tok2.expose().token.inner);\n                }\n            } else if (tok1.token.type === parser.Token.Identifier && tok1.token.value === '_') {\n                patt = patternToObject(tok1);\n                patt.class = 'wildcard';\n            } else {\n                patt = patternToObject(tok1);\n                patt.class = 'pattern_literal';\n                if (patt.inner) {\n                    patt.inner = loadPattern(tok1.expose().token.inner);\n                }\n            }\n            if (// Macro classes aren't allowed in lookbehind because we wouldn't\n                // know where to insert the macro, and you can't use a L->R macro\n                // to match R->L.\n                reverse && patt.macroName) {\n                throwSyntaxError(patt.class, 'Not allowed in top-level lookbehind', patt.macroName[0]);\n            }\n            patts.push(patt);\n        }\n        return reverse ? reversePattern(patts) : patts;\n    }\n    function cachedTermMatch(stx, term) {\n        var res = [];\n        var i = 0;\n        while (stx[i] && stx[i].term === term) {\n            res.unshift(stx[i]);\n            i++;\n        }\n        return {\n            result: term,\n            destructed: res,\n            rest: stx.slice(res.length)\n        };\n    }\n    function expandWithMacro(macroName, stx, context, rec) {\n        var name = macroName.map(syntax.unwrapSyntax).join('');\n        var ident = syntax.makeIdent(name, macroName[0]);\n        var macroObj = context.env.get(expander.resolve(ident));\n        var newContext = expander.makeExpanderContext(context);\n        if (!macroObj) {\n            throwSyntaxError('invoke', 'Macro not in scope', macroName[0]);\n        }\n        var next = macroName.slice(-1).concat(stx);\n        var rest, result, rt, patternEnv;\n        while (macroObj && next) {\n            try {\n                rt = macroObj.fn(next, newContext, [], []);\n                result = rt.result;\n                rest = rt.rest;\n                patternEnv = rt.patterns;\n            } catch (e) {\n                if (e instanceof syntax.SyntaxCaseError) {\n                    result = null;\n                    rest = stx;\n                    break;\n                } else {\n                    throw e;\n                }\n            }\n            if (rec && result.length >= 1) {\n                var resultHead = result[0];\n                var resultRest = result.slice(1);\n                var nextName = expander.getName(resultHead, resultRest);\n                var nextMacro = expander.getMacroInEnv(resultHead, resultRest, context.env);\n                if (nextName && nextMacro) {\n                    macroObj = nextMacro;\n                    next = result.concat(rest);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        return {\n            result: result,\n            rest: rest,\n            patternEnv: patternEnv\n        };\n    }\n    function matchPatternClass(patternObj, stx, context) {\n        var result, rest, match, patternEnv;\n        if (// pattern has no parse class\n            patternObj.class === 'token' && stx[0] && stx[0].token.type !== parser.Token.EOF) {\n            result = [stx[0]];\n            rest = stx.slice(1);\n        } else if (patternObj.class === 'lit' && stx[0] && typeIsLiteral(stx[0].token.type)) {\n            result = [stx[0]];\n            rest = stx.slice(1);\n        } else if (patternObj.class === 'ident' && stx[0] && stx[0].token.type === parser.Token.Identifier) {\n            result = [stx[0]];\n            rest = stx.slice(1);\n        } else if (stx.length > 0 && patternObj.class === 'VariableStatement') {\n            match = stx[0].term ? cachedTermMatch(stx, stx[0].term) : expander.enforest(stx, expander.makeExpanderContext(context));\n            if (match.result && match.result.isVariableStatement) {\n                result = match.destructed || match.result.destruct(false);\n                rest = match.rest;\n            } else {\n                result = null;\n                rest = stx;\n            }\n        } else if (stx.length > 0 && patternObj.class === 'expr') {\n            match = expander.get_expression(stx, expander.makeExpanderContext(context));\n            if (match.result === null || !match.result.isExpr) {\n                result = null;\n                rest = stx;\n            } else {\n                result = match.destructed || match.result.destruct(false);\n                result = [syntax.makeDelim('()', result, result[0])];\n                rest = match.rest;\n            }\n        } else if (patternObj.class === 'invoke' || patternObj.class === 'invokeRec') {\n            match = expandWithMacro(patternObj.macroName, stx, context, patternObj.class === 'invokeRec');\n            result = match.result;\n            rest = match.result ? match.rest : stx;\n            patternEnv = match.patternEnv;\n        } else {\n            result = null;\n            rest = stx;\n        }\n        return {\n            result: result,\n            rest: rest,\n            patternEnv: patternEnv\n        };\n    }\n    function matchPatterns(patterns, stx, context, topLevel) {\n        // topLevel lets us know if the patterns are on the top level or nested inside\n        // a delimiter:\n        //     case $topLevel (,) ... => { }\n        //     case ($nested (,) ...) => { }\n        // This matters for how we deal with trailing unmatched syntax when the pattern\n        // has an ellipses:\n        //     m 1,2,3 foo\n        // should match 1,2,3 and leave foo alone but:\n        //     m (1,2,3 foo)\n        // should fail to match entirely.\n        topLevel = topLevel || false;\n        // note that there are two environments floating around,\n        // one is the mapping of identifiers to macro definitions (env)\n        // and the other is the pattern environment (patternEnv) that maps\n        // patterns in a macro case to syntax.\n        var result = [];\n        var patternEnv = {};\n        var match;\n        var pattern;\n        var rest = stx;\n        var success = true;\n        var inLeading;\n        patternLoop:\n            for (var i = 0; i < patterns.length; i++) {\n                if (success === false) {\n                    break;\n                }\n                pattern = patterns[i];\n                inLeading = false;\n                do {\n                    if (// handles cases where patterns trail a repeated pattern like `$x ... ;`\n                        pattern.repeat && i + 1 < patterns.length) {\n                        var restMatch = matchPatterns(patterns.slice(i + 1), rest, context, topLevel);\n                        if (restMatch.success) {\n                            // match the repeat pattern on the empty array to fill in its\n                            // pattern variable in the environment\n                            match = matchPattern(pattern, [], context, patternEnv, topLevel);\n                            patternEnv = _.extend(restMatch.patternEnv, match.patternEnv);\n                            rest = restMatch.rest;\n                            break patternLoop;\n                        }\n                    }\n                    if (pattern.repeat && pattern.leading && pattern.separator !== ' ') {\n                        if (rest[0].token.value === pattern.separator.token.value) {\n                            if (!inLeading) {\n                                inLeading = true;\n                            }\n                            rest = rest.slice(1);\n                        } else {\n                            if (// If we are in a leading repeat, the separator is required.\n                                inLeading) {\n                                success = false;\n                                break;\n                            }\n                        }\n                    }\n                    match = matchPattern(pattern, rest, context, patternEnv, topLevel);\n                    if (!match.success && pattern.repeat) {\n                        // a repeat can match zero tokens and still be a\n                        // \"success\" so break out of the inner loop and\n                        // try the next pattern\n                        break;\n                    }\n                    if (!match.success) {\n                        success = false;\n                        break;\n                    }\n                    rest = match.rest;\n                    patternEnv = match.patternEnv;\n                    if (success && !(topLevel || pattern.repeat)) {\n                        if (// the very last pattern matched, inside a\n                            // delimiter, not a repeat, *and* there are more\n                            // unmatched bits of syntax\n                            i == patterns.length - 1 && rest.length !== 0) {\n                            success = false;\n                            break;\n                        }\n                    }\n                    if (pattern.repeat && !pattern.leading && success) {\n                        if (// if (i < patterns.length - 1 && rest.length > 0) {\n                            //     var restMatch = matchPatterns(patterns.slice(i+1), rest, env, topLevel);\n                            //     if (restMatch.success) {\n                            //         patternEnv = _.extend(patternEnv, restMatch.patternEnv);\n                            //         rest = restMatch.rest;\n                            //         break patternLoop;\n                            //     }\n                            // }\n                            pattern.separator === ' ') {\n                            // no separator specified (using the empty string for this)\n                            // so keep going\n                            continue;\n                        } else if (rest[0] && rest[0].token.value === pattern.separator.token.value) {\n                            // more tokens and the next token matches the separator\n                            rest = rest.slice(1);\n                        } else if (pattern.separator !== ' ' && rest.length > 0 && i === patterns.length - 1 && topLevel === false) {\n                            // separator is specified, there is a next token, the\n                            // next token doesn't match the separator, there are\n                            // no more patterns, and this is a top level pattern\n                            // so the match has failed\n                            success = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n                } while (pattern.repeat && success && rest.length > 0);\n            }\n        if (// If we are in a delimiter and we haven't matched all the syntax, it\n            // was a failed match.\n            !topLevel && rest.length) {\n            success = false;\n        }\n        var result;\n        if (success) {\n            result = rest.length ? stx.slice(0, -rest.length) : stx;\n        } else {\n            result = [];\n        }\n        return {\n            success: success,\n            result: result,\n            rest: rest,\n            patternEnv: patternEnv\n        };\n    }\n    function initPatternEnv(pattern) {\n        var env = {};\n        assert(Array.isArray(pattern.inner), 'expecting an array of patterns');\n        for (var i = 0; i < pattern.inner.length; i++) {\n            env[pattern.inner[i].value] = {\n                level: 0,\n                match: [],\n                topLevel: false\n            };\n        }\n        return env;\n    }\n    function matchPattern(pattern, stx, context, patternEnv, topLevel) {\n        var subMatch;\n        var match, matchEnv;\n        var rest;\n        var success;\n        if (typeof pattern.inner !== 'undefined') {\n            if (pattern.class === 'pattern_group') {\n                // pattern groups don't match the delimiters\n                subMatch = matchPatterns(pattern.inner, stx, context, true);\n                rest = subMatch.rest;\n                success = subMatch.success;\n            } else if (pattern.class === 'named_group') {\n                subMatch = matchPatterns(pattern.inner, stx, context, true);\n                rest = subMatch.rest;\n                success = subMatch.success;\n                if (success) {\n                    var namedMatch = {};\n                    namedMatch[pattern.value] = {\n                        level: 0,\n                        match: subMatch.result,\n                        topLevel: topLevel\n                    };\n                    subMatch.patternEnv = loadPatternEnv(namedMatch, subMatch.patternEnv, topLevel, false, pattern.value);\n                }\n            } else if (stx[0] && stx[0].token.type === parser.Token.Delimiter && stx[0].token.value === pattern.value) {\n                stx[0].expose();\n                if (pattern.inner.length === 0 && stx[0].token.inner.length !== 0) {\n                    return {\n                        success: false,\n                        rest: stx,\n                        patternEnv: patternEnv\n                    };\n                }\n                subMatch = matchPatterns(pattern.inner, stx[0].token.inner, context, false);\n                rest = stx.slice(1);\n                success = subMatch.success;\n            } else {\n                // token is not a delimiter\n                success = false;\n                rest = stx;\n                // match failed but we need to initialize each sub pattern to an empty match\n                subMatch = { patternEnv: initPatternEnv(pattern) };\n            }\n            if (success) {\n                patternEnv = loadPatternEnv(patternEnv, subMatch.patternEnv, topLevel, pattern.repeat);\n            } else if (pattern.repeat) {\n                patternEnv = copyPatternEnv(patternEnv, subMatch.patternEnv, topLevel);\n            }\n        } else {\n            if (pattern.class === 'wildcard') {\n                success = true;\n                rest = stx.slice(1);\n            } else if (pattern.class === 'pattern_literal') {\n                if (// match the literal but don't update the pattern environment\n                    stx[0] && pattern.value === stx[0].token.value) {\n                    success = true;\n                    rest = stx.slice(1);\n                } else {\n                    success = false;\n                    rest = stx;\n                }\n            } else {\n                match = matchPatternClass(pattern, stx, context);\n                success = match.result !== null;\n                rest = match.rest;\n                matchEnv = {\n                    level: 0,\n                    match: match.result,\n                    topLevel: topLevel\n                };\n                if (// push the match onto this value's slot in the environment\n                    pattern.repeat) {\n                    if (patternEnv[pattern.value] && success) {\n                        patternEnv[pattern.value].match.push(matchEnv);\n                    } else if (patternEnv[pattern.value] === undefined) {\n                        // initialize if necessary\n                        patternEnv[pattern.value] = {\n                            level: 1,\n                            match: [matchEnv],\n                            topLevel: topLevel\n                        };\n                    }\n                } else {\n                    patternEnv[pattern.value] = matchEnv;\n                }\n                patternEnv = loadPatternEnv(patternEnv, match.patternEnv, topLevel, pattern.repeat, pattern.value);\n            }\n        }\n        return {\n            success: success,\n            rest: rest,\n            patternEnv: patternEnv\n        };\n    }\n    function copyPatternEnv(toEnv, fromEnv, topLevel) {\n        _.forEach(fromEnv, function (patternVal, patternKey) {\n            if (!toEnv[patternKey]) {\n                toEnv[patternKey] = {\n                    level: patternVal.level + 1,\n                    match: [patternVal],\n                    topLevel: topLevel\n                };\n            }\n        });\n        return toEnv;\n    }\n    function loadPatternEnv(toEnv, fromEnv, topLevel, repeat, prefix) {\n        prefix = prefix || '';\n        _.forEach(fromEnv, function (patternVal, patternKey) {\n            var patternName = prefix + patternKey;\n            if (repeat) {\n                var nextLevel = patternVal.level + 1;\n                if (toEnv[patternName]) {\n                    toEnv[patternName].level = nextLevel;\n                    toEnv[patternName].match.push(patternVal);\n                } else {\n                    toEnv[patternName] = {\n                        level: nextLevel,\n                        match: [patternVal],\n                        topLevel: topLevel\n                    };\n                }\n            } else {\n                toEnv[patternName] = patternVal;\n            }\n        });\n        return toEnv;\n    }\n    function matchLookbehind(patterns, stx, terms, context) {\n        var success, patternEnv, prevStx, prevTerms;\n        if (// No lookbehind, noop.\n            !patterns.length) {\n            success = true;\n            patternEnv = {};\n            prevStx = stx;\n            prevTerms = terms;\n        } else {\n            var match = matchPatterns(patterns, stx, context, true);\n            var last = match.result[match.result.length - 1];\n            success = match.success;\n            patternEnv = match.patternEnv;\n            if (success) {\n                if (match.rest.length) {\n                    if (last && last.term && last.term === match.rest[0].term) {\n                        // The term tree was split, so its a failed match;\n                        success = false;\n                    } else {\n                        prevStx = match.rest;\n                        for (var\n                                // Find where to slice the prevTerms to match up with\n                                // the state of prevStx.\n                                i = 0, len = terms.length; i < len; i++) {\n                            if (terms[i] === prevStx[0].term) {\n                                prevTerms = terms.slice(i);\n                                break;\n                            }\n                        }\n                        assert(prevTerms, 'No matching previous term found');\n                    }\n                } else {\n                    prevTerms = [];\n                    prevStx = [];\n                }\n            }\n        }\n        // We need to reverse the matches for any top level repeaters because\n        // they match in reverse, and thus put their results in backwards.\n        _.forEach(patternEnv, function (val, key) {\n            if (val.level && val.match && val.topLevel) {\n                val.match.reverse();\n            }\n        });\n        return {\n            success: success,\n            patternEnv: patternEnv,\n            prevStx: prevStx,\n            prevTerms: prevTerms\n        };\n    }\n    function hasMatch(m) {\n        if (m.level === 0) {\n            return m.match.length > 0;\n        }\n        return !!m.match;\n    }\n    function transcribe(macroBody, macroNameStx, env) {\n        return _.chain(macroBody).reduce(function (acc, bodyStx, idx, original) {\n            var // first find the ellipses and mark the syntax objects\n            // (note that this step does not eagerly go into delimiter bodies)\n            last = original[idx - 1];\n            var next = original[idx + 1];\n            var nextNext = original[idx + 2];\n            if (// drop `...`\n                bodyStx.token.value === '...') {\n                return acc;\n            }\n            if (// drop `(<separator)` when followed by an ellipse\n                delimIsSeparator(bodyStx) && next && next.token.value === '...') {\n                return acc;\n            }\n            if (// skip the $ in $(...)\n                bodyStx.token.value === '$' && next && next.token.type === parser.Token.Delimiter && next.token.value === '()') {\n                return acc;\n            }\n            if (// mark $[...] as a literal\n                bodyStx.token.value === '$' && next && next.token.type === parser.Token.Delimiter && next.token.value === '[]') {\n                next.literal = true;\n                return acc;\n            }\n            if (bodyStx.token.type === parser.Token.Delimiter && bodyStx.token.value === '()' && last && last.token.value === '$') {\n                bodyStx.group = true;\n            }\n            if (// literal [] delimiters have their bodies just\n                // directly passed along\n                bodyStx.literal === true) {\n                assert(bodyStx.token.type === parser.Token.Delimiter, 'expecting a literal to be surrounded by []');\n                return acc.concat(bodyStx.token.inner);\n            }\n            if (next && next.token.value === '...') {\n                bodyStx.repeat = true;\n                bodyStx.separator = ' ';\n            } else if (delimIsSeparator(next) && nextNext && nextNext.token.value === '...') {\n                bodyStx.repeat = true;\n                bodyStx.separator = next.token.inner[0];\n            }\n            acc.push(bodyStx);\n            return acc;\n        }, []).reduce(function (acc, bodyStx, idx) {\n            if (// then do the actual transcription\n                bodyStx.repeat) {\n                if (bodyStx.token.type === parser.Token.Delimiter) {\n                    bodyStx.expose();\n                    var fv = _.filter(freeVarsInPattern(bodyStx.token.inner), function (pat) {\n                        // ignore \"patterns\"\n                        // that aren't in the\n                        // environment (treat\n                        // them like literals)\n                        return env.hasOwnProperty(pat);\n                    });\n                    var restrictedEnv = [];\n                    var nonScalar = _.find(fv, function (pat) {\n                        return env[pat].level > 0;\n                    });\n                    assert(typeof nonScalar !== 'undefined', 'must have a least one non-scalar in repeat');\n                    var repeatLength = env[nonScalar].match.length;\n                    var sameLength = _.all(fv, function (pat) {\n                        return env[pat].level === 0 || env[pat].match.length === repeatLength;\n                    });\n                    assert(sameLength, 'all non-scalars must have the same length');\n                    // create a list of envs restricted to the free vars\n                    _.each(_.range(repeatLength), function (idx$2) {\n                        var renv = {};\n                        _.each(fv, function (pat) {\n                            if (env[pat].level === 0) {\n                                // copy scalars over\n                                renv[pat] = env[pat];\n                            } else {\n                                // grab the match at this index\n                                renv[pat] = env[pat].match[idx$2];\n                            }\n                        });\n                        var allHaveMatch = Object.keys(renv).every(function (pat) {\n                            return hasMatch(renv[pat]);\n                        });\n                        if (allHaveMatch) {\n                            restrictedEnv.push(renv);\n                        }\n                    });\n                    var transcribed = _.map(restrictedEnv, function (renv) {\n                        if (bodyStx.group) {\n                            return transcribe(bodyStx.token.inner, macroNameStx, renv);\n                        } else {\n                            var newBody$2 = syntaxFromToken(_.clone(bodyStx.token), bodyStx);\n                            newBody$2.token.inner = transcribe(bodyStx.token.inner, macroNameStx, renv);\n                            return newBody$2;\n                        }\n                    });\n                    var joined;\n                    if (bodyStx.group) {\n                        joined = joinSyntaxArray(transcribed, bodyStx.separator);\n                    } else {\n                        joined = joinSyntax(transcribed, bodyStx.separator);\n                    }\n                    push.apply(acc, joined);\n                    return acc;\n                }\n                if (!env[bodyStx.token.value]) {\n                    throwSyntaxError('patterns', 'The pattern variable is not bound for the template', bodyStx);\n                } else if (env[bodyStx.token.value].level !== 1) {\n                    throwSyntaxError('patterns', 'Ellipses level does not match in the template', bodyStx);\n                }\n                push.apply(acc, joinRepeatedMatch(env[bodyStx.token.value].match, bodyStx.separator));\n                return acc;\n            } else {\n                if (bodyStx.token.type === parser.Token.Delimiter) {\n                    bodyStx.expose();\n                    var newBody = syntaxFromToken(_.clone(bodyStx.token), macroBody);\n                    newBody.token.inner = transcribe(bodyStx.token.inner, macroNameStx, env);\n                    acc.push(newBody);\n                    return acc;\n                }\n                if (isPatternVar(bodyStx) && Object.prototype.hasOwnProperty.bind(env)(bodyStx.token.value)) {\n                    if (!env[bodyStx.token.value]) {\n                        throwSyntaxError('patterns', 'The pattern variable is not bound for the template', bodyStx);\n                    } else if (env[bodyStx.token.value].level !== 0) {\n                        throwSyntaxError('patterns', 'Ellipses level does not match in the template', bodyStx);\n                    }\n                    push.apply(acc, takeLineContext(bodyStx, env[bodyStx.token.value].match));\n                    return acc;\n                }\n                acc.push(syntaxFromToken(_.clone(bodyStx.token), bodyStx));\n                return acc;\n            }\n        }, []).value();\n    }\n    function cloneMatch(oldMatch) {\n        var newMatch = {\n            success: oldMatch.success,\n            rest: oldMatch.rest,\n            patternEnv: {}\n        };\n        for (var pat in oldMatch.patternEnv) {\n            if (oldMatch.patternEnv.hasOwnProperty(pat)) {\n                newMatch.patternEnv[pat] = oldMatch.patternEnv[pat];\n            }\n        }\n        return newMatch;\n    }\n    function makeIdentityRule(pattern, isInfix, context) {\n        var inf = [];\n        var pat = [];\n        var stx = [];\n        if (isInfix) {\n            for (var i = 0; i < pattern.length; i++) {\n                if (pattern[i].token.type === parser.Token.Punctuator && pattern[i].token.value === '|') {\n                    pat.push(makeIdent('$inf', context), makePunc(':', context), makeDelim('()', inf, context), pattern[0], makeIdent('$id', context), makePunc(':', context), makeDelim('()', pat.slice(i + 1), context));\n                    stx.push(makeIdent('$inf', context), makeIdent('$id', context));\n                    break;\n                }\n                inf.push(pattern[i]);\n            }\n        } else {\n            pat.push(makeIdent('$id', context), makePunc(':', context), makeDelim('()', pattern, context));\n            stx.push(makeIdent('$id', context));\n        }\n        return {\n            pattern: pat,\n            body: stx\n        };\n    }\n    exports$2.loadPattern = loadPattern;\n    exports$2.matchPatterns = matchPatterns;\n    exports$2.matchLookbehind = matchLookbehind;\n    exports$2.transcribe = transcribe;\n    exports$2.matchPatternClass = matchPatternClass;\n    exports$2.takeLineContext = takeLineContext;\n    exports$2.takeLine = takeLine;\n    exports$2.typeIsLiteral = typeIsLiteral;\n    exports$2.cloneMatch = cloneMatch;\n    exports$2.makeIdentityRule = makeIdentityRule;\n}));\n//# sourceMappingURL=patterns.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/patterns.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/patterns.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n    'use strict';\n\n    var Syntax,\n        Precedence,\n        BinaryPrecedence,\n        SourceNode,\n        estraverse,\n        esutils,\n        isArray,\n        base,\n        indent,\n        json,\n        renumber,\n        hexadecimal,\n        quotes,\n        escapeless,\n        newline,\n        space,\n        parentheses,\n        semicolons,\n        safeConcatenation,\n        directive,\n        extra,\n        parse,\n        sourceMap,\n        sourceCode,\n        preserveBlankLines,\n        FORMAT_MINIFY,\n        FORMAT_DEFAULTS;\n\n    estraverse = __webpack_require__(20);\n    esutils = __webpack_require__(21);\n\n    Syntax = estraverse.Syntax;\n\n    // Generation is done by generateExpression.\n    function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n    }\n\n    // Generation is done by generateStatement.\n    function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n    }\n\n    Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Await: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Unary: 13,\n        Postfix: 14,\n        Call: 15,\n        New: 16,\n        TaggedTemplate: 17,\n        Member: 18,\n        Primary: 19\n    };\n\n    BinaryPrecedence = {\n        '||': Precedence.LogicalOR,\n        '&&': Precedence.LogicalAND,\n        '|': Precedence.BitwiseOR,\n        '^': Precedence.BitwiseXOR,\n        '&': Precedence.BitwiseAND,\n        '==': Precedence.Equality,\n        '!=': Precedence.Equality,\n        '===': Precedence.Equality,\n        '!==': Precedence.Equality,\n        'is': Precedence.Equality,\n        'isnt': Precedence.Equality,\n        '<': Precedence.Relational,\n        '>': Precedence.Relational,\n        '<=': Precedence.Relational,\n        '>=': Precedence.Relational,\n        'in': Precedence.Relational,\n        'instanceof': Precedence.Relational,\n        '<<': Precedence.BitwiseSHIFT,\n        '>>': Precedence.BitwiseSHIFT,\n        '>>>': Precedence.BitwiseSHIFT,\n        '+': Precedence.Additive,\n        '-': Precedence.Additive,\n        '*': Precedence.Multiplicative,\n        '%': Precedence.Multiplicative,\n        '/': Precedence.Multiplicative\n    };\n\n    //Flags\n    var F_ALLOW_IN = 1,\n        F_ALLOW_CALL = 1 << 1,\n        F_ALLOW_UNPARATH_NEW = 1 << 2,\n        F_FUNC_BODY = 1 << 3,\n        F_DIRECTIVE_CTX = 1 << 4,\n        F_SEMICOLON_OPT = 1 << 5;\n\n    //Expression flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_ALLOW_CALL\n    // F_ALLOW_UNPARATH_NEW\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TFF = F_ALLOW_IN,\n        E_FFT = F_ALLOW_UNPARATH_NEW,\n        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n\n    //Statement flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_FUNC_BODY\n    // F_DIRECTIVE_CTX\n    // F_SEMICOLON_OPT\n    var S_TFFF = F_ALLOW_IN,\n        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n        S_FFFF = 0x00,\n        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: '    ',\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                newline: '\\n',\n                space: ' ',\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: 'single',\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false,\n                preserveBlankLines: false\n            },\n            moz: {\n                comprehensionExpressionStartsWithAssignment: false,\n                starlessGenerator: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            raw: true,\n            verbatim: null,\n            sourceCode: null\n        };\n    }\n\n    function stringRepeat(str, num) {\n        var result = '';\n\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n            if (num & 1) {\n                result += str;\n            }\n        }\n\n        return result;\n    }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    function hasLineTerminator(str) {\n        return (/[\\r\\n]/g).test(str);\n    }\n\n    function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n    }\n\n    function merge(target, override) {\n        var key;\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                target[key] = override[key];\n            }\n        }\n        return target;\n    }\n\n    function updateDeeply(target, override) {\n        var key, val;\n\n        function isHashObject(target) {\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n\n        if (value !== value) {\n            throw new Error('Numeric literal whose value is NaN');\n        }\n        if (value < 0 || (value === 0 && 1 / value < 0)) {\n            throw new Error('Numeric literal whose value is negative');\n        }\n\n        if (value === 1 / 0) {\n            return json ? 'null' : renumber ? '1e400' : '1e+400';\n        }\n\n        result = '' + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n\n        point = result.indexOf('.');\n        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace('e+', 'e');\n        exponent = 0;\n        if ((pos = temp.indexOf('e')) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n        }\n        pos = 0;\n        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {\n            --pos;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += 'e' + exponent;\n        }\n        if ((temp.length < result.length ||\n                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&\n                +temp === value) {\n            result = temp;\n        }\n\n        return result;\n    }\n\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? 'u' : '\\\\u') + ((ch === 0x2028) ? '2028' : '2029');\n        } else if (ch === 10 || ch === 13) {  // \\n, \\r\n            return (previousIsBackslash ? '' : '\\\\') + ((ch === 10) ? 'n' : 'r');\n        }\n        return String.fromCharCode(ch);\n    }\n\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n\n        result = reg.toString();\n\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n\n            flags = match[1];\n            result = '';\n\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for (i = 0, iz = reg.source.length; i < iz; ++i) {\n                ch = reg.source.charCodeAt(i);\n\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {  // ]\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {  // /\n                            result += '\\\\';\n                        } else if (ch === 91) {  // [\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92;  // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n\n            return '/' + result + '/' + flags;\n        }\n\n        return result;\n    }\n\n    function escapeAllowedCharacter(code, next) {\n        var hex;\n\n        if (code === 0x08  /* \\b */) {\n            return '\\\\b';\n        }\n\n        if (code === 0x0C  /* \\f */) {\n            return '\\\\f';\n        }\n\n        if (code === 0x09  /* \\t */) {\n            return '\\\\t';\n        }\n\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 0xFF) {\n            return '\\\\u' + '0000'.slice(hex.length) + hex;\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n            return '\\\\0';\n        } else if (code === 0x000B  /* \\v */) { // '\\v'\n            return '\\\\x0B';\n        } else {\n            return '\\\\x' + '00'.slice(hex.length) + hex;\n        }\n    }\n\n    function escapeDisallowedCharacter(code) {\n        if (code === 0x5C  /* \\ */) {\n            return '\\\\\\\\';\n        }\n\n        if (code === 0x0A  /* \\n */) {\n            return '\\\\n';\n        }\n\n        if (code === 0x0D  /* \\r */) {\n            return '\\\\r';\n        }\n\n        if (code === 0x2028) {\n            return '\\\\u2028';\n        }\n\n        if (code === 0x2029) {\n            return '\\\\u2029';\n        }\n\n        throw new Error('Incorrectly classified character');\n    }\n\n    function escapeDirective(str) {\n        var i, iz, code, quote;\n\n        quote = quotes === 'double' ? '\"' : '\\'';\n        for (i = 0, iz = str.length; i < iz; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                quote = '\"';\n                break;\n            } else if (code === 0x22  /* \" */) {\n                quote = '\\'';\n                break;\n            } else if (code === 0x5C  /* \\ */) {\n                ++i;\n            }\n        }\n\n        return quote + str + quote;\n    }\n\n    function escapeString(str) {\n        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                ++singleQuotes;\n            } else if (code === 0x22  /* \" */) {\n                ++doubleQuotes;\n            } else if (code === 0x2F  /* / */ && json) {\n                result += '\\\\';\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \\ */) {\n                result += escapeDisallowedCharacter(code);\n                continue;\n            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n                continue;\n            }\n            result += String.fromCharCode(code);\n        }\n\n        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));\n        quote = single ? '\\'' : '\"';\n\n        if (!(single ? singleQuotes : doubleQuotes)) {\n            return quote + result + quote;\n        }\n\n        str = result;\n        result = quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* \" */ && !single)) {\n                result += '\\\\';\n            }\n            result += String.fromCharCode(code);\n        }\n\n        return result + quote;\n    }\n\n    /**\n     * flatten an array to a string, where the array can contain\n     * either strings or nested arrays\n     */\n    function flattenToString(arr) {\n        var i, iz, elem, result = '';\n        for (i = 0, iz = arr.length; i < iz; ++i) {\n            elem = arr[i];\n            result += isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n    }\n\n    /**\n     * convert generated to a SourceNode when source maps are enabled.\n     */\n    function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n            // with no source maps, generated is either an\n            // array or a string.  if an array, flatten it.\n            // if a string, just return it\n            if (isArray(generated)) {\n                return flattenToString(generated);\n            } else {\n                return generated;\n            }\n        }\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);\n    }\n\n    function noEmptySpace() {\n        return (space) ? space : ' ';\n    }\n\n    function join(left, right) {\n        var leftSource,\n            rightSource,\n            leftCharCode,\n            rightCharCode;\n\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n            return [right];\n        }\n\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n            return [left];\n        }\n\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n\n        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||\n            esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||\n            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`\n            return [left, noEmptySpace(), right];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||\n                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n            return [left, right];\n        }\n        return [left, space, right];\n    }\n\n    function addIndent(stmt) {\n        return [base, stmt];\n    }\n\n    function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n    }\n\n    function calculateSpaces(str) {\n        var i;\n        for (i = str.length - 1; i >= 0; --i) {\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n                break;\n            }\n        }\n        return (str.length - 1) - i;\n    }\n\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n\n        // first line doesn't have indentation\n        for (i = 1, len = array.length; i < len; ++i) {\n            line = array[i];\n            j = 0;\n            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n                ++j;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n\n        if (typeof specialBase !== 'undefined') {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === '*') {\n                specialBase += ' ';\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                --spaces;\n            }\n            previousBase = base;\n        }\n\n        for (i = 1, len = array.length; i < len; ++i) {\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n            array[i] = sourceMap ? sn.join('') : sn;\n        }\n\n        base = previousBase;\n\n        return array.join('\\n');\n    }\n\n    function generateComment(comment, specialBase) {\n        if (comment.type === 'Line') {\n            if (endsWithLineTerminator(comment.value)) {\n                return '//' + comment.value;\n            } else {\n                // Always use LineTerminator\n                var result = '//' + comment.value;\n                if (!preserveBlankLines) {\n                    result += '\\n';\n                }\n                return result;\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n        }\n        return '/*' + comment.value + '*/';\n    }\n\n    function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment,\n            extRange, range, prevRange, prefix, infix, suffix, count;\n\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n\n            if (preserveBlankLines) {\n                comment = stmt.leadingComments[0];\n                result = [];\n\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n\n                prevRange = range;\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n                    comment = stmt.leadingComments[i];\n                    range = comment.range;\n\n                    infix = sourceCode.substring(prevRange[1], range[0]);\n                    count = (infix.match(/\\n/g) || []).length;\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n\n                    prevRange = range;\n                }\n\n                suffix = sourceCode.substring(range[1], extRange[1]);\n                count = (suffix.match(/\\n/g) || []).length;\n                result.push(stringRepeat('\\n', count));\n            } else {\n                comment = stmt.leadingComments[0];\n                result = [];\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                    result.push('\\n');\n                }\n                result.push(generateComment(comment));\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push('\\n');\n                }\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n                    comment = stmt.leadingComments[i];\n                    fragment = [generateComment(comment)];\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        fragment.push('\\n');\n                    }\n                    result.push(addIndent(fragment));\n                }\n            }\n\n            result.push(addIndent(save));\n        }\n\n        if (stmt.trailingComments) {\n\n            if (preserveBlankLines) {\n                comment = stmt.trailingComments[0];\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n            } else {\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n                    comment = stmt.trailingComments[i];\n                    if (tailingToStatement) {\n                        // We assume target like following script\n                        //\n                        // var t = 20;  /**\n                        //               * This is comment of t\n                        //               */\n                        if (i === 0) {\n                            // first case\n                            result = [result, indent];\n                        } else {\n                            result = [result, specialBase];\n                        }\n                        result.push(generateComment(comment, specialBase));\n                    } else {\n                        result = [result, addIndent(generateComment(comment))];\n                    }\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result = [result, '\\n'];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    function generateBlankLines(start, end, result) {\n        var j, newlineCount = 0;\n\n        for (j = start; j < end; j++) {\n            if (sourceCode[j] === '\\n') {\n                newlineCount++;\n            }\n        }\n\n        for (j = 1; j < newlineCount; j++) {\n            result.push(newline);\n        }\n    }\n\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return ['(', text, ')'];\n        }\n        return text;\n    }\n\n    function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for (i = 1, iz = result.length; i < iz; i++) {\n            result[i] = newline + base + result[i];\n        }\n        return result;\n    }\n\n    function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n\n        if (typeof verbatim === 'string') {\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n            // verbatim is object\n            result = generateVerbatimString(verbatim.content);\n            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;\n            result = parenthesize(result, prec, precedence);\n        }\n\n        return toSourceNodeWhenNeeded(result, expr);\n    }\n\n    function CodeGenerator() {\n    }\n\n    // Helpers.\n\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n        var result, noLeadingComment, that = this;\n\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [space, this.generateStatement(stmt, flags)];\n        }\n\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return ';';\n        }\n\n        withIndent(function () {\n            result = [\n                newline,\n                addIndent(that.generateStatement(stmt, flags))\n            ];\n        });\n\n        return result;\n    };\n\n    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [result, space];\n        }\n        if (ends) {\n            return [result, base];\n        }\n        return [result, newline, base];\n    };\n\n    function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n    }\n\n    function generateAsyncPrefix(node, spaceRequired) {\n        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n    }\n\n    function generateStarSuffix(node) {\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\n        return isGenerator ? '*' + space : '';\n    }\n\n    function generateMethodPrefix(prop) {\n        var func = prop.value;\n        if (func.async) {\n            return generateAsyncPrefix(func, !prop.computed);\n        } else {\n            // avoid space before method name\n            return generateStarSuffix(func) ? '*' : '';\n        }\n    }\n\n    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n            return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n    };\n\n    CodeGenerator.prototype.generateFunctionParams = function (node) {\n        var i, iz, result, hasDefault;\n\n        hasDefault = false;\n\n        if (node.type === Syntax.ArrowFunctionExpression &&\n                !node.rest && (!node.defaults || node.defaults.length === 0) &&\n                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n            // arg => { } case\n            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n        } else {\n            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n            result.push('(');\n            if (node.defaults) {\n                hasDefault = true;\n            }\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                if (hasDefault && node.defaults[i]) {\n                    // Handle default values.\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n                } else {\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n                }\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n\n            if (node.rest) {\n                if (node.params.length) {\n                    result.push(',' + space);\n                }\n                result.push('...');\n                result.push(generateIdentifier(node.rest));\n            }\n\n            result.push(')');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateFunctionBody = function (node) {\n        var result, expr;\n\n        result = this.generateFunctionParams(node);\n\n        if (node.type === Syntax.ArrowFunctionExpression) {\n            result.push(space);\n            result.push('=>');\n        }\n\n        if (node.expression) {\n            result.push(space);\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n            if (expr.toString().charAt(0) === '{') {\n                expr = ['(', expr, ')'];\n            }\n            result.push(expr);\n        } else {\n            result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n        var result = ['for' + space + '('], that = this;\n        withIndent(function () {\n            if (stmt.left.type === Syntax.VariableDeclaration) {\n                withIndent(function () {\n                    result.push(stmt.left.kind + noEmptySpace());\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n                });\n            } else {\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n            }\n\n            result = join(result, operator);\n            result = [join(\n                result,\n                that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)\n            ), ')'];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n    };\n\n    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n        var result = [];\n\n        if (computed) {\n            result.push('[');\n        }\n\n        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));\n        if (computed) {\n            result.push(']');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n            flags |= F_ALLOW_IN;\n        }\n\n        return parenthesize(\n            [\n                this.generateExpression(left, Precedence.Call, flags),\n                space + operator + space,\n                this.generateExpression(right, Precedence.Assignment, flags)\n            ],\n            Precedence.Assignment,\n            precedence\n        );\n    };\n\n    CodeGenerator.prototype.semicolon = function (flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n            return '';\n        }\n        return ';';\n    };\n\n    // Statements.\n\n    CodeGenerator.Statement = {\n\n        BlockStatement: function (stmt, flags) {\n            var range, content, result = ['{', newline], that = this;\n\n            withIndent(function () {\n                // handle functions without any code\n                if (stmt.body.length === 0 && preserveBlankLines) {\n                    range = stmt.range;\n                    if (range[1] - range[0] > 2) {\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\n                        if (content[0] === '\\n') {\n                            result = ['{'];\n                        }\n                        result.push(content);\n                    }\n                }\n\n                var i, iz, fragment, bodyFlags;\n                bodyFlags = S_TFFF;\n                if (flags & F_FUNC_BODY) {\n                    bodyFlags |= F_DIRECTIVE_CTX;\n                }\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    if (preserveBlankLines) {\n                        // handle spaces before the first line\n                        if (i === 0) {\n                            if (stmt.body[0].leadingComments) {\n                                range = stmt.body[0].leadingComments[0].extendedRange;\n                                content = sourceCode.substring(range[0], range[1]);\n                                if (content[0] === '\\n') {\n                                    result = ['{'];\n                                }\n                            }\n                            if (!stmt.body[0].leadingComments) {\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n                            }\n                        }\n\n                        // handle spaces between lines\n                        if (i > 0) {\n                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                            }\n                        }\n                    }\n\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\n                    } else {\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n                    }\n\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        if (preserveBlankLines && i < iz - 1) {\n                            // don't add a new line if there are leading coments\n                            // in the next statement\n                            if (!stmt.body[i + 1].leadingComments) {\n                                result.push(newline);\n                            }\n                        } else {\n                            result.push(newline);\n                        }\n                    }\n\n                    if (preserveBlankLines) {\n                        // handle spaces after the last line\n                        if (i === iz - 1) {\n                            if (!stmt.body[i].trailingComments) {\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                            }\n                        }\n                    }\n                }\n            });\n\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        BreakStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'break ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'break' + this.semicolon(flags);\n        },\n\n        ContinueStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'continue ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'continue' + this.semicolon(flags);\n        },\n\n        ClassBody: function (stmt, flags) {\n            var result = [ '{', newline], that = this;\n\n            withIndent(function (indent) {\n                var i, iz;\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(newline);\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        ClassDeclaration: function (stmt, flags) {\n            var result, fragment;\n            result  = ['class ' + stmt.id.name];\n            if (stmt.superClass) {\n                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(stmt.body, S_TFFT));\n            return result;\n        },\n\n        DirectiveStatement: function (stmt, flags) {\n            if (extra.raw && stmt.raw) {\n                return stmt.raw + this.semicolon(flags);\n            }\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n\n        DoWhileStatement: function (stmt, flags) {\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.body, result);\n            return join(result, [\n                'while' + space + '(',\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                ')' + this.semicolon(flags)\n            ]);\n        },\n\n        CatchClause: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                var guard;\n\n                result = [\n                    'catch' + space + '(',\n                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n\n                if (stmt.guard) {\n                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n                    result.splice(2, 0, ' if ', guard);\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\n            return result;\n        },\n\n        DebuggerStatement: function (stmt, flags) {\n            return 'debugger' + this.semicolon(flags);\n        },\n\n        EmptyStatement: function (stmt, flags) {\n            return ';';\n        },\n\n        ExportDeclaration: function (stmt, flags) {\n            var result = [ 'export' ], bodyFlags, that = this;\n\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\n\n            // export default HoistableDeclaration[Default]\n            // export default AssignmentExpression[In] ;\n            if (stmt['default']) {\n                result = join(result, 'default');\n                if (isStatement(stmt.declaration)) {\n                    result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n                } else {\n                    result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n                }\n                return result;\n            }\n\n            // export VariableStatement\n            // export Declaration[Default]\n            if (stmt.declaration) {\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            }\n\n            // export * FromClause ;\n            // export ExportClause[NoReference] FromClause ;\n            // export ExportClause ;\n            if (stmt.specifiers) {\n                if (stmt.specifiers.length === 0) {\n                    result = join(result, '{' + space + '}');\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n                } else {\n                    result = join(result, '{');\n                    withIndent(function (indent) {\n                        var i, iz;\n                        result.push(newline);\n                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n                            result.push(indent);\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                            if (i + 1 < iz) {\n                                result.push(',' + newline);\n                            }\n                        }\n                    });\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result.push(newline);\n                    }\n                    result.push(base + '}');\n                }\n\n                if (stmt.source) {\n                    result = join(result, [\n                        'from' + space,\n                        // ModuleSpecifier\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                        this.semicolon(flags)\n                    ]);\n                } else {\n                    result.push(this.semicolon(flags));\n                }\n            }\n            return result;\n        },\n\n        ExpressionStatement: function (stmt, flags) {\n            var result, fragment;\n\n            function isClassPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 5) !== 'class') {\n                    return false;\n                }\n                code = fragment.charCodeAt(5);\n                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n            }\n\n            function isFunctionPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            function isAsyncPrefixed(fragment) {\n                var code, i, iz;\n                if (fragment.slice(0, 5) !== 'async') {\n                    return false;\n                }\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n                    return false;\n                }\n                for (i = 6, iz = fragment.length; i < iz; ++i) {\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n                        break;\n                    }\n                }\n                if (i === iz) {\n                    return false;\n                }\n                if (fragment.slice(i, i + 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(i + 8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\n            // wrap expression with parentheses\n            fragment = toSourceNodeWhenNeeded(result).toString();\n            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression\n                    isClassPrefixed(fragment) ||\n                    isFunctionPrefixed(fragment) ||\n                    isAsyncPrefixed(fragment) ||\n                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {\n                result = ['(', result, ')' + this.semicolon(flags)];\n            } else {\n                result.push(this.semicolon(flags));\n            }\n            return result;\n        },\n\n        ImportDeclaration: function (stmt, flags) {\n            // ES6: 15.2.1 valid import declarations:\n            //     - import ImportClause FromClause ;\n            //     - import ModuleSpecifier ;\n            var result, cursor, that = this;\n\n            // If no ImportClause is present,\n            // this should be `import ModuleSpecifier` so skip `from`\n            // ModuleSpecifier is StringLiteral.\n            if (stmt.specifiers.length === 0) {\n                // import ModuleSpecifier ;\n                return [\n                    'import',\n                    space,\n                    // ModuleSpecifier\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                    this.semicolon(flags)\n                ];\n            }\n\n            // import ImportClause FromClause ;\n            result = [\n                'import'\n            ];\n            cursor = 0;\n\n            // ImportedBinding\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n                result = join(result, [\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                ]);\n                ++cursor;\n            }\n\n            if (stmt.specifiers[cursor]) {\n                if (cursor !== 0) {\n                    result.push(',');\n                }\n\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n                    // NameSpaceImport\n                    result = join(result, [\n                            space,\n                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                    ]);\n                } else {\n                    // NamedImports\n                    result.push(space + '{');\n\n                    if ((stmt.specifiers.length - cursor) === 1) {\n                        // import { ... } from \"...\";\n                        result.push(space);\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                        result.push(space + '}' + space);\n                    } else {\n                        // import {\n                        //    ...,\n                        //    ...,\n                        // } from \"...\";\n                        withIndent(function (indent) {\n                            var i, iz;\n                            result.push(newline);\n                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                                result.push(indent);\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                                if (i + 1 < iz) {\n                                    result.push(',' + newline);\n                                }\n                            }\n                        });\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                            result.push(newline);\n                        }\n                        result.push(base + '}' + space);\n                    }\n                }\n            }\n\n            result = join(result, [\n                'from' + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ]);\n            return result;\n        },\n\n        VariableDeclarator: function (stmt, flags) {\n            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;\n            if (stmt.init) {\n                return [\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n                    space,\n                    '=',\n                    space,\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n                ];\n            }\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n\n        VariableDeclaration: function (stmt, flags) {\n            // VariableDeclarator is typed as Statement,\n            // but joined with comma (not LineTerminator).\n            // So if comment is attached to target node, we should specialize.\n            var result, i, iz, node, bodyFlags, that = this;\n\n            result = [ stmt.kind ];\n\n            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;\n\n            function block() {\n                node = stmt.declarations[0];\n                if (extra.comment && node.leadingComments) {\n                    result.push('\\n');\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                } else {\n                    result.push(noEmptySpace());\n                    result.push(that.generateStatement(node, bodyFlags));\n                }\n\n                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n                    node = stmt.declarations[i];\n                    if (extra.comment && node.leadingComments) {\n                        result.push(',' + newline);\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                    } else {\n                        result.push(',' + space);\n                        result.push(that.generateStatement(node, bodyFlags));\n                    }\n                }\n            }\n\n            if (stmt.declarations.length > 1) {\n                withIndent(block);\n            } else {\n                block();\n            }\n\n            result.push(this.semicolon(flags));\n\n            return result;\n        },\n\n        ThrowStatement: function (stmt, flags) {\n            return [join(\n                'throw',\n                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n            ), this.semicolon(flags)];\n        },\n\n        TryStatement: function (stmt, flags) {\n            var result, i, iz, guardedHandlers;\n\n            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n            result = this.maybeBlockSuffix(stmt.block, result);\n\n            if (stmt.handlers) {\n                // old interface\n                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n                    }\n                }\n            } else {\n                guardedHandlers = stmt.guardedHandlers || [];\n\n                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n                    }\n                }\n\n                // new interface\n                if (stmt.handler) {\n                    if (isArray(stmt.handler)) {\n                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                            if (stmt.finalizer || i + 1 !== iz) {\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                            }\n                        }\n                    } else {\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                        if (stmt.finalizer) {\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\n                        }\n                    }\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n            }\n            return result;\n        },\n\n        SwitchStatement: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                result = [\n                    'switch' + space + '(',\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n                    ')' + space + '{' + newline\n                ];\n            });\n            if (stmt.cases) {\n                bodyFlags = S_TFFF;\n                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        SwitchCase: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                if (stmt.test) {\n                    result = [\n                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                        ':'\n                    ];\n                } else {\n                    result = ['default:'];\n                }\n\n                i = 0;\n                iz = stmt.consequent.length;\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n                    result.push(fragment);\n                    i = 1;\n                }\n\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(newline);\n                }\n\n                bodyFlags = S_TFFF;\n                for (; i < iz; ++i) {\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n                    result.push(fragment);\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            return result;\n        },\n\n        IfStatement: function (stmt, flags) {\n            var result, bodyFlags, semicolonOptional, that = this;\n            withIndent(function () {\n                result = [\n                    'if' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            semicolonOptional = flags & F_SEMICOLON_OPT;\n            bodyFlags = S_TFFF;\n            if (semicolonOptional) {\n                bodyFlags |= F_SEMICOLON_OPT;\n            }\n            if (stmt.alternate) {\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n                result = this.maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n                } else {\n                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n                }\n            } else {\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n            }\n            return result;\n        },\n\n        ForStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = ['for' + space + '('];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\n                    } else {\n                        // F_ALLOW_IN becomes false.\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                        result.push(';');\n                    }\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.test) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n                    result.push(';');\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.update) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n                    result.push(')');\n                } else {\n                    result.push(')');\n                }\n            });\n\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        ForInStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        ForOfStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        LabeledStatement: function (stmt, flags) {\n            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n        },\n\n        Program: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags;\n            iz = stmt.body.length;\n            result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n            bodyFlags = S_TFTF;\n            for (i = 0; i < iz; ++i) {\n                if (!safeConcatenation && i === iz - 1) {\n                    bodyFlags |= F_SEMICOLON_OPT;\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces before the first line\n                    if (i === 0) {\n                        if (!stmt.body[0].leadingComments) {\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n                        }\n                    }\n\n                    // handle spaces between lines\n                    if (i > 0) {\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                        }\n                    }\n                }\n\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n                result.push(fragment);\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    if (preserveBlankLines) {\n                        if (!stmt.body[i + 1].leadingComments) {\n                            result.push(newline);\n                        }\n                    } else {\n                        result.push(newline);\n                    }\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces after the last line\n                    if (i === iz - 1) {\n                        if (!stmt.body[i].trailingComments) {\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                        }\n                    }\n                }\n            }\n            return result;\n        },\n\n        FunctionDeclaration: function (stmt, flags) {\n            return [\n                generateAsyncPrefix(stmt, true),\n                'function',\n                generateStarSuffix(stmt) || noEmptySpace(),\n                generateIdentifier(stmt.id),\n                this.generateFunctionBody(stmt)\n            ];\n        },\n\n        ReturnStatement: function (stmt, flags) {\n            if (stmt.argument) {\n                return [join(\n                    'return',\n                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n                ), this.semicolon(flags)];\n            }\n            return ['return' + this.semicolon(flags)];\n        },\n\n        WhileStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'while' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        WithStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'with' + space + '(',\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        }\n\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\n\n    // Expressions.\n\n    CodeGenerator.Expression = {\n\n        SequenceExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n            if (Precedence.Sequence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            result = [];\n            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            return parenthesize(result, Precedence.Sequence, precedence);\n        },\n\n        AssignmentExpression: function (expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n\n        ArrowFunctionExpression: function (expr, precedence, flags) {\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n\n        ConditionalExpression: function (expr, precedence, flags) {\n            if (Precedence.Conditional < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n                    space + '?' + space,\n                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n                    space + ':' + space,\n                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n                ],\n                Precedence.Conditional,\n                precedence\n            );\n        },\n\n        LogicalExpression: function (expr, precedence, flags) {\n            return this.BinaryExpression(expr, precedence, flags);\n        },\n\n        BinaryExpression: function (expr, precedence, flags) {\n            var result, currentPrecedence, fragment, leftSource;\n            currentPrecedence = BinaryPrecedence[expr.operator];\n\n            if (currentPrecedence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n\n            fragment = this.generateExpression(expr.left, currentPrecedence, flags);\n\n            leftSource = fragment.toString();\n\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {\n                result = [fragment, noEmptySpace(), expr.operator];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n\n            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);\n\n            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||\n            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n                result.push(noEmptySpace());\n                result.push(fragment);\n            } else {\n                result = join(result, fragment);\n            }\n\n            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n                return ['(', result, ')'];\n            }\n            return parenthesize(result, currentPrecedence, precedence);\n        },\n\n        CallExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n            result.push('(');\n            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            result.push(')');\n\n            if (!(flags & F_ALLOW_CALL)) {\n                return ['(', result, ')'];\n            }\n            return parenthesize(result, Precedence.Call, precedence);\n        },\n\n        NewExpression: function (expr, precedence, flags) {\n            var result, length, i, iz, itemFlags;\n            length = expr['arguments'].length;\n\n            // F_ALLOW_CALL becomes false.\n            // F_ALLOW_UNPARATH_NEW may become false.\n            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;\n\n            result = join(\n                'new',\n                this.generateExpression(expr.callee, Precedence.New, itemFlags)\n            );\n\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n                result.push('(');\n                for (i = 0, iz = length; i < iz; ++i) {\n                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + space);\n                    }\n                }\n                result.push(')');\n            }\n\n            return parenthesize(result, Precedence.New, precedence);\n        },\n\n        MemberExpression: function (expr, precedence, flags) {\n            var result, fragment;\n\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];\n\n            if (expr.computed) {\n                result.push('[');\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n                result.push(']');\n            } else {\n                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n                    fragment = toSourceNodeWhenNeeded(result).toString();\n                    // When the following conditions are all true,\n                    //   1. No floating point\n                    //   2. Don't have exponents\n                    //   3. The last character is a decimal digit\n                    //   4. Not hexadecimal OR octal number literal\n                    // we should add a floating point.\n                    if (\n                            fragment.indexOf('.') < 0 &&\n                            !/[eExX]/.test(fragment) &&\n                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&\n                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'\n                            ) {\n                        result.push('.');\n                    }\n                }\n                result.push('.');\n                result.push(generateIdentifier(expr.property));\n            }\n\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n\n        UnaryExpression: function (expr, precedence, flags) {\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n            if (space === '') {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [expr.operator];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n                    rightCharCode = fragment.toString().charCodeAt(0);\n\n                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||\n                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {\n                        result.push(noEmptySpace());\n                        result.push(fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            return parenthesize(result, Precedence.Unary, precedence);\n        },\n\n        YieldExpression: function (expr, precedence, flags) {\n            var result;\n            if (expr.delegate) {\n                result = 'yield*';\n            } else {\n                result = 'yield';\n            }\n            if (expr.argument) {\n                result = join(\n                    result,\n                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)\n                );\n            }\n            return parenthesize(result, Precedence.Yield, precedence);\n        },\n\n        AwaitExpression: function (expr, precedence, flags) {\n            var result = join(\n                expr.delegate ? 'await*' : 'await',\n                this.generateExpression(expr.argument, Precedence.Await, E_TTT)\n            );\n            return parenthesize(result, Precedence.Await, precedence);\n        },\n\n        UpdateExpression: function (expr, precedence, flags) {\n            if (expr.prefix) {\n                return parenthesize(\n                    [\n                        expr.operator,\n                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n                    ],\n                    Precedence.Unary,\n                    precedence\n                );\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n                    expr.operator\n                ],\n                Precedence.Postfix,\n                precedence\n            );\n        },\n\n        FunctionExpression: function (expr, precedence, flags) {\n            var result = [\n                generateAsyncPrefix(expr, true),\n                'function'\n            ];\n            if (expr.id) {\n                result.push(generateStarSuffix(expr) || noEmptySpace());\n                result.push(generateIdentifier(expr.id));\n            } else {\n                result.push(generateStarSuffix(expr) || space);\n            }\n            result.push(this.generateFunctionBody(expr));\n            return result;\n        },\n\n        ExportBatchSpecifier: function (expr, precedence, flags) {\n            return '*';\n        },\n\n        ArrayPattern: function (expr, precedence, flags) {\n            return this.ArrayExpression(expr, precedence, flags);\n        },\n\n        ArrayExpression: function (expr, precedence, flags) {\n            var result, multiline, that = this;\n            if (!expr.elements.length) {\n                return '[]';\n            }\n            multiline = expr.elements.length > 1;\n            result = ['[', multiline ? newline : ''];\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === iz) {\n                            result.push(',');\n                        }\n                    } else {\n                        result.push(multiline ? indent : '');\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n                    }\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push(']');\n            return result;\n        },\n\n        ClassExpression: function (expr, precedence, flags) {\n            var result, fragment;\n            result = ['class'];\n            if (expr.id) {\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n            }\n            if (expr.superClass) {\n                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(expr.body, S_TFFT));\n            return result;\n        },\n\n        MethodDefinition: function (expr, precedence, flags) {\n            var result, fragment;\n            if (expr['static']) {\n                result = ['static' + space];\n            } else {\n                result = [];\n            }\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                fragment = [\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n                    this.generateFunctionBody(expr.value)\n                ];\n            } else {\n                fragment = [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return join(result, fragment);\n        },\n\n        Property: function (expr, precedence, flags) {\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                return [\n                    expr.kind, noEmptySpace(),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            if (expr.shorthand) {\n                return this.generatePropertyKey(expr.key, expr.computed);\n            }\n\n            if (expr.method) {\n                return [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            return [\n                this.generatePropertyKey(expr.key, expr.computed),\n                ':' + space,\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        ObjectExpression: function (expr, precedence, flags) {\n            var multiline, result, fragment, that = this;\n\n            if (!expr.properties.length) {\n                return '{}';\n            }\n            multiline = expr.properties.length > 1;\n\n            withIndent(function () {\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n            });\n\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    return [ '{', space, fragment, space, '}' ];\n                }\n            }\n\n            withIndent(function (indent) {\n                var i, iz;\n                result = [ '{', newline, indent, fragment ];\n\n                if (multiline) {\n                    result.push(',' + newline);\n                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n                        result.push(indent);\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                        if (i + 1 < iz) {\n                            result.push(',' + newline);\n                        }\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        ObjectPattern: function (expr, precedence, flags) {\n            var result, i, iz, multiline, property, that = this;\n            if (!expr.properties.length) {\n                return '{}';\n            }\n\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (property.value.type !== Syntax.Identifier) {\n                    multiline = true;\n                }\n            } else {\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    property = expr.properties[i];\n                    if (!property.shorthand) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = ['{', multiline ? newline : '' ];\n\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    result.push(multiline ? indent : '');\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push('}');\n            return result;\n        },\n\n        ThisExpression: function (expr, precedence, flags) {\n            return 'this';\n        },\n\n        Identifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr);\n        },\n\n        ImportDefaultSpecifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr.id);\n        },\n\n        ImportNamespaceSpecifier: function (expr, precedence, flags) {\n            var result = ['*'];\n            if (expr.id) {\n                result.push(space + 'as' + noEmptySpace() + generateIdentifier(expr.id));\n            }\n            return result;\n        },\n\n        ImportSpecifier: function (expr, precedence, flags) {\n            return this.ExportSpecifier(expr, precedence, flags);\n        },\n\n        ExportSpecifier: function (expr, precedence, flags) {\n            var result = [ expr.id.name ];\n            if (expr.name) {\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(expr.name));\n            }\n            return result;\n        },\n\n        Literal: function (expr, precedence, flags) {\n            var raw;\n            if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            return expr.raw;\n                        }\n                    }\n                } catch (e) {\n                    // not use raw property\n                }\n            }\n\n            if (expr.value === null) {\n                return 'null';\n            }\n\n            if (typeof expr.value === 'string') {\n                return escapeString(expr.value);\n            }\n\n            if (typeof expr.value === 'number') {\n                return generateNumber(expr.value);\n            }\n\n            if (typeof expr.value === 'boolean') {\n                return expr.value ? 'true' : 'false';\n            }\n\n            return generateRegExp(expr.value);\n        },\n\n        GeneratorExpression: function (expr, precedence, flags) {\n            return this.ComprehensionExpression(expr, precedence, flags);\n        },\n\n        ComprehensionExpression: function (expr, precedence, flags) {\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n\n            var result, i, iz, fragment, that = this;\n            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];\n\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result.push(fragment);\n            }\n\n            if (expr.blocks) {\n                withIndent(function () {\n                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                            result = join(result, fragment);\n                        } else {\n                            result.push(fragment);\n                        }\n                    }\n                });\n            }\n\n            if (expr.filter) {\n                result = join(result, 'if' + space);\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n                result = join(result, [ '(', fragment, ')' ]);\n            }\n\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n\n                result = join(result, fragment);\n            }\n\n            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');\n            return result;\n        },\n\n        ComprehensionBlock: function (expr, precedence, flags) {\n            var fragment;\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind, noEmptySpace(),\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\n                ];\n            } else {\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n            }\n\n            fragment = join(fragment, expr.of ? 'of' : 'in');\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n\n            return [ 'for' + space + '(', fragment, ')' ];\n        },\n\n        SpreadElement: function (expr, precedence, flags) {\n            return [\n                '...',\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        TaggedTemplateExpression: function (expr, precedence, flags) {\n            var itemFlags = E_TTF;\n            if (!(flags & F_ALLOW_CALL)) {\n                itemFlags = E_TFF;\n            }\n            var result = [\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n\n        TemplateElement: function (expr, precedence, flags) {\n            // Don't use \"cooked\". Since tagged template can use raw template\n            // representation. So if we do so, it breaks the script semantics.\n            return expr.value.raw;\n        },\n\n        TemplateLiteral: function (expr, precedence, flags) {\n            var result, i, iz;\n            result = [ '`' ];\n            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n                if (i + 1 < iz) {\n                    result.push('${' + space);\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n                    result.push(space + '}');\n                }\n            }\n            result.push('`');\n            return result;\n        },\n\n        ModuleSpecifier: function (expr, precedence, flags) {\n            return this.Literal(expr, precedence, flags);\n        }\n\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n        var result, type;\n\n        type = expr.type || Syntax.Property;\n\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, precedence);\n        }\n\n        result = this[type](expr, precedence, flags);\n\n\n        if (extra.comment) {\n            result = addComments(expr,result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    };\n\n    CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n        var result,\n            fragment;\n\n        result = this[stmt.type](stmt, flags);\n\n        // Attach comments\n\n        if (extra.comment) {\n            result = addComments(stmt, result);\n        }\n\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\\n') {\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n        }\n\n        return toSourceNodeWhenNeeded(result, stmt);\n    };\n\n    function generateInternal(node) {\n        var codegen;\n\n        codegen = new CodeGenerator();\n        if (isStatement(node)) {\n            return codegen.generateStatement(node, S_TFFF);\n        }\n\n        if (isExpression(node)) {\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n\n        throw new Error('Unknown node type: ' + node.type);\n    }\n\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === 'string') {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === 'number') {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === 'string') {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? 'double' : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n            newline = space = indent = base = '';\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        sourceCode = options.sourceCode;\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n        extra = options;\n\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = __webpack_require__(25).SourceNode;\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        }\n\n        result = generateInternal(node);\n\n        if (!sourceMap) {\n            pair = {code: result.toString(), map: null};\n            return options.sourceMapWithCode ? pair : pair.code;\n        }\n\n\n        pair = result.toStringWithSourceMap({\n            file: options.file,\n            sourceRoot: options.sourceMapRoot\n        });\n\n        if (options.sourceContent) {\n            pair.map.setSourceContent(options.sourceMap,\n                                      options.sourceContent);\n        }\n\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n\n        return pair.map.toString();\n    }\n\n    FORMAT_MINIFY = {\n        indent: {\n            style: '',\n            base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: 'auto',\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n    };\n\n    FORMAT_DEFAULTS = getDefaultOptions().format;\n\n    exports.version = __webpack_require__(35).version;\n    exports.generate = generate;\n    exports.attachComments = estraverse.attachComments;\n    exports.Precedence = updateDeeply({}, Precedence);\n    exports.browser = false;\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/escodegen.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/escodegen.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true, define:true*/\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // and plain browser loading,\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.estraverse = {}));\n    }\n}(this, function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        isArray,\n        VisitorOption,\n        VisitorKeys,\n        objectCreate,\n        objectKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function ignoreJSHintError() { }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    ignoreJSHintError(shallowCopy);\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    function lowerBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                i = current + 1;\n                len -= diff + 1;\n            } else {\n                len = diff;\n            }\n        }\n        return i;\n    }\n    ignoreJSHintError(lowerBound);\n\n    objectCreate = Object.create || (function () {\n        function F() { }\n\n        return function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    })();\n\n    objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n            keys.push(key);\n        }\n        return keys;\n    };\n\n    function extend(to, from) {\n        var keys = objectKeys(from), key, i, len;\n        for (i = 0, len = keys.length; i < len; i += 1) {\n            key = keys[i];\n            to[key] = from[key];\n        }\n        return to;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'body', 'superClass'],\n        ClassExpression: ['id', 'body', 'superClass'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportBatchSpecifier: [],\n        ExportDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['id', 'name'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],\n        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['id'],\n        ImportNamespaceSpecifier: ['id'],\n        ImportSpecifier: ['id', 'name'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = visitor.fallback === 'iteration';\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = extend(objectCreate(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = element.wrap || node.type;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = objectKeys(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = element.wrap || node.type;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = objectKeys(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = '1.8.1-dev';\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/estraverse/estraverse.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/estraverse/estraverse.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n(function () {\n    'use strict';\n\n    exports.ast = __webpack_require__(22);\n    exports.code = __webpack_require__(23);\n    exports.keyword = __webpack_require__(24);\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/esutils/lib/utils.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/esutils/lib/utils.js?");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    function isExpression(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'ArrayExpression':\n            case 'AssignmentExpression':\n            case 'BinaryExpression':\n            case 'CallExpression':\n            case 'ConditionalExpression':\n            case 'FunctionExpression':\n            case 'Identifier':\n            case 'Literal':\n            case 'LogicalExpression':\n            case 'MemberExpression':\n            case 'NewExpression':\n            case 'ObjectExpression':\n            case 'SequenceExpression':\n            case 'ThisExpression':\n            case 'UnaryExpression':\n            case 'UpdateExpression':\n                return true;\n        }\n        return false;\n    }\n\n    function isIterationStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'DoWhileStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'WhileStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'BlockStatement':\n            case 'BreakStatement':\n            case 'ContinueStatement':\n            case 'DebuggerStatement':\n            case 'DoWhileStatement':\n            case 'EmptyStatement':\n            case 'ExpressionStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'IfStatement':\n            case 'LabeledStatement':\n            case 'ReturnStatement':\n            case 'SwitchStatement':\n            case 'ThrowStatement':\n            case 'TryStatement':\n            case 'VariableDeclaration':\n            case 'WhileStatement':\n            case 'WithStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isSourceElement(node) {\n      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';\n    }\n\n    function trailingStatement(node) {\n        switch (node.type) {\n        case 'IfStatement':\n            if (node.alternate != null) {\n                return node.alternate;\n            }\n            return node.consequent;\n\n        case 'LabeledStatement':\n        case 'ForStatement':\n        case 'ForInStatement':\n        case 'WhileStatement':\n        case 'WithStatement':\n            return node.body;\n        }\n        return null;\n    }\n\n    function isProblematicIfStatement(node) {\n        var current;\n\n        if (node.type !== 'IfStatement') {\n            return false;\n        }\n        if (node.alternate == null) {\n            return false;\n        }\n        current = node.consequent;\n        do {\n            if (current.type === 'IfStatement') {\n                if (current.alternate == null)  {\n                    return true;\n                }\n            }\n            current = trailingStatement(current);\n        } while (current);\n\n        return false;\n    }\n\n    module.exports = {\n        isExpression: isExpression,\n        isStatement: isStatement,\n        isIterationStatement: isIterationStatement,\n        isSourceElement: isSourceElement,\n        isProblematicIfStatement: isProblematicIfStatement,\n\n        trailingStatement: trailingStatement\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/esutils/lib/ast.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/esutils/lib/ast.js?");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("/*\n  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var Regex, NON_ASCII_WHITESPACES;\n\n    // See `tools/generate-identifier-regex.js`.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return isDecimalDigit(ch) ||    // 0..9\n            (97 <= ch && ch <= 102) ||  // a..f\n            (65 <= ch && ch <= 70);     // A..F\n    }\n\n    function isOctalDigit(ch) {\n        return (ch >= 48 && ch <= 55);   // 0..7\n    }\n\n    // 7.2 White Space\n\n    NON_ASCII_WHITESPACES = [\n        0x1680, 0x180E,\n        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,\n        0x202F, 0x205F,\n        0x3000,\n        0xFEFF\n    ];\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch >= 97 && ch <= 122) ||     // a..z\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch >= 97 && ch <= 122) ||     // a..z\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    module.exports = {\n        isDecimalDigit: isDecimalDigit,\n        isHexDigit: isHexDigit,\n        isOctalDigit: isOctalDigit,\n        isWhiteSpace: isWhiteSpace,\n        isLineTerminator: isLineTerminator,\n        isIdentifierStart: isIdentifierStart,\n        isIdentifierPart: isIdentifierPart\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/esutils/lib/code.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/esutils/lib/code.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var code = __webpack_require__(23);\n\n    function isStrictModeReservedWordES6(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isKeywordES5(id, strict) {\n        // yield should not be treated as keyword under non-strict mode.\n        if (!strict && id === 'yield') {\n            return false;\n        }\n        return isKeywordES6(id, strict);\n    }\n\n    function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n            return true;\n        }\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    function isReservedWordES5(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);\n    }\n\n    function isReservedWordES6(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    function isIdentifierName(id) {\n        var i, iz, ch;\n\n        if (id.length === 0) {\n            return false;\n        }\n\n        ch = id.charCodeAt(0);\n        if (!code.isIdentifierStart(ch) || ch === 92) {  // \\ (backslash)\n            return false;\n        }\n\n        for (i = 1, iz = id.length; i < iz; ++i) {\n            ch = id.charCodeAt(i);\n            if (!code.isIdentifierPart(ch) || ch === 92) {  // \\ (backslash)\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function isIdentifierES5(id, strict) {\n        return isIdentifierName(id) && !isReservedWordES5(id, strict);\n    }\n\n    function isIdentifierES6(id, strict) {\n        return isIdentifierName(id) && !isReservedWordES6(id, strict);\n    }\n\n    module.exports = {\n        isKeywordES5: isKeywordES5,\n        isKeywordES6: isKeywordES6,\n        isReservedWordES5: isReservedWordES5,\n        isReservedWordES6: isReservedWordES6,\n        isRestrictedWord: isRestrictedWord,\n        isIdentifierName: isIdentifierName,\n        isIdentifierES5: isIdentifierES5,\n        isIdentifierES6: isIdentifierES6\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/esutils/lib/keyword.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/esutils/lib/keyword.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = __webpack_require__(26).SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(32).SourceMapConsumer;\nexports.SourceNode = __webpack_require__(34).SourceNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var base64VLQ = __webpack_require__(27);\n  var util = __webpack_require__(29);\n  var ArraySet = __webpack_require__(30).ArraySet;\n  var MappingList = __webpack_require__(31).MappingList;\n\n  /**\n   * An instance of the SourceMapGenerator represents a source map which is\n   * being built incrementally. You may pass an object with the following\n   * properties:\n   *\n   *   - file: The filename of the generated source.\n   *   - sourceRoot: A root for all relative URLs in this source map.\n   */\n  function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, 'file', null);\n    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  SourceMapGenerator.prototype._version = 3;\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  SourceMapGenerator.fromSourceMap =\n    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        var newMapping = {\n          generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }\n        };\n\n        if (mapping.source != null) {\n          newMapping.source = mapping.source;\n          if (sourceRoot != null) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n\n          if (mapping.name != null) {\n            newMapping.name = mapping.name;\n          }\n        }\n\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  SourceMapGenerator.prototype.addMapping =\n    function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, 'generated');\n      var original = util.getArg(aArgs, 'original', null);\n      var source = util.getArg(aArgs, 'source', null);\n      var name = util.getArg(aArgs, 'name', null);\n\n      if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n      }\n\n      if (source != null && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n\n      if (name != null && !this._names.has(name)) {\n        this._names.add(name);\n      }\n\n      this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n      });\n    };\n\n  /**\n   * Set the source content for a source file.\n   */\n  SourceMapGenerator.prototype.setSourceContent =\n    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n      }\n\n      if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  SourceMapGenerator.prototype.applySourceMap =\n    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n      var sourceFile = aSourceFile;\n      // If aSourceFile is omitted, we will use the file property of the SourceMap\n      if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n          throw new Error(\n            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n          );\n        }\n        sourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      // Make \"sourceFile\" relative if an absolute Url is passed.\n      if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n      }\n      // Applying the SourceMap can add and remove items from the sources and\n      // the names array.\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n\n      // Find mappings for the \"sourceFile\"\n      this._mappings.unsortedForEach(function (mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n          // Check if it can be mapped by the source map, then update the mapping.\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          });\n          if (original.source != null) {\n            // Copy mapping\n            mapping.source = original.source;\n            if (aSourceMapPath != null) {\n              mapping.source = util.join(aSourceMapPath, mapping.source)\n            }\n            if (sourceRoot != null) {\n              mapping.source = util.relative(sourceRoot, mapping.source);\n            }\n            mapping.originalLine = original.line;\n            mapping.originalColumn = original.column;\n            if (original.name != null) {\n              mapping.name = original.name;\n            }\n          }\n        }\n\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n          newSources.add(source);\n        }\n\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n          newNames.add(name);\n        }\n\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n\n      // Copy sourcesContents of applied map.\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aSourceMapPath != null) {\n            sourceFile = util.join(aSourceMapPath, sourceFile);\n          }\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  SourceMapGenerator.prototype._validateMapping =\n    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                                aName) {\n      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n          && aGenerated.line > 0 && aGenerated.column >= 0\n          && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n      }\n      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n               && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n               && aGenerated.line > 0 && aGenerated.column >= 0\n               && aOriginal.line > 0 && aOriginal.column >= 0\n               && aSource) {\n        // Cases 2 and 3.\n        return;\n      }\n      else {\n        throw new Error('Invalid mapping: ' + JSON.stringify({\n          generated: aGenerated,\n          source: aSource,\n          original: aOriginal,\n          name: aName\n        }));\n      }\n    };\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  SourceMapGenerator.prototype._serializeMappings =\n    function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = '';\n      var mapping;\n\n      var mappings = this._mappings.toArray();\n\n      for (var i = 0, len = mappings.length; i < len; i++) {\n        mapping = mappings[i];\n\n        if (mapping.generatedLine !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generatedLine !== previousGeneratedLine) {\n            result += ';';\n            previousGeneratedLine++;\n          }\n        }\n        else {\n          if (i > 0) {\n            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {\n              continue;\n            }\n            result += ',';\n          }\n        }\n\n        result += base64VLQ.encode(mapping.generatedColumn\n                                   - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (mapping.source != null) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source)\n                                     - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n\n          // lines are stored 0-based in SourceMap spec version 3\n          result += base64VLQ.encode(mapping.originalLine - 1\n                                     - previousOriginalLine);\n          previousOriginalLine = mapping.originalLine - 1;\n\n          result += base64VLQ.encode(mapping.originalColumn\n                                     - previousOriginalColumn);\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (mapping.name != null) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name)\n                                       - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n\n      return result;\n    };\n\n  SourceMapGenerator.prototype._generateSourcesContent =\n    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n      return aSources.map(function (source) {\n        if (!this._sourcesContents) {\n          return null;\n        }\n        if (aSourceRoot != null) {\n          source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents,\n                                                    key)\n          ? this._sourcesContents[key]\n          : null;\n      }, this);\n    };\n\n  /**\n   * Externalize the source map.\n   */\n  SourceMapGenerator.prototype.toJSON =\n    function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._file != null) {\n        map.file = this._file;\n      }\n      if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n      }\n\n      return map;\n    };\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  SourceMapGenerator.prototype.toString =\n    function SourceMapGenerator_toString() {\n      return JSON.stringify(this);\n    };\n\n  exports.SourceMapGenerator = SourceMapGenerator;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/source-map-generator.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/source-map-generator.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var base64 = __webpack_require__(28);\n\n  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n  // length quantities we use in the source map spec, the first bit is the sign,\n  // the next four bits are the actual value, and the 6th bit is the\n  // continuation bit. The continuation bit tells us whether there are more\n  // digits in this value following this digit.\n  //\n  //   Continuation\n  //   |    Sign\n  //   |    |\n  //   V    V\n  //   101011\n\n  var VLQ_BASE_SHIFT = 5;\n\n  // binary: 100000\n  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n  // binary: 011111\n  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n  // binary: 100000\n  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n  /**\n   * Converts from a two-complement value to a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n   */\n  function toVLQSigned(aValue) {\n    return aValue < 0\n      ? ((-aValue) << 1) + 1\n      : (aValue << 1) + 0;\n  }\n\n  /**\n   * Converts to a two-complement value from a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n   */\n  function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative\n      ? -shifted\n      : shifted;\n  }\n\n  /**\n   * Returns the base 64 VLQ encoded value.\n   */\n  exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n\n    var vlq = toVLQSigned(aValue);\n\n    do {\n      digit = vlq & VLQ_BASE_MASK;\n      vlq >>>= VLQ_BASE_SHIFT;\n      if (vlq > 0) {\n        // There are still more digits in this value, so we must make sure the\n        // continuation bit is marked.\n        digit |= VLQ_CONTINUATION_BIT;\n      }\n      encoded += base64.encode(digit);\n    } while (vlq > 0);\n\n    return encoded;\n  };\n\n  /**\n   * Decodes the next base 64 VLQ value from the given string and returns the\n   * value and the rest of the string via the out parameter.\n   */\n  exports.decode = function base64VLQ_decode(aStr, aOutParam) {\n    var i = 0;\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n\n    do {\n      if (i >= strLen) {\n        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n      }\n      digit = base64.decode(aStr.charAt(i++));\n      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n      digit &= VLQ_BASE_MASK;\n      result = result + (digit << shift);\n      shift += VLQ_BASE_SHIFT;\n    } while (continuation);\n\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aStr.slice(i);\n  };\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/base64-vlq.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/base64-vlq.js?");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var charToIntMap = {};\n  var intToCharMap = {};\n\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    .split('')\n    .forEach(function (ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n\n  /**\n   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n   */\n  exports.encode = function base64_encode(aNumber) {\n    if (aNumber in intToCharMap) {\n      return intToCharMap[aNumber];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n  };\n\n  /**\n   * Decode a single base 64 digit to an integer.\n   */\n  exports.decode = function base64_decode(aChar) {\n    if (aChar in charToIntMap) {\n      return charToIntMap[aChar];\n    }\n    throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n  };\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/base64.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/base64.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  /**\n   * This is a helper function for getting values from parameter/options\n   * objects.\n   *\n   * @param args The object we are extracting values from\n   * @param name The name of the property we are getting.\n   * @param defaultValue An optional value to return if the property is missing\n   * from the object. If this is not specified and the property is missing, an\n   * error will be thrown.\n   */\n  function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n      return aArgs[aName];\n    } else if (arguments.length === 3) {\n      return aDefaultValue;\n    } else {\n      throw new Error('\"' + aName + '\" is a required argument.');\n    }\n  }\n  exports.getArg = getArg;\n\n  var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n  var dataUrlRegexp = /^data:.+\\,.+$/;\n\n  function urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n      return null;\n    }\n    return {\n      scheme: match[1],\n      auth: match[2],\n      host: match[3],\n      port: match[4],\n      path: match[5]\n    };\n  }\n  exports.urlParse = urlParse;\n\n  function urlGenerate(aParsedUrl) {\n    var url = '';\n    if (aParsedUrl.scheme) {\n      url += aParsedUrl.scheme + ':';\n    }\n    url += '//';\n    if (aParsedUrl.auth) {\n      url += aParsedUrl.auth + '@';\n    }\n    if (aParsedUrl.host) {\n      url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n      url += \":\" + aParsedUrl.port\n    }\n    if (aParsedUrl.path) {\n      url += aParsedUrl.path;\n    }\n    return url;\n  }\n  exports.urlGenerate = urlGenerate;\n\n  /**\n   * Normalizes a path, or the path portion of a URL:\n   *\n   * - Replaces consequtive slashes with one slash.\n   * - Removes unnecessary '.' parts.\n   * - Removes unnecessary '<dir>/..' parts.\n   *\n   * Based on code in the Node.js 'path' core module.\n   *\n   * @param aPath The path or url to normalize.\n   */\n  function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n      if (!url.path) {\n        return aPath;\n      }\n      path = url.path;\n    }\n    var isAbsolute = (path.charAt(0) === '/');\n\n    var parts = path.split(/\\/+/);\n    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n      part = parts[i];\n      if (part === '.') {\n        parts.splice(i, 1);\n      } else if (part === '..') {\n        up++;\n      } else if (up > 0) {\n        if (part === '') {\n          // The first part is blank if the path is absolute. Trying to go\n          // above the root is a no-op. Therefore we can remove all '..' parts\n          // directly after the root.\n          parts.splice(i + 1, up);\n          up = 0;\n        } else {\n          parts.splice(i, 2);\n          up--;\n        }\n      }\n    }\n    path = parts.join('/');\n\n    if (path === '') {\n      path = isAbsolute ? '/' : '.';\n    }\n\n    if (url) {\n      url.path = path;\n      return urlGenerate(url);\n    }\n    return path;\n  }\n  exports.normalize = normalize;\n\n  /**\n   * Joins two paths/URLs.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be joined with the root.\n   *\n   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n   *   first.\n   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n   *   is updated with the result and aRoot is returned. Otherwise the result\n   *   is returned.\n   *   - If aPath is absolute, the result is aPath.\n   *   - Otherwise the two paths are joined with a slash.\n   * - Joining for example 'http://' and 'www.example.com' is also supported.\n   */\n  function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n    if (aPath === \"\") {\n      aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n      aRoot = aRootUrl.path || '/';\n    }\n\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n      if (aRootUrl) {\n        aPathUrl.scheme = aRootUrl.scheme;\n      }\n      return urlGenerate(aPathUrl);\n    }\n\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n      return aPath;\n    }\n\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n      aRootUrl.host = aPath;\n      return urlGenerate(aRootUrl);\n    }\n\n    var joined = aPath.charAt(0) === '/'\n      ? aPath\n      : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n    if (aRootUrl) {\n      aRootUrl.path = joined;\n      return urlGenerate(aRootUrl);\n    }\n    return joined;\n  }\n  exports.join = join;\n\n  /**\n   * Make a path relative to a URL or another path.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be made relative to aRoot.\n   */\n  function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n\n    aRoot = aRoot.replace(/\\/$/, '');\n\n    // XXX: It is possible to remove this block, and the tests still pass!\n    var url = urlParse(aRoot);\n    if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n      return aPath.slice(1);\n    }\n\n    return aPath.indexOf(aRoot + '/') === 0\n      ? aPath.substr(aRoot.length + 1)\n      : aPath;\n  }\n  exports.relative = relative;\n\n  /**\n   * Because behavior goes wacky when you set `__proto__` on objects, we\n   * have to prefix all the strings in our set with an arbitrary character.\n   *\n   * See https://github.com/mozilla/source-map/pull/31 and\n   * https://github.com/mozilla/source-map/issues/30\n   *\n   * @param String aStr\n   */\n  function toSetString(aStr) {\n    return '$' + aStr;\n  }\n  exports.toSetString = toSetString;\n\n  function fromSetString(aStr) {\n    return aStr.substr(1);\n  }\n  exports.fromSetString = fromSetString;\n\n  function strcmp(aStr1, aStr2) {\n    var s1 = aStr1 || \"\";\n    var s2 = aStr2 || \"\";\n    return (s1 > s2) - (s1 < s2);\n  }\n\n  /**\n   * Comparator between two mappings where the original positions are compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same original source/line/column, but different generated\n   * line and column the same. Useful when searching for a mapping with a\n   * stubbed out mapping.\n   */\n  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp || onlyCompareOriginal) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.name, mappingB.name);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    return mappingA.generatedColumn - mappingB.generatedColumn;\n  };\n  exports.compareByOriginalPositions = compareByOriginalPositions;\n\n  /**\n   * Comparator between two mappings where the generated positions are\n   * compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same generated line and column, but different\n   * source/name/original line and column the same. Useful when searching for a\n   * mapping with a stubbed out mapping.\n   */\n  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp;\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp || onlyCompareGenerated) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp) {\n      return cmp;\n    }\n\n    return strcmp(mappingA.name, mappingB.name);\n  };\n  exports.compareByGeneratedPositions = compareByGeneratedPositions;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/util.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/util.js?");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var util = __webpack_require__(29);\n\n  /**\n   * A data structure which is a combination of an array and a set. Adding a new\n   * member is O(1), testing for membership is O(1), and finding the index of an\n   * element is O(1). Removing elements from the set is not supported. Only\n   * strings are supported for membership.\n   */\n  function ArraySet() {\n    this._array = [];\n    this._set = {};\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for (var i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  };\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var isDuplicate = this.has(aStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set[util.toSetString(aStr)] = idx;\n    }\n  };\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.has = function ArraySet_has(aStr) {\n    return Object.prototype.hasOwnProperty.call(this._set,\n                                                util.toSetString(aStr));\n  };\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (this.has(aStr)) {\n      return this._set[util.toSetString(aStr)];\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  };\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n  };\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n  };\n\n  exports.ArraySet = ArraySet;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/array-set.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/array-set.js?");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var util = __webpack_require__(29);\n\n  /**\n   * Determine whether mappingB is after mappingA with respect to generated\n   * position.\n   */\n  function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA ||\n           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;\n  }\n\n  /**\n   * A data structure to provide a sorted view of accumulated mappings in a\n   * performance conscious manner. It trades a neglibable overhead in general\n   * case for a large speedup in case of mappings being added in order.\n   */\n  function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  MappingList.prototype.unsortedForEach =\n    function MappingList_forEach(aCallback, aThisArg) {\n      this._array.forEach(aCallback, aThisArg);\n    };\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  MappingList.prototype.add = function MappingList_add(aMapping) {\n    var mapping;\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  };\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositions);\n      this._sorted = true;\n    }\n    return this._array;\n  };\n\n  exports.MappingList = MappingList;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/mapping-list.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/mapping-list.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var util = __webpack_require__(29);\n  var binarySearch = __webpack_require__(33);\n  var ArraySet = __webpack_require__(30).ArraySet;\n  var base64VLQ = __webpack_require__(27);\n\n  /**\n   * A SourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: Optional. The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    sources = sources.map(util.normalize);\n\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this.file = file;\n  }\n\n  /**\n   * Create a SourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @returns SourceMapConsumer\n   */\n  SourceMapConsumer.fromSourceMap =\n    function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(SourceMapConsumer.prototype);\n\n      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                              smc.sourceRoot);\n      smc.file = aSourceMap._file;\n\n      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();\n      smc.__originalMappings = aSourceMap._mappings.toArray().slice()\n        .sort(util.compareByOriginalPositions);\n\n      return smc;\n    };\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  SourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  });\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n  SourceMapConsumer.prototype.__generatedMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    get: function () {\n      if (!this.__generatedMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__generatedMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype.__originalMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    get: function () {\n      if (!this.__originalMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__originalMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype._nextCharIsMappingSeparator =\n    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n      var c = aStr.charAt(0);\n      return c === \";\" || c === \",\";\n    };\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  SourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var str = aStr;\n      var temp = {};\n      var mapping;\n\n      while (str.length > 0) {\n        if (str.charAt(0) === ';') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        }\n        else if (str.charAt(0) === ',') {\n          str = str.slice(1);\n        }\n        else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n\n          // Generated column.\n          base64VLQ.decode(str, temp);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n\n          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n            // Original source.\n            base64VLQ.decode(str, temp);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source, but no line and column');\n            }\n\n            // Original line.\n            base64VLQ.decode(str, temp);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            // Lines are stored 0-based\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source and line, but no column');\n            }\n\n            // Original column.\n            base64VLQ.decode(str, temp);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n\n            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n              // Original name.\n              base64VLQ.decode(str, temp);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n\n          this.__generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            this.__originalMappings.push(mapping);\n          }\n        }\n      }\n\n      this.__generatedMappings.sort(util.compareByGeneratedPositions);\n      this.__originalMappings.sort(util.compareByOriginalPositions);\n    };\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  SourceMapConsumer.prototype._findMapping =\n    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                           aColumnName, aComparator) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got '\n                            + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got '\n                            + aNeedle[aColumnName]);\n      }\n\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  SourceMapConsumer.prototype.computeColumnSpans =\n    function SourceMapConsumer_computeColumnSpans() {\n      for (var index = 0; index < this._generatedMappings.length; ++index) {\n        var mapping = this._generatedMappings[index];\n\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n          var nextMapping = this._generatedMappings[index + 1];\n\n          if (mapping.generatedLine === nextMapping.generatedLine) {\n            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n            continue;\n          }\n        }\n\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n      }\n    };\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  SourceMapConsumer.prototype.originalPositionFor =\n    function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      var index = this._findMapping(needle,\n                                    this._generatedMappings,\n                                    \"generatedLine\",\n                                    \"generatedColumn\",\n                                    util.compareByGeneratedPositions);\n\n      if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, 'source', null);\n          if (source != null && this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, 'originalLine', null),\n            column: util.getArg(mapping, 'originalColumn', null),\n            name: util.getArg(mapping, 'name', null)\n          };\n        }\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n  SourceMapConsumer.prototype.sourceContentFor =\n    function SourceMapConsumer_sourceContentFor(aSource) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      if (this.sourceRoot != null) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n\n      var url;\n      if (this.sourceRoot != null\n          && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\"\n            && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n        }\n\n        if ((!url.path || url.path == \"/\")\n            && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.generatedPositionFor =\n    function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var index = this._findMapping(needle,\n                                    this._originalMappings,\n                                    \"originalLine\",\n                                    \"originalColumn\",\n                                    util.compareByOriginalPositions);\n\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    };\n\n  /**\n   * Returns all generated line and column information for the original source\n   * and line provided. The only argument is an object with the following\n   * properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.allGeneratedPositionsFor =\n    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n      // When there is no exact match, SourceMapConsumer.prototype._findMapping\n      // returns the index of the closest mapping less than the needle. By\n      // setting needle.originalColumn to Infinity, we thus find the last\n      // mapping for the given line, provided such a mapping exists.\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: Infinity\n      };\n\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var mappings = [];\n\n      var index = this._findMapping(needle,\n                                    this._originalMappings,\n                                    \"originalLine\",\n                                    \"originalColumn\",\n                                    util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        while (mapping && mapping.originalLine === needle.originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[--index];\n        }\n      }\n\n      return mappings.reverse();\n    };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  SourceMapConsumer.prototype.eachMapping =\n    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      var mappings;\n      switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n      }\n\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = mapping.source;\n        if (source != null && sourceRoot != null) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/source-map-consumer.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/source-map-consumer.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next closest element that is less than that element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element which is less than the one we are searching for, so we\n    //      return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // aHaystack[mid] is greater than our needle.\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n      }\n      // We did not find an exact match, return the next closest one\n      // (termination case 2).\n      return mid;\n    }\n    else {\n      // aHaystack[mid] is less than our needle.\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (2) or (3) and return the appropriate thing.\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of next lowest value checked if there is no exact hit. This is\n   * because mappings between original and generated line/col pairs are single\n   * points, and there is an implicit region between each of them, so a miss\n   * just means that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)\n  };\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/binary-search.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/binary-search.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (false) {\n    var define = require('amdefine')(module, require);\n}\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\n  var SourceMapGenerator = __webpack_require__(26).SourceMapGenerator;\n  var util = __webpack_require__(29);\n\n  // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n  // operating systems these days (capturing the result).\n  var REGEX_NEWLINE = /(\\r?\\n)/;\n\n  // Newline character code for charCodeAt() comparisons\n  var NEWLINE_CODE = 10;\n\n  // Private symbol for identifying `SourceNode`s when multiple versions of\n  // the source-map library are loaded. This MUST NOT CHANGE across\n  // versions!\n  var isSourceNode = \"$$$isSourceNode$$$\";\n\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  SourceNode.fromStringWithSourceMap =\n    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode();\n\n      // All even indices of this array are one line of the generated code,\n      // while all odd indices are the newlines between two adjacent lines\n      // (since `REGEX_NEWLINE` captures its match).\n      // Processed fragments are removed from this array, by calling `shiftNextLine`.\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        // The last line of a file might not have a newline.\n        var newLine = remainingLines.shift() || \"\";\n        return lineContents + newLine;\n      };\n\n      // We need to remember the position of \"remainingLines\"\n      var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n      // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n      var lastMapping = null;\n\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping !== null) {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            // Associate first line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn -\n                                          lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                                lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            // No more remaining code, continue\n            lastMapping = mapping;\n            return;\n          }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      // We have processed all mappings.\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          // Associate the remaining code in the current line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.join(\"\"));\n      }\n\n      // Copy sourcesContent into SourceNode\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath\n            ? util.join(aRelativePath, mapping.source)\n            : mapping.source;\n          node.add(new SourceNode(mapping.originalLine,\n                                  mapping.originalColumn,\n                                  source,\n                                  code,\n                                  mapping.name));\n        }\n      }\n    };\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length-1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      }\n      else {\n        if (chunk !== '') {\n          aFn(chunk, { source: this.source,\n                       line: this.line,\n                       column: this.column,\n                       name: this.name });\n        }\n      }\n    }\n  };\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len-1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  };\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    }\n    else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    }\n    else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n  };\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  SourceNode.prototype.setSourceContent =\n    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walkSourceContents =\n    function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0, len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if(lastOriginalSource !== original.source\n           || lastOriginalLine !== original.line\n           || lastOriginalColumn !== original.column\n           || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (var idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map: map };\n  };\n\n  exports.SourceNode = SourceNode;\n\n}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/~/source-map/lib/source-map/source-node.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/~/source-map/lib/source-map/source-node.js?");

/***/ },
/* 35 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"escodegen@1.6.x\",\n\t\t\t\"/home/cs/Projects/rlet/node_modules/sweet.js\"\n\t\t]\n\t],\n\t\"_from\": \"escodegen@>=1.6.0 <1.7.0\",\n\t\"_id\": \"escodegen@1.6.1\",\n\t\"_inCache\": true,\n\t\"_location\": \"/escodegen\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.0.0-alpha-5\",\n\t\"_phantomChildren\": {\n\t\t\"amdefine\": \"1.0.0\"\n\t},\n\t\"_requested\": {\n\t\t\"name\": \"escodegen\",\n\t\t\"raw\": \"escodegen@1.6.x\",\n\t\t\"rawSpec\": \"1.6.x\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=1.6.0 <1.7.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/sweet.js\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz\",\n\t\"_shasum\": \"367de17d8510540d12bc6dcb8b3f918391265815\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"escodegen@1.6.x\",\n\t\"_where\": \"/home/cs/Projects/rlet/node_modules/sweet.js\",\n\t\"bin\": {\n\t\t\"escodegen\": \"./bin/escodegen.js\",\n\t\t\"esgenerate\": \"./bin/esgenerate.js\"\n\t},\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/escodegen/issues\"\n\t},\n\t\"dependencies\": {\n\t\t\"esprima\": \"^1.2.2\",\n\t\t\"estraverse\": \"^1.9.1\",\n\t\t\"esutils\": \"^1.1.6\",\n\t\t\"optionator\": \"^0.5.0\",\n\t\t\"source-map\": \"~0.1.40\"\n\t},\n\t\"description\": \"ECMAScript code generator\",\n\t\"devDependencies\": {\n\t\t\"acorn-6to5\": \"^0.11.1-25\",\n\t\t\"bluebird\": \"^2.3.11\",\n\t\t\"bower-registry-client\": \"^0.2.1\",\n\t\t\"chai\": \"^1.10.0\",\n\t\t\"commonjs-everywhere\": \"^0.9.7\",\n\t\t\"esprima-moz\": \"*\",\n\t\t\"gulp\": \"^3.8.10\",\n\t\t\"gulp-eslint\": \"^0.2.0\",\n\t\t\"gulp-mocha\": \"^2.0.0\",\n\t\t\"semver\": \"^4.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"367de17d8510540d12bc6dcb8b3f918391265815\",\n\t\t\"tarball\": \"http://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.10.0\"\n\t},\n\t\"files\": [\n\t\t\"LICENSE.BSD\",\n\t\t\"LICENSE.source-map\",\n\t\t\"README.md\",\n\t\t\"bin\",\n\t\t\"escodegen.js\",\n\t\t\"package.json\"\n\t],\n\t\"gitHead\": \"1ca664f68dcf220b76c9dc562b2337c5e0b4227d\",\n\t\"homepage\": \"http://github.com/estools/escodegen\",\n\t\"installable\": true,\n\t\"licenses\": [\n\t\t{\n\t\t\t\"type\": \"BSD\",\n\t\t\t\"url\": \"http://github.com/estools/escodegen/raw/master/LICENSE.BSD\"\n\t\t}\n\t],\n\t\"main\": \"escodegen.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t}\n\t],\n\t\"name\": \"escodegen\",\n\t\"optionalDependencies\": {\n\t\t\"source-map\": \"~0.1.40\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"http://github.com/estools/escodegen.git\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"cjsify -a path: tools/entry-point.js > escodegen.browser.js\",\n\t\t\"build-min\": \"cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js\",\n\t\t\"lint\": \"gulp lint\",\n\t\t\"release\": \"node tools/release.js\",\n\t\t\"test\": \"gulp travis\",\n\t\t\"unit-test\": \"gulp test\"\n\t},\n\t\"version\": \"1.6.1\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escodegen/package.json\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escodegen/package.json?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./es6-module-loader\": 37,\n\t\"./es6-module-loader.js\": 37,\n\t\"./esprima-es6\": 38,\n\t\"./esprima-es6.js\": 38,\n\t\"./expander\": 14,\n\t\"./expander.js\": 14,\n\t\"./parser\": 13,\n\t\"./parser.js\": 13,\n\t\"./patterns\": 18,\n\t\"./patterns.js\": 18,\n\t\"./scopedEval\": 17,\n\t\"./scopedEval.js\": 17,\n\t\"./sjs\": 40,\n\t\"./sjs.js\": 40,\n\t\"./sweet\": 44,\n\t\"./sweet.js\": 44,\n\t\"./syntax\": 16,\n\t\"./syntax.js\": 16\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 36;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib ^\\.\\/.*$\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib_^\\.\\/.*$?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n * es6-module-loader\n * https://github.com/addyosmani/es6-module-loader\n *\n * Copyright (c) 2013 Guy Bedford, Luke Hoban, Addy Osmani\n * Licensed under the MIT license.\n */\n\n(function (root, factory) {\n    if (true) {\n        // CommonJS\n        factory(exports, false, __webpack_require__(38));\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports', true, 'esprima-es6'], factory);\n    }\n}(this, function(exports, inBrowser, esprima) {\n\n    // new Loader( options ) - Module loader constructor\n    // The Loader constructor creates a new loader. The argument is the\n    // options object\n    //\n    // options.global - The loader's global object\n    // options.intrinsics - The loader's intrinsic methods\n    // options.strict -  should code evaluated in the loader be in strict mode?\n    // options.normalize( request [, referer] ) - normalize hook\n    // options.resolve( normalized, { referer, metadata } ) - The URL resolution hook\n    // options.fetch( resolved, fulfill, reject, { normalized, referer, metadata } ) - The module loading hook\n    // options.translate( source, { normalized, address, metadata, type } ) - source translation hook\n    // options.link( source, { normalized, address, metadata, type } ) - the link hook\n    function Loader(options) {\n\n        // Initialization of loader state from options\n\n        // the global prototype chain is:\n        // global instance (this._global) -> intrinsics (this._intrinsics) -> initial global (options.global = window)\n        // global instance is created fresh to have this chain\n        // also sets global.window = global for full global encapsulation\n        \n        // Object.create(window) doesn't work...\n        var Global = function () {}\n        Global.prototype = options.global || window;\n        this._builtins = new Global();\n\n        // some standard builtins can't work through this prototype\n        // structure so we need to wrap them to allow this global\n        // abstraction layer\n        var wrapped = {};\n        var wrap = ['addEventListener', 'removeEventListener', 'getComputedStyle', 'setTimeout', 'setInterval'];\n        for (var i = 0; i < wrap.length; i++) (function (name) {\n            wrapped[name] = function () {\n                return window[name].apply(window, arguments);\n            }\n        })(wrap[i]);\n\n        this.defineBuiltins(wrapped);\n\n        Global = function () {}\n        Global.prototype = this._builtins;\n        this._global = new Global();\n\n        Object.defineProperty(this._global, 'window', { value: this._global });\n\n        this._strict = !!options.strict;\n        this.normalize = options.normalize || exports.System.normalize;\n        this.resolve = options.resolve || exports.System.resolve;\n        this.fetch = options.fetch || exports.System.fetch;\n        this.translate = options.translate || exports.System.translate;\n        this.link = options.link || exports.System.link;\n\n        // The internal table of module instance objects\n        this._mios = {};\n\n        // the internal table of loaded scripts\n        this._sloaded = {};\n        \n        // modules currently loading\n        // key is normalized name, value is an array of callback functions to be queued (optional)\n        this._mloads = {};\n        // scripts \n        this._sloads = {};\n    }\n\n\n    Object.defineProperty(Loader.prototype, \"global\", {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            return this._global;\n        }\n    });\n\n    // Loader.prototype.load( address, callback, errback [, referer = null] )\n    //\n    // The load method takes a string representing a module URL and a\n    // callback that receives the result of loading, compiling, and\n    // executing the module at that URL. The compiled code is statically\n    // associated with this loader, and its URL is the given URL. The\n    // additional callback is used if an error occurs.\n    //\n    // load will handle import statements, but export statements are a\n    // syntax error\n    Loader.prototype.load = function (url, callback, errback) {\n        var self = this;\n        if (url instanceof Array) {\n            var scriptCnt = 0;\n            for (var i = 0; i < url.length; i++) (function (i) {\n                self.load(url[i], function () {\n                    scriptCnt++;\n                    if (scriptCnt == url.length) {\n                        callback && callback();\n                    }\n                }, errback)\n            })(i);\n            return;\n        }\n\n        if (this._sloaded[url]) {\n            callback && callback();\n            return;\n        }\n\n        // store the callbacks in a load queue for multiple requests\n        if (this._sloads[url]) {\n            this._sloads[url].push({\n                callback: callback,\n                errback: errback\n            });\n            return;\n        }\n        else {\n            this._sloads[url] = [{\n                callback: callback, \n                errback: errback\n            }];\n        }\n        var _callback = function() {\n            for (var i = 0; i < self._sloads[url].length; i++)\n                self._sloads[url][i].callback && self._sloads[url][i].callback();\n            delete self._sloads[url];\n        }\n        var _errback = function(err) {\n            var allCalled = true;\n            for (var i = 0; i < self._sloads[url].length; i++) {\n                if (self._sloads[url][i].errback) {\n                    self._sloads[url][i].errback(err);\n                }\n                else {\n                    allCalled = false;\n                }\n            }\n            delete self._sloads[url];\n            // if any didn't have an error handler, throw\n            if (!allCalled)\n                throw err;\n        }\n\n        this.fetch(url, function (source) {\n            var opt = {\n                address: url,\n                type: 'script'\n            };\n            source = self.translate(source, opt);\n\n            self._linkExecute(url, source, opt, _callback, _errback, true);\n        }, _errback);\n    };\n\n    // Loader.prototype.import( name, callback, errback, referer = null )\n    // Asynchronously load a module or sequence of modules by name.\n    Loader.prototype.import = function (name, callback, errback, referer) {\n        var self = this;\n        if (name instanceof Array) {\n            var modules = [];\n            var moduleCnt = 0;\n            var self = this;\n            for (var i = 0; i < name.length; i++) (function(i) {\n                self.import(name[i], function(m) {\n                    modules[i] = m;\n                    moduleCnt++;\n                    if (moduleCnt == name.length) {\n                        callback && callback.apply(null, modules);\n                    }\n                }, errback, referer);\n            })(i);\n            return;\n        }\n\n        name = this.normalize(name, referer);\n\n        var opt = {\n            referer: referer,\n            metadata: typeof name == 'object' ? name.metadata : null\n        };\n        // name is now the normalized name in this function\n        if (typeof name != 'string') {\n            name = name.normalized;\n        }\n\n        if (this._mios[name]) {\n            return callback && callback(this._mios[name]);\n        }\n\n        // store the callbacks in a load queue for multiple requests\n        if (this._mloads[name]) {\n            this._mloads[name].push({\n                callback: callback,\n                errback: errback\n            });\n            return;\n        }\n        else {\n            this._mloads[name] = [{\n                callback: callback, \n                errback: errback\n            }];\n        }\n        var _callback = function(module) {\n            self._mios[name] = module;\n            for (var i = 0; i < self._mloads[name].length; i++)\n                self._mloads[name][i].callback && self._mloads[name][i].callback(module);\n            delete self._mloads[name];\n        }\n        var _errback = function(err) {\n            var allCalled = true;\n            if (!self._mloads[name])\n                throw err;\n            for (var i = 0; i < self._mloads[name].length; i++) {\n                if (self._mloads[name][i].errback) {\n                    self._mloads[name][i].errback(err);\n                }\n                else {\n                    allCalled = false;\n                }\n            }\n            delete self._mloads[name];\n            // if any didn't have an error handler, throw\n            if (!allCalled)\n                throw err;\n        }\n\n        var url = this.resolve(name, opt);\n\n        if (typeof url != 'string') {\n            url = url.address;\n            // NB what to do with 'extra'?\n        }\n\n        opt.normalized = name;\n\n        this.fetch(url, function(source) {\n            opt.address = url;\n            opt.type = 'module';\n            source = self.translate(source, opt);\n            self._linkExecute(name, source, opt, _callback, _errback);\n        }, _errback, opt);\n    };\n\n    // Loader.prototype.fetch\n    // NB spec issue here - this clashes with the instance fetch function!?\n\n    // _linkExecute - private function\n    // given a normalized module name, the source, and the options metadata\n    // run the link and execute hooks, with the callback returning the \n    // defined module object\n    // isScript = true implies loading a script so don't define exports\n    var evalCnt = 0;\n    Loader.prototype._linkExecute = function (name, source, opt, callback, errback) {\n        // when no name is given,\n        // provide a unique name to cache the syntax tree parsing\n        if (!name) {\n            name = '__eval' + evalCnt++;\n        }\n\n        var isScript = opt.type == 'script';\n\n        var link = this.link(source, opt);\n\n        // 1. module\n        if (link instanceof Module && !isScript) {\n            return callback(link);\n        }\n\n        // preload esprima if necessary\n        var self = this;\n        ES6Parser.loadEsprima(name, source, function() {\n            var imports, execute;\n            // 2. specified imports and execute\n            if (typeof link == 'object' && !isScript) {\n                imports = link.imports;\n                execute = link.execute;\n            }\n            // 3. undefined -> default\n            else\n                imports = ES6Parser.parseImports(name, source);\n\n            // stops an unnecessary load cascade\n            if (errback.called)\n                return;\n\n            var _source = source;\n            var normalizeMap = {};\n            execute = execute || function() {\n                var exports;\n                // parses export statements and evaluates in the correct context\n                // returning the exports object\n                exports = ES6Parser.parseEval(_source, self, {\n                    name: name, \n                    normalizeMap: normalizeMap,\n                    sourceURL: opt.address, \n                    isEval: isScript\n                });\n                // only return exports for a module when not doing script eval\n                if (name && !isScript)\n                    return new Module(exports || {});\n            }\n\n            if (!imports.length)\n                return callback(execute.call(self));\n\n            var deps = [];\n            var depCnt = 0;\n            for (var i = 0; i < imports.length; i++) (function(i) {\n                var referer = { name: name, address: opt.address };\n\n                // run the normalization to get the canonical module name\n                // to allow imports to be loaded\n                var normalized = self.normalize(imports[i], referer);\n\n                if (typeof normalized == 'object')\n                    normalized = normalized.normalized;\n\n                normalizeMap[imports[i]] = normalized;\n\n                self.import(imports[i], function (module) {\n                    depCnt++;\n                    deps[i] = module;\n                    if (depCnt == imports.length) {\n                        try {\n                            var output = execute.apply(self, deps);\n                            callback(output);\n                        }\n                        catch(e) {\n                            errback(e);\n                            return;\n                        }\n                    }\n                }, errback, referer);\n            })(i);\n\n        }, errback);\n    };\n\n\n    // Loader.prototype.eval( source )\n    // Synchronously executes a Script non-terminal. \n    // If the compilation process results in a fetch, a SyntaxError is thrown.\n    // The compiled code is statically associated with this loader.\n    Loader.prototype.eval = function (source) {\n        ES6Parser.parseEval(source, this, {\n            isEval: true\n        });\n    };\n\n    // Loader.prototype.parseEval( source )\n    // Asynchronously executes a Script non-terminal.\n    // The compiled code is statically associated with this loader.\n    Loader.prototype.evalAsync = function (source, callback, errback) {\n        // links and then evals\n        this._linkExecute(null, source, { type: 'script' }, callback || function() {}, errback || function() {});\n    }\n\n    // Loader.prototype.get ( name )\n    //\n    // Look up a module in the loader’s registry, using a name that is assumed \n    // to be normalized.\n    Loader.prototype.get = function (name) {\n        return this._mios[name] || null;\n    };\n\n\n    // Loader.prototype.set( name, mod )\n    //\n    // Stores (possibly overwriting) a module instance object \n    // in the loader’s registry, using a name that is assumed to be normalized.\n    Loader.prototype.set = function (name, mod) {\n        this._mios[name] = new Module(mod);\n    };\n\n    Loader.prototype.has = function (name) {\n        return !!this._mios[name];\n    };\n\n    Loader.prototype.delete = function (name) {\n        delete this._mios[name];\n    };\n\n    // Loader.prototype.defineBuiltins( [ obj ] )\n    //\n    // The defineBuiltins method takes an object and defines all the built-in\n    // objects and functions of the ES6 standard library associated with this\n    // loader's intrinsics as properties on the object.\n    Loader.prototype.defineBuiltins = function (o) {\n        for (var p in o) {\n            if (o.hasOwnProperty(p)) {\n                this._builtins[p] = o[p];\n            }\n        }\n    };\n\n\n    function Module (o) {\n        \n        if (typeof o != 'object') throw new TypeError(\"Expected object\");\n        \n        if (o instanceof Module) {\n            return o;\n        } else {\n            var self = this;\n            for (var key in o) {\n                (function (key) {\n                    Object.defineProperty(self, key, {\n                        configurable: false,\n                        enumerable: true,\n                        get: function () {\n                            return o[key];\n                        }\n                    });\n                })(key);\n            }\n        }\n    };\n\n\n    // Pre-configured Loader instance for easier use\n    var absUrlRegEx = /^\\/|([^\\:\\/]*:\\/\\/)/;\n    var isUrl = function(name) {\n        return name.substr(name.length - 3, 3) == '.js' || name.match(absUrlRegEx);\n    }\n\n    var defaultSystemLoader;\n    if (inBrowser) {\n        // make a default loader ready for the browser\n        defaultSystemLoader = new Loader({\n            global: window,\n            strict: false,\n            normalize: function(name, referer) {\n                if (isUrl(name))\n                    return name;\n                var parentName = referer && referer.name;\n                if (name.substr(0, 2) == './') {\n                    var parentParts = parentName && parentName.split('/');\n                    if (!parentParts || !parentParts.length)\n                        return name.substr(2);\n                    parentParts.pop();\n                    parentParts.push(name.substr(2));\n                    return parentParts.join('/');\n                }\n                if (name.substr(0, 3) == '../') {\n                    var parentParts = parentName && parentName.split('/');\n                    if (!parentParts || !parentParts.length)\n                        throw \"Path below baseUrl\";\n                    parentParts.pop();\n                    return this.normalize('./' + name.substr(3), { name: parentParts.join('/') });\n                }\n                return name;\n            },\n            resolve: function (name, options) {\n                for (var r in this.ondemandTable)\n                    if (this.ondemandTable[r].indexOf(name) != -1)\n                        return name;\n                if (isUrl(name))\n                    return name;\n                return this.baseURL + (this.baseURL.substr(this.baseURL.length - 1, 1) != '/' ? '/' : '') + name + (name.substr(name.length - 3, 3) == '.js' ? '' : '.js');\n            },\n            fetch: function (url, fulfill, reject, options) {\n                var xhr = new XMLHttpRequest();\n                xhr.onreadystatechange = function () {\n                    if (xhr.readyState === 4) {\n                        if (xhr.status === 200 || (xhr.status == 0 && xhr.responseText)) {\n                            fulfill(xhr.responseText);\n                        } else {\n                            reject(xhr.statusText || 'XHR error');\n                        }\n                    }\n                };\n                xhr.open(\"GET\", url, true);\n                xhr.send(null);\n            },\n            translate: function (source, options) {\n                return source;\n            },\n            link: function (source, options) {}\n        });\n        defaultSystemLoader.baseURL = document.URL.substring(0, window.location.href.lastIndexOf('\\/') + 1);\n        defaultSystemLoader.ondemandTable = {};\n        defaultSystemLoader.ondemand = function (ondemandTable) {\n            for (var r in ondemandTable) {\n                this.ondemandTable[r] = this.ondemandTable[r] || [];\n                if (ondemandTable[r] instanceof Array)\n                    this.ondemandTable[r] = this.ondemandTable[r].concat(ondemandTable[r]);\n                else\n                    this.ondemandTable[r].push(ondemandTable[r]);\n            }\n        }\n    } else {\n        // make a default loader ready for node\n        defaultSystemLoader = new Loader({\n            global: this,\n            strict: true,\n            normalize: function(name, referer) {\n                if (isUrl(name))\n                    return name;\n                var parentName = referer && referer.name;\n                if (name.substr(0, 2) == './') {\n                    var parentParts = parentName && parentName.split('/');\n                    if (!parentParts || !parentParts.length)\n                        return name.substr(2);\n                    parentParts.pop();\n                    parentParts.push(name.substr(2));\n                    return parentParts.join('/');\n                }\n                if (name.substr(0, 3) == '../') {\n                    var parentParts = parentName && parentName.split('/');\n                    if (!parentParts || !parentParts.length)\n                        throw \"Path below baseUrl\";\n                    parentParts.pop();\n                    return this.normalize('./' + name.substr(3), { name: parentParts.join('/') });\n                }\n                return name;\n            },\n            resolve: function (name, options) {\n                if (isUrl(name))\n                    return name;\n                return this.baseURL + (this.baseURL.substr(this.baseURL.length - 1, 1) != '/' ? '/' : '') + name + (name.substr(name.length - 3, 3) == '.js' ? '' : '.js');\n            },\n            fetch: function (url, fulfill, reject, options) {\n                __webpack_require__(39).readFile(url, {encoding: 'utf8'}, function(err, data) {\n                    if (err) {\n                        reject(err);\n                    }\n                    fulfill(data);\n                });\n            },\n            translate: function (source, options) {\n                return source;\n            },\n            link: function (source, options) {}   \n        });\n    }\n\n\n\n\n    // Syntax Parsing and Source Modifying Polyfills\n\n    // esprima-based parser for module syntax, with pluggable polyfill support\n    // var scripts = document.getElementsByTagName('script');\n    // var curScript = scripts[scripts.length - 1];\n    // var esprimaSrc = curScript.getAttribute('data-esprima-src') || curScript.src.substr(0, curScript.src.lastIndexOf('/') + 1) + 'esprima-es6.min.js';\n\n    var ES6Parser = {\n        // iterate the entire syntax tree node object with the given iterator function\n        traverse: function(object, iterator) {\n            var key, child;\n            if (iterator(object) === false)\n                return;\n            for (key in object) {\n                child = object[key];\n                if (typeof child == 'object' && child !== null)\n                    this.traverse(child, iterator);\n            }\n        },\n        // module syntax regexs - may over-classify but not under-classify\n        // simply designed as a first level check to catch any use of\n        // module syntax, before loading esprima for deeper analysis\n        importRegEx: /^\\s*import\\s+./m,\n        exportRegEx: /^\\s*export\\s+(\\{|\\*|var|class|function|default)/m,\n        moduleRegEx: /^\\s*module\\s+(\"[^\"]+\"|'[^']+')\\s*\\{/m,\n        checkModuleSyntax: function(name, source) {\n            if (name == null || this.parseNames[name] === undefined)\n                this.parseNames[name] = source && !!(source.match(this.importRegEx) || source.match(this.exportRegEx) || source.match(this.moduleRegEx));\n            return this.parseNames[name];\n        },\n        loadEsprima: function(name, source, callback, errback) {\n            return callback();\n\n            // // use a regex to check if the source contains 'import', 'export' or 'module' statements\n            // // may incorrectly fire, but the damage is only an http request to do better parsing shortly\n            // if (!this.polyfills.length && !this.checkModuleSyntax(name, source))\n            //     return callback();\n\n            // var self = this;\n            // System.load(esprimaSrc, function() {\n            //     esprima = System.global.esprima;\n            //     callback();\n            // });\n        },\n        // store the names of modules which needed to be parsed by esprima\n        parseNames: {},\n        // store the syntax trees for modules parsed by esprima\n        treeCache: {},\n        // parse the list of import module names for a given source\n        parseImports: function(name, source) {\n            // regex showed no need for esprima -> return empty\n            if (!this.checkModuleSyntax(name, source))\n                return [];\n\n            try {\n                var tree = this.treeCache[name] || (this.treeCache[name] = esprima.parse(source, { range: true }));\n            }\n            catch(e) {\n                e.message = 'Esprima parser error in \"' + name + '\"\\n ' + e.message;\n                throw e;\n            }\n            var imports = [];\n            this.traverse(tree, function(node) {\n\n                if (node.type == 'ImportDeclaration') {\n                    imports.push(node.source.value);\n                }\n                // export * from 'foo';\n                // export { ... } from 'foo';\n                else if (node.type == 'ExportDeclaration' && node.source) {\n                    imports.push(node.source.value);\n                }\n            });\n            return imports;\n        },\n        // allow custom polyfills to be added in the form of syntax functions\n        addPolyfill: function(polyfill) {\n            // by virtue of adding a polyfill, we now load esprima by default\n            this.loadEsprima(null, null, function(){}, function(){});\n            this.polyfills.push(polyfill);\n        },\n        polyfills: [],\n        applyPolyfill: function(node, tSource) {\n            for (var i = 0; i < this.polyfills.length; i++)\n                this.polyfills[i](node, tSource);\n        },\n\n        // runs an eval of code with module syntax\n        // opt = {\n        //   name: name, // normalized module name, used to load cached syntax tree\n        //   normalizeMap: normalizeMap, // normalization map to save having to renormalize again\n        //   sourceURL: opt.address, // used for source map\n        //   isEval: isScript // indicate if exports should be parsed\n        // }\n        // return value is any exports as a plain object\n        parseEval: function(source, loader, opt) {\n\n            // regex showed no need for esprima - normal eval\n            if (!this.polyfills.length && !this.checkModuleSyntax(opt.name, source)) {\n                loader.global.__Loader = loader;\n                scopedEval((loader._strict ? '\"use strict\";\\n' : '') + source, loader.global, opt.sourceURL);\n                delete loader.global.__Loader;\n                return;\n            }\n\n            var tree = this.treeCache[opt.name] || esprima.parse(source, { range: true });\n\n            var normalizeMap = opt.normalizeMap || {};\n\n            var tSource = new SourceModifier(source);\n\n            var self = this;\n            this.traverse(tree, function(node) {\n                \n                // --- Imports ---\n                if (node.type == 'ImportDeclaration') {\n                    var moduleName = normalizeMap[node.source.value] || node.source.value;\n\n                    // import $ from 'jquery';\n                    if (node.kind == 'default') {\n                        tSource.replace(node.range[0], node.range[1], \"var \" + node.specifiers[0].id.name + \" = __Loader.get('\" + moduleName + \"')['default'];\");\n                    }\n\n                    // import { ... } from 'jquery';\n                    else {\n                        var replaceSource = \"var __module = __Loader.get('\" + moduleName + \"');\";\n                        for (var i = 0; i < node.specifiers.length; i++) {\n                            var specifier = node.specifiers[i];\n                            replaceSource += \"var \" + (specifier.name ? specifier.name.name : specifier.id.name) + \" = __module['\" + specifier.id.name + \"'];\";\n                        }\n                        tSource.replace(node.range[0], node.range[1], replaceSource);\n                    }\n                }\n\n                // --- Exports ---\n                else if (node.type == 'ExportDeclaration') {\n\n                    if (node.declaration) {\n\n                        var exportName;\n                        var declarationIndex = node.declaration.range[0] - 1;\n\n                        if (node.declaration.type == 'VariableDeclaration') {\n                            var declaration = node.declaration.declarations[0];\n                            \n                            // export var p = ...\n                            if (declaration.init) {\n                                exportName = declaration.id.name;\n                                declarationIndex = declaration.init.range[0] - 1;\n                            }\n                        }\n\n                        // export function q() {}\n                        // export class q {}\n                        else if (node.declaration.type == 'FunctionDeclaration' || node.declaration.type == 'ClassDeclaration')\n                            exportName = node.declaration.id.name;\n                        \n                        // export default ... overrides any other name\n                        if (node.default)\n                            exportName = 'default';\n\n                        tSource.replace(node.range[0], declarationIndex, \"__exports['\" + exportName + \"'] = \");\n\n                    }\n\n                    else if (node.source) {\n                        var moduleName = normalizeMap[node.source.value] || node.source.value;\n\n                        // export * from 'jquery'\n                        if (node.specifiers[0].type == 'ExportBatchSpecifier') {\n                            tSource.replace(node.range[0], node.range[1], \"var __module = __Loader.get('\" + moduleName + \"'); for (var m in __module) { __exports[m] = __module[m]; }; \");\n                        }\n\n                        // export { a as b, c as d } from 'jquery'\n                        else {\n                            var replaceSource = \"var __module = __Loader.get('\" + moduleName + \"'); \";\n                            for (var i = 0; i < node.specifiers.length; i++) {\n                                var specifier = node.specifiers[i];\n                                replaceSource += \"__exports['\" + (specifier.name ? specifier.name.name : specifier.id.name) + \"'] = __module['\" + specifier.id.name + \"']; \";\n                            }\n                            tSource.replace(node.range[0], node.range[1], replaceSource);\n                        }\n                    }\n\n                    else {\n\n                        // export {a as b, c as d}\n                        var replaceSource = \"\";\n                        for (var i = 0; i < node.specifiers.length; i++) {\n                            var specifier = node.specifiers[i];\n                            replaceSource += \"__exports['\" + specifier.id.name + \"'] = \" + (specifier.name ? specifier.name.name : specifier.id.name) + \"; \";\n                        }\n                        tSource.replace(node.range[0], node.range[1], replaceSource);\n\n                    }\n                }\n\n                // --- Modules ---\n                else if (node.type == 'ModuleDeclaration' && node.body.type == 'BlockStatement') {\n                    // module 'foo' { ..code.. }\n                    // -> (function() { var __exports = {}; ..code.. __Loader.set(\"foo\", new Module(__exports)); })();\n\n                    tSource.replace(node.range[0], node.body.range[0] + 1, \"(function() { var __exports = {}; \");\n                    tSource.replace(node.body.range[1], node.range[1], \" __Loader.set('\" + node.id.name + \"', new Module(__exports)); })();\");\n                }\n\n                // --- Polyfills ---\n                else if (self.polyfills.length)\n                    self.applyPolyfill(node, tSource);\n            });\n\n            delete this.treeCache[opt.name];\n\n            loader.global.__Loader = loader;\n            var exports = loader.global.__exports = {};\n\n            scopedEval((loader._strict ? '\"use strict\";\\n' : '') + tSource.toString(), loader.global, opt.sourceURL);\n\n            delete loader.global.__Loader;\n            delete loader.global.__exports;\n\n            // if exports are defined and it is an eval, throw\n            if (opt.isEval) {\n                for (var e in exports) {\n                    throw 'Exports only supported for modules, not script evaluation.'\n                }\n            }\n\n            return exports;\n        }\n    };\n\n    /*\n     * SourceModifier\n     *\n     * Allows for partial modification of a source file based on successive\n     * range adjustment operations consistent with the original source file\n     *\n     * Example:\n     *                               012345678910\n     *   var h = new SourceModifier('hello world');\n     *   h.replace(2, 4, 'y');\n     *   h.replace(6, 10, 'person');\n     *   h.source == 'hey person';\n     *   h.rangeOps == [{start: 2, end: 4, diff: -2}, {start: 4, end: 9, diff: 1}]\n     *\n     */\n    var SourceModifier = function(source) {\n        this.source = source;\n        this.rangeOps = [];\n    }\n    SourceModifier.prototype = {\n        mapIndex: function(index) {\n            // apply the range operations in order to the index\n            for (var i = 0; i < this.rangeOps.length; i++) {\n                var curOp = this.rangeOps[i];\n                if (curOp.start >= index)\n                    continue;\n                if (curOp.end <= index) {\n                    index += curOp.diff;\n                    continue;\n                }\n                throw 'Source location ' + index + ' has already been transformed!';\n            }\n            return index;\n        },\n        replace: function(start, end, replacement) {\n            var diff = replacement.length - (end - start + 1);\n\n            start = this.mapIndex(start);\n            end = this.mapIndex(end);\n            \n            this.source = this.source.substr(0, start) + replacement + this.source.substr(end + 1);\n\n            this.rangeOps.push({\n                start: start, \n                end: end, \n                diff: diff\n            });\n        },\n        getRange: function(start, end) {\n            return this.source.substr(this.mapIndex(start), this.mapIndex(end));\n        },\n        toString: function() {\n            return this.source;\n        }\n    };\n\n    // Export the Loader class\n    exports.Loader = Loader;\n    // Export the Module class\n    exports.Module = Module;\n    // Export the System object\n    exports.System = defaultSystemLoader;\n\n    // carefully scoped eval with given global\n    var scopedEval = function(source, global, sourceURL) {\n        eval('(function(window) { with(global) { ' + source + ' } }).call(global, global);' +\n             (sourceURL ? '\\n//# sourceURL=' + sourceURL : ''));\n    }\n    \n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/es6-module-loader.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/es6-module-loader.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true,\nparseClassExpression: true, parseClassDeclaration: true, parseExpression: true,\nparseForStatement: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseImportSpecifier: true,\nparseLeftHandSideExpression: true, parseParams: true, validateParam: true,\nparseSpreadOrAssignmentExpression: true,\nparseStatement: true, parseSourceElement: true, parseModuleBlock: true, parseConciseBody: true,\nparseYieldExpression: true\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        ClassPropertyType,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = [\"(\", \"{\", \"[\", \"in\", \"typeof\", \"instanceof\", \"new\",\n                    \"return\", \"case\", \"delete\", \"throw\", \"void\",\n                    // assignment operators\n                    \"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\",\n                    \"&=\", \"|=\", \"^=\", \",\",\n                    // binary/unary operators\n                    \"+\", \"-\", \"*\", \"/\", \"%\", \"++\", \"--\", \"<<\", \">>\", \">>>\", \"&\",\n                    \"|\", \"^\", \"!\", \"~\", \"&&\", \"||\", \"?\", \":\", \"===\", \"==\", \">=\",\n                    \"<=\", \"<\", \">\", \"!=\", \"!==\"];\n\n    Syntax = {\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AssignmentExpression: 'AssignmentExpression',\n        BinaryExpression: 'BinaryExpression',\n        BlockStatement: 'BlockStatement',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ClassHeritage: 'ClassHeritage',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForStatement: 'ForStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportSpecifier: 'ImportSpecifier',\n        LabeledStatement: 'LabeledStatement',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleDeclaration: 'ModuleDeclaration',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    ClassPropertyType = {\n        static: 'static',\n        prototype: 'prototype'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedTemplate:  'Unexpected quasi %0',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n        IllegalReturn: 'Illegal return statement',\n        IllegalYield: 'Illegal yield expression',\n        IllegalSpread: 'Illegal spread element',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n        DefaultRestParameter: 'Rest parameter can not have a default value',\n        ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n        ObjectPatternAsRestParameter: 'Invalid rest parameter',\n        ObjectPatternAsSpread: 'Invalid spread argument',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode',\n        NewlineAfterModule:  'Illegal newline after module',\n        NoFromAfterImport: 'Missing from after import',\n        InvalidModuleSpecifier: 'Invalid module specifier',\n        NestedModule: 'Module declaration can not be nested',\n        NoYieldInGenerator: 'Missing yield in generator',\n        NoUnintializedConst: 'Const must be initialized',\n        ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n        ComprehensionError:  'Comprehension Error',\n        EachNotAllowed:  'Each is not supported'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (lineComment) {\n                ++index;\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === 13 && source.charCodeAt(index) === 10) {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source.charCodeAt(index++);\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    // Block comment ends with '*/' (char #42, char #47).\n                    if (ch === 42) {\n                        ch = source.charCodeAt(index);\n                        if (ch === 47) {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === 47) {\n                ch = source.charCodeAt(index + 1);\n                // Line comment starts with '//' (char #47, char #47).\n                if (ch === 47) {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === 42) {\n                    // Block comment starts with '/*' (char #47, char #42).\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n        // Check for most common single-character punctuators.\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 40) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 123) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '...',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '=' && ch2 === '>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: '=>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch, octal;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    number = '';\n\n                    while (index < length) {\n                        ch = source[index];\n                        if (ch !== '0' && ch !== '1') {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length === 0) {\n                        // only 0b or 0B\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n                    return scanOctalLiteral(ch, start);\n                }\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;\n\n        terminated = false;\n        tail = false;\n        start = index;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            cooked += String.fromCharCode(code);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))\n            },\n            tail: tail,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplateElement(option) {\n        var startsWith, template;\n\n        lookahead = null;\n        skipComment();\n\n        startsWith = (option.head) ? '`' : '}';\n\n        if (source[index] !== startsWith) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        template = scanTemplate();\n\n        peek();\n\n        return template;\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        lookahead = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '\\\\') {\n                    ch = source[index++];\n                    // ECMA-262 7.8.5\n                    if (isLineTerminator(ch.charCodeAt(0))) {\n                        throwError({}, Messages.UnterminatedRegExp);\n                    }\n                    str += ch;\n                } else if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        peek();\n\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return scanRegExp();\n        }\n        if (prevToken.type === \"Punctuator\") {\n            if (prevToken.value === \")\") {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === \"Keyword\" &&\n                        (checkToken.value === \"if\" ||\n                         checkToken.value === \"while\" ||\n                         checkToken.value === \"for\" ||\n                         checkToken.value === \"with\")) {\n                    return scanRegExp();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === \"}\") {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === \"Keyword\") {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === \"Keyword\") {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return scanRegExp();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return scanRegExp();\n            }\n            return scanRegExp();\n        }\n        if (prevToken.type === \"Keyword\") {\n            return scanRegExp();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            return scanStringLiteral();\n        }\n\n        if (ch === 96) {\n            return scanTemplate();\n        }\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function lookahead2() {\n        var adv, pos, line, start, result;\n\n        // If we are collecting the tokens, don't grab the next one yet.\n        adv = (typeof extra.advance === 'function') ? extra.advance : advance;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n\n        // Scan for the next immediate token.\n        if (lookahead === null) {\n            lookahead = adv();\n        }\n        index = lookahead.range[1];\n        lineNumber = lookahead.lineNumber;\n        lineStart = lookahead.lineStart;\n\n        // Grab the token right after.\n        result = adv();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return result;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        postProcess: function (node) {\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createForOfStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForOfStatement,\n                left: left,\n                right: right,\n                body: body,\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value, method, shorthand) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind,\n                method: method,\n                shorthand: shorthand\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        },\n\n        createTemplateElement: function (value, tail) {\n            return {\n                type: Syntax.TemplateElement,\n                value: value,\n                tail: tail\n            };\n        },\n\n        createTemplateLiteral: function (quasis, expressions) {\n            return {\n                type: Syntax.TemplateLiteral,\n                quasis: quasis,\n                expressions: expressions\n            };\n        },\n\n        createSpreadElement: function (argument) {\n            return {\n                type: Syntax.SpreadElement,\n                argument: argument\n            };\n        },\n\n        createTaggedTemplateExpression: function (tag, quasi) {\n            return {\n                type: Syntax.TaggedTemplateExpression,\n                tag: tag,\n                quasi: quasi\n            };\n        },\n\n        createArrowFunctionExpression: function (params, defaults, body, rest, expression) {\n            return {\n                type: Syntax.ArrowFunctionExpression,\n                id: null,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: false,\n                expression: expression\n            };\n        },\n\n        createMethodDefinition: function (propertyType, kind, key, value) {\n            return {\n                type: Syntax.MethodDefinition,\n                key: key,\n                value: value,\n                kind: kind,\n                'static': propertyType === ClassPropertyType.static\n            };\n        },\n\n        createClassBody: function (body) {\n            return {\n                type: Syntax.ClassBody,\n                body: body\n            };\n        },\n\n        createClassExpression: function (id, superClass, body) {\n            return {\n                type: Syntax.ClassExpression,\n                id: id,\n                superClass: superClass,\n                body: body\n            };\n        },\n\n        createClassDeclaration: function (id, superClass, body) {\n            return {\n                type: Syntax.ClassDeclaration,\n                id: id,\n                superClass: superClass,\n                body: body\n            };\n        },\n\n        createExportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ExportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createExportBatchSpecifier: function () {\n            return {\n                type: Syntax.ExportBatchSpecifier\n            };\n        },\n\n        createExportDeclaration: function (def, declaration, specifiers, source) {\n            return {\n                type: Syntax.ExportDeclaration,\n                declaration: declaration,\n                default: def,\n                specifiers: specifiers,\n                source: source\n            };\n        },\n\n        createImportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ImportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createImportDeclaration: function (specifiers, kind, source) {\n            return {\n                type: Syntax.ImportDeclaration,\n                specifiers: specifiers,\n                kind: kind,\n                source: source\n            };\n        },\n\n        createYieldExpression: function (argument, delegate) {\n            return {\n                type: Syntax.YieldExpression,\n                argument: argument,\n                delegate: delegate\n            };\n        },\n\n        createModuleDeclaration: function (id, source, body) {\n            return {\n                type: Syntax.ModuleDeclaration,\n                id: id,\n                source: source,\n                body: body\n            };\n        }\n\n\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        if (token.type === Token.Template) {\n            throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n\n    // Return true if the next token matches the specified contextual keyword\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    function isAssignableLeftHandSide(expr) {\n        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true, body;\n\n        expect('[');\n        while (!match(']')) {\n            if (lookahead.value === 'for' &&\n                    lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                matchKeyword('for');\n                tmp = parseForStatement({ignore_body: true});\n                tmp.of = tmp.type === Syntax.ForOfStatement;\n                tmp.type = Syntax.ComprehensionBlock;\n                if (tmp.left.kind) { // can't be let or const\n                    throwError({}, Messages.ComprehensionError);\n                }\n                blocks.push(tmp);\n            } else if (lookahead.value === 'if' &&\n                           lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                expectKeyword('if');\n                expect('(');\n                filter = parseExpression();\n                expect(')');\n            } else if (lookahead.value === ',' &&\n                           lookahead.type === Token.Punctuator) {\n                possiblecomprehension = false; // no longer allowed.\n                lex();\n                elements.push(null);\n            } else {\n                tmp = parseSpreadOrAssignmentExpression();\n                elements.push(tmp);\n                if (tmp && tmp.type === Syntax.SpreadElement) {\n                    if (!match(']')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n                    expect(','); // this lexes.\n                    possiblecomprehension = false;\n                }\n            }\n        }\n\n        expect(']');\n\n        if (filter && !blocks.length) {\n            throwError({}, Messages.ComprehensionRequiresBlock);\n        }\n\n        if (blocks.length) {\n            if (elements.length !== 1) {\n                throwError({}, Messages.ComprehensionError);\n            }\n            return {\n                type:  Syntax.ComprehensionExpression,\n                filter: filter,\n                blocks: blocks,\n                body: elements[0]\n            };\n        }\n        return delegate.createArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(options) {\n        var previousStrict, previousYieldAllowed, params, defaults, body;\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = options.generator;\n        params = options.params || [];\n        defaults = options.defaults || [];\n\n        body = parseConciseBody();\n        if (options.name && strict && isRestrictedWord(params[0].name)) {\n            throwErrorTolerant(options.name, Messages.StrictParamName);\n        }\n        if (state.yieldAllowed && !state.yieldFound) {\n            throwErrorTolerant({}, Messages.NoYieldInGenerator);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n\n        return delegate.createFunctionExpression(null, params, defaults, body, options.rest || null, options.generator, body.type !== Syntax.BlockStatement);\n    }\n\n\n    function parsePropertyMethodFunction(options) {\n        var previousStrict, tmp, method;\n\n        previousStrict = strict;\n        strict = true;\n\n        tmp = parseParams();\n\n        if (tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, tmp.message);\n        }\n\n\n        method = parsePropertyFunction({\n            params: tmp.params,\n            defaults: tmp.defaults,\n            rest: tmp.rest,\n            generator: options.generator\n        });\n\n        strict = previousStrict;\n\n        return method;\n    }\n\n\n    function parseObjectPropertyKey() {\n        var token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.createLiteral(token);\n        }\n\n        return delegate.createIdentifier(token.value);\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param;\n\n        token = lookahead;\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return delegate.createProperty('get', key, parsePropertyFunction({ generator: false }), false, false);\n            }\n            if (token.value === 'set' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                param = [ parseVariableIdentifier() ];\n                expect(')');\n                return delegate.createProperty('set', key, parsePropertyFunction({ params: param, generator: false, name: token }), false, false);\n            }\n            if (match(':')) {\n                lex();\n                return delegate.createProperty('init', id, parseAssignmentExpression(), false, false);\n            }\n            if (match('(')) {\n                return delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: false }), true, false);\n            }\n            return delegate.createProperty('init', id, id, false, true);\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            if (!match('*')) {\n                throwUnexpected(token);\n            }\n            lex();\n\n            id = parseObjectPropertyKey();\n\n            if (!match('(')) {\n                throwUnexpected(lex());\n            }\n\n            return delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: true }), true, false);\n        }\n        key = parseObjectPropertyKey();\n        if (match(':')) {\n            lex();\n            return delegate.createProperty('init', key, parseAssignmentExpression(), false, false);\n        }\n        if (match('(')) {\n            return delegate.createProperty('init', key, parsePropertyMethodFunction({ generator: false }), true, false);\n        }\n        throwUnexpected(lex());\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectExpression(properties);\n    }\n\n    function parseTemplateElement(option) {\n        var token = scanTemplateElement(option);\n        if (strict && token.octal) {\n            throwError(token, Messages.StrictOctalLiteral);\n        }\n        return delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions;\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return delegate.createTemplateLiteral(quasis, expressions);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        ++state.parenthesizedCount;\n\n        state.allowArrowFunction = !state.allowArrowFunction;\n        expr = parseExpression();\n        state.allowArrowFunction = false;\n\n        if (expr.type !== Syntax.ArrowFunctionExpression) {\n            expect(')');\n        }\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token;\n\n        token = lookahead;\n        type = lookahead.type;\n\n        if (type === Token.Identifier) {\n            lex();\n            return delegate.createIdentifier(token.value);\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            return delegate.createLiteral(lex());\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                return delegate.createThisExpression();\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n\n            if (matchKeyword('super')) {\n                lex();\n                return delegate.createIdentifier('super');\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            return delegate.createLiteral(token);\n        }\n\n        if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            return delegate.createLiteral(token);\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            return delegate.createLiteral(scanRegExp());\n        }\n\n        if (type === Token.Template) {\n            return parseTemplateLiteral();\n        }\n\n        return throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], arg;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                arg = parseSpreadOrAssignmentExpression();\n                args.push(arg);\n\n                if (match(')')) {\n                    break;\n                } else if (arg.type === Syntax.SpreadElement) {\n                    throwError({}, Messages.ElementAfterSpreadElement);\n                }\n\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseSpreadOrAssignmentExpression() {\n        if (match('...')) {\n            lex();\n            return delegate.createSpreadElement(parseAssignmentExpression());\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseNonComputedProperty() {\n        var token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.createIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args;\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.createNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, property;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                expr = delegate.createMemberExpression('[', expr, parseComputedMember());\n            } else if (match('.')) {\n                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());\n            } else {\n                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());\n            }\n        }\n\n        return expr;\n    }\n\n\n    function parseLeftHandSideExpression() {\n        var expr, property;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || lookahead.type === Token.Template) {\n            if (match('[')) {\n                expr = delegate.createMemberExpression('[', expr, parseComputedMember());\n            } else if (match('.')) {\n                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());\n            } else {\n                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr = parseLeftHandSideExpressionAllowCall(),\n            token = lookahead;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            token = lex();\n            expr = delegate.createPostfixExpression(token.value, expr);\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            return delegate.createUnaryExpression(token.value, expr);\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            return delegate.createUnaryExpression(token.value, expr);\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var expr, token, prec, previousAllowIn, stack, right, operator, left, i;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        expr = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return expr;\n        }\n        token.prec = prec;\n        lex();\n\n        stack = [expr, token, parseUnaryExpression()];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                stack.push(delegate.createBinaryExpression(operator, left, right));\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            stack.push(parseUnaryExpression());\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate;\n\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.createConditionalExpression(expr, consequent, alternate);\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function reinterpretAsAssignmentBindingPattern(expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.kind !== 'init') {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n                reinterpretAsAssignmentBindingPattern(property.value);\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsAssignmentBindingPattern(element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            if (isRestrictedWord(expr.name)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        } else if (expr.type === Syntax.SpreadElement) {\n            reinterpretAsAssignmentBindingPattern(expr.argument);\n            if (expr.argument.type === Syntax.ObjectPattern) {\n                throwError({}, Messages.ObjectPatternAsSpread);\n            }\n        } else {\n            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        }\n    }\n\n\n    function reinterpretAsDestructuredParameter(options, expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.kind !== 'init') {\n                    throwError({}, Messages.InvalidLHSInFormalsList);\n                }\n                reinterpretAsDestructuredParameter(options, property.value);\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsDestructuredParameter(options, element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            validateParam(options, expr, expr.name);\n        } else {\n            if (expr.type !== Syntax.MemberExpression) {\n                throwError({}, Messages.InvalidLHSInFormalsList);\n            }\n        }\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n                reinterpretAsDestructuredParameter(options, param);\n                params.push(param);\n                defaults.push(null);\n            } else if (param.type === Syntax.SpreadElement) {\n                assert(i === len - 1, \"It is guaranteed that SpreadElement is last element by parseExpression\");\n                reinterpretAsDestructuredParameter(options, param.argument);\n                rest = param.argument;\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n            } else {\n                return null;\n            }\n        }\n\n        if (options.firstRestricted) {\n            throwError(options.firstRestricted, options.message);\n        }\n        if (options.stricted) {\n            throwErrorTolerant(options.stricted, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return { params: params, defaults: defaults, rest: rest };\n    }\n\n    function parseArrowFunctionExpression(options) {\n        var previousStrict, previousYieldAllowed, body;\n\n        expect('=>');\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        strict = true;\n        state.yieldAllowed = false;\n        body = parseConciseBody();\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n\n        return delegate.createArrowFunctionExpression(options.params, options.defaults, body, options.rest, body.type !== Syntax.BlockStatement);\n    }\n\n    function parseAssignmentExpression() {\n        var expr, token, params, oldParenthesizedCount;\n\n        if (matchKeyword('yield')) {\n            return parseYieldExpression();\n        }\n\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        if (match('(')) {\n            token = lookahead2();\n            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {\n                params = parseParams();\n                if (!match('=>')) {\n                    throwUnexpected(lex());\n                }\n                return parseArrowFunctionExpression(params);\n            }\n        }\n\n        token = lookahead;\n        expr = parseConditionalExpression();\n\n        if (match('=>') && expr.type === Syntax.Identifier) {\n            if (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === (oldParenthesizedCount + 1)) {\n                if (isRestrictedWord(expr.name)) {\n                    throwError({}, Messages.StrictParamName);\n                }\n                return parseArrowFunctionExpression({ params: [ expr ], defaults: [], rest: null });\n            }\n        }\n\n        if (matchAssign()) {\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            // ES.next draf 11.13 Runtime Semantics step 1\n            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n                reinterpretAsAssignmentBindingPattern(expr);\n            } else if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression());\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, expressions, sequence, coverFormalsList, spreadFound, token;\n\n        expr = parseAssignmentExpression();\n        expressions = [ expr ];\n\n        if (match(',')) {\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n\n                lex();\n                expr = parseSpreadOrAssignmentExpression();\n                expressions.push(expr);\n\n                if (expr.type === Syntax.SpreadElement) {\n                    spreadFound = true;\n                    if (!match(')')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                    break;\n                }\n            }\n\n            sequence = delegate.createSequenceExpression(expressions);\n        }\n\n        if (state.allowArrowFunction && match(')')) {\n            token = lookahead2();\n            if (token.value === '=>') {\n                lex();\n\n                state.allowArrowFunction = false;\n                expr = expressions;\n                coverFormalsList = reinterpretAsCoverFormalsList(expr);\n                if (coverFormalsList) {\n                    return parseArrowFunctionExpression(coverFormalsList);\n                }\n\n                throwUnexpected(token);\n            }\n        }\n\n        if (spreadFound) {\n            throwError({}, Messages.IllegalSpread);\n        }\n\n        return sequence || expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return delegate.createBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return delegate.createIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id,\n            init = null;\n        if (match('{')) {\n            id = parseObjectInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n        } else if (match('[')) {\n            id = parseArrayInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n        } else {\n            if (state.allowDefault) {\n                id = matchKeyword('default') ? parseNonComputedProperty() : parseVariableIdentifier();\n            } else {\n                id = parseVariableIdentifier();\n            }\n            // 12.2.1\n            if (strict && isRestrictedWord(id.name)) {\n                throwErrorTolerant({}, Messages.StrictVarName);\n            }\n        }\n\n        if (kind === 'const') {\n            if (!match('=')) {\n                throwError({}, Messages.NoUnintializedConst);\n            }\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return delegate.createVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, kind);\n    }\n\n    // http://wiki.ecmascript.org/doku.php?id=harmony:modules\n\n    function parseModuleDeclaration() {\n        var id, src, body;\n\n        lex();   // 'module'\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterModule);\n        }\n\n        switch (lookahead.type) {\n\n        case Token.StringLiteral:\n            id = parsePrimaryExpression();\n            body = parseModuleBlock();\n            src = null;\n            break;\n\n        case Token.Identifier:\n            id = parseVariableIdentifier();\n            body = null;\n            if (!matchContextualKeyword('from')) {\n                throwUnexpected(lex());\n            }\n            lex();\n            src = parsePrimaryExpression();\n            if (src.type !== Syntax.Literal) {\n                throwError({}, Messages.InvalidModuleSpecifier);\n            }\n            break;\n        }\n\n        consumeSemicolon();\n        return delegate.createModuleDeclaration(id, src, body);\n    }\n\n    function parseExportBatchSpecifier() {\n        expect('*');\n        return delegate.createExportBatchSpecifier();\n    }\n\n    function parseExportSpecifier() {\n        var id, name = null;\n\n        id = parseVariableIdentifier();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseNonComputedProperty();\n        }\n\n        return delegate.createExportSpecifier(id, name);\n    }\n\n    function parseExportDeclaration() {\n        var previousAllowDefault, decl, def, src, specifiers;\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            lex();\n            if (match('=')) {\n                lex();\n                def = parseAssignmentExpression();\n            } else if (lookahead.type === Token.Keyword) {\n                switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                case 'var':\n                case 'class':\n                    def = parseSourceElement();\n                    break;\n                case 'function':\n                    def = parseFunctionExpression();\n                    break;\n                default:\n                    throwUnexpected(lex());\n                }\n            } else {\n                def = parseAssignmentExpression();\n            }\n            consumeSemicolon();\n            return delegate.createExportDeclaration(true, def, null, null);\n        }\n\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'let':\n            case 'const':\n            case 'var':\n            case 'class':\n            case 'function':\n                previousAllowDefault = state.allowDefault;\n                state.allowDefault = true;\n                decl = delegate.createExportDeclaration(false, parseSourceElement(), null, null);\n                state.allowDefault = previousAllowDefault;\n                return decl;\n            }\n            throwUnexpected(lex());\n        }\n\n        specifiers = [];\n        src = null;\n\n        if (match('*')) {\n            specifiers.push(parseExportBatchSpecifier());\n        } else {\n            expect('{');\n            do {\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n            expect('}');\n        }\n\n        if (matchContextualKeyword('from')) {\n            lex();\n            src = parsePrimaryExpression();\n            if (src.type !== Syntax.Literal) {\n                throwError({}, Messages.InvalidModuleSpecifier);\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createExportDeclaration(false, null, specifiers, src);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, kind, src;\n\n        expectKeyword('import');\n        specifiers = [];\n\n        if (isIdentifierName(lookahead)) {\n            kind = 'default';\n            specifiers.push(parseImportSpecifier());\n\n            if (!matchContextualKeyword('from')) {\n                throwError({}, Messages.NoFromAfterImport);\n            }\n            lex();\n        } else if (match('{')) {\n            kind = 'named';\n            lex();\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n            expect('}');\n\n            if (!matchContextualKeyword('from')) {\n                throwError({}, Messages.NoFromAfterImport);\n            }\n            lex();\n        }\n\n        src = parsePrimaryExpression();\n        if (src.type !== Syntax.Literal) {\n            throwError({}, Messages.InvalidModuleSpecifier);\n        }\n\n        consumeSemicolon();\n\n        return delegate.createImportDeclaration(specifiers, kind, src);\n    }\n\n    function parseImportSpecifier() {\n        var id, name = null;\n\n        id = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseVariableIdentifier();\n        }\n\n        return delegate.createImportSpecifier(id, name);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n        return delegate.createEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return delegate.createIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return delegate.createDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return delegate.createWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token = lex(),\n            declarations = parseVariableDeclarationList();\n\n        return delegate.createVariableDeclaration(declarations, token.value);\n    }\n\n    function parseForStatement(opts) {\n        var init, test, update, left, right, body, operator, oldInIteration;\n        init = test = update = null;\n        expectKeyword('for');\n\n        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n        if (matchContextualKeyword(\"each\")) {\n            throwError({}, Messages.EachNotAllowed);\n        }\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1) {\n                    if (matchKeyword('in') || matchContextualKeyword('of')) {\n                        operator = lookahead;\n                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n                            lex();\n                            left = init;\n                            right = parseExpression();\n                            init = null;\n                        }\n                    }\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchContextualKeyword('of')) {\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isAssignableLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        if (!(opts !== undefined && opts.ignore_body)) {\n            body = parseStatement();\n        }\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return delegate.createForStatement(init, test, update, body);\n        }\n\n        if (operator.value === 'in') {\n            return delegate.createForInStatement(left, right, body);\n        }\n        return delegate.createForOfStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return delegate.createContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return delegate.createBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return delegate.createReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return delegate.createReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return delegate.createWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            sourceElement;\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            consequent.push(sourceElement);\n        }\n\n        return delegate.createSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return delegate.createSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return delegate.createThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body;\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseExpression();\n        // 12.14.1\n        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return delegate.createCatchClause(param, body);\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return delegate.createTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return delegate.createDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'class':\n                return parseClassDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return delegate.createLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount;\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesizedCount;\n\n        return delegate.createBlockStatement(sourceElements);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, rest, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            token = lex();\n            rest = true;\n        }\n\n        if (match('[')) {\n            param = parseArrayInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n        } else if (match('{')) {\n            if (rest) {\n                throwError({}, Messages.ObjectPatternAsRestParameter);\n            }\n            param = parseObjectInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n        } else {\n            param = parseVariableIdentifier();\n            validateParam(options, token, token.value);\n            if (match('=')) {\n                if (rest) {\n                    throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n                }\n                lex();\n                def = parseAssignmentExpression();\n                ++options.defaultCount;\n            }\n        }\n\n        if (rest) {\n            if (!match(')')) {\n                throwError({}, Messages.ParameterAfterRestParameter);\n            }\n            options.rest = param;\n            return false;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            rest: null,\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return options;\n    }\n\n    function parseFunctionDeclaration() {\n        var id, body, token, tmp, firstRestricted, message, previousStrict, previousYieldAllowed, generator, expression;\n\n        expectKeyword('function');\n\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        token = lookahead;\n\n        if (state.allowDefault) {\n            id = matchKeyword('default') ? parseNonComputedProperty() : parseVariableIdentifier();\n        } else {\n            id = parseVariableIdentifier();\n        }\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n\n        // here we redo some work in order to set 'expression'\n        expression = !match('{');\n        body = parseConciseBody();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        if (state.yieldAllowed && !state.yieldFound) {\n            throwErrorTolerant({}, Messages.NoYieldInGenerator);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n\n        return delegate.createFunctionDeclaration(id, tmp.params, tmp.defaults, body, tmp.rest, generator, expression);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, firstRestricted, message, tmp, body, previousStrict, previousYieldAllowed, generator, expression;\n\n        expectKeyword('function');\n\n        generator = false;\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n\n        // here we redo some work in order to set 'expression'\n        expression = !match('{');\n        body = parseConciseBody();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        if (state.yieldAllowed && !state.yieldFound) {\n            throwErrorTolerant({}, Messages.NoYieldInGenerator);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n\n        return delegate.createFunctionExpression(id, tmp.params, tmp.defaults, body, tmp.rest, generator, expression);\n    }\n\n    function parseYieldExpression() {\n        var delegateFlag, expr, previousYieldAllowed;\n\n        expectKeyword('yield');\n\n        if (!state.yieldAllowed) {\n            throwErrorTolerant({}, Messages.IllegalYield);\n        }\n\n        delegateFlag = false;\n        if (match('*')) {\n            lex();\n            delegateFlag = true;\n        }\n\n        // It is a Syntax Error if any AssignmentExpression Contains YieldExpression.\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = false;\n        expr = parseAssignmentExpression();\n        state.yieldAllowed = previousYieldAllowed;\n        state.yieldFound = true;\n\n        return delegate.createYieldExpression(expr, delegateFlag);\n    }\n\n    // 14 Classes\n\n    function parseMethodDefinition(existingPropNames) {\n        var token, key, param, propType, isValidDuplicateProp = false;\n\n        if (lookahead.value === 'static') {\n            propType = ClassPropertyType.static;\n            lex();\n        } else {\n            propType = ClassPropertyType.prototype;\n        }\n\n        if (match('*')) {\n            lex();\n            return delegate.createMethodDefinition(\n                propType,\n                '',\n                parseObjectPropertyKey(),\n                parsePropertyMethodFunction({ generator: true })\n            );\n        }\n\n        token = lookahead;\n        key = parseObjectPropertyKey();\n\n        if (token.value === 'get' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            // It is a syntax error if any other properties have a name\n            // duplicating this one unless they are a setter\n            if (existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp =\n                    // There isn't already a getter for this prop\n                    existingPropNames[propType][key.name].get === undefined\n                    // There isn't already a data prop by this name\n                    && existingPropNames[propType][key.name].data === undefined\n                    // The only existing prop by this name is a setter\n                    && existingPropNames[propType][key.name].set !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].get = true;\n\n            expect('(');\n            expect(')');\n            return delegate.createMethodDefinition(\n                propType,\n                'get',\n                key,\n                parsePropertyFunction({ generator: false })\n            );\n        }\n        if (token.value === 'set' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            // It is a syntax error if any other properties have a name\n            // duplicating this one unless they are a getter\n            if (existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp =\n                    // There isn't already a setter for this prop\n                    existingPropNames[propType][key.name].set === undefined\n                    // There isn't already a data prop by this name\n                    && existingPropNames[propType][key.name].data === undefined\n                    // The only existing prop by this name is a getter\n                    && existingPropNames[propType][key.name].get !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].set = true;\n\n            expect('(');\n            token = lookahead;\n            param = [ parseVariableIdentifier() ];\n            expect(')');\n            return delegate.createMethodDefinition(\n                propType,\n                'set',\n                key,\n                parsePropertyFunction({ params: param, generator: false, name: token })\n            );\n        }\n\n        // It is a syntax error if any other properties have the same name as a\n        // non-getter, non-setter method\n        if (existingPropNames[propType].hasOwnProperty(key.name)) {\n            throwError(key, Messages.IllegalDuplicateClassProperty);\n        } else {\n            existingPropNames[propType][key.name] = {};\n        }\n        existingPropNames[propType][key.name].data = true;\n\n        return delegate.createMethodDefinition(\n            propType,\n            '',\n            key,\n            parsePropertyMethodFunction({ generator: false })\n        );\n    }\n\n    function parseClassElement(existingProps) {\n        if (match(';')) {\n            lex();\n            return;\n        }\n        return parseMethodDefinition(existingProps);\n    }\n\n    function parseClassBody() {\n        var classElement, classElements = [], existingProps = {};\n\n        existingProps[ClassPropertyType.static] = {};\n        existingProps[ClassPropertyType.prototype] = {};\n\n        expect('{');\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            classElement = parseClassElement(existingProps);\n\n            if (typeof classElement !== 'undefined') {\n                classElements.push(classElement);\n            }\n        }\n\n        expect('}');\n\n        return delegate.createClassBody(classElements);\n    }\n\n    function parseClassExpression() {\n        var id, previousYieldAllowed, superClass = null;\n\n        expectKeyword('class');\n\n        if (!matchKeyword('extends') && !match('{')) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseAssignmentExpression();\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        return delegate.createClassExpression(id, superClass, parseClassBody());\n    }\n\n    function parseClassDeclaration() {\n        var id, previousYieldAllowed, superClass = null;\n\n        expectKeyword('class');\n\n        if (state.allowDefault) {\n            id = matchKeyword('default') ? parseNonComputedProperty() : parseVariableIdentifier();\n        } else {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseAssignmentExpression();\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        return delegate.createClassDeclaration(id, superClass, parseClassBody());\n    }\n\n    // 15 Program\n\n    function matchModuleDeclaration() {\n        var id;\n        if (matchContextualKeyword('module')) {\n            id = lookahead2();\n            return id.type === Token.StringLiteral || id.type === Token.Identifier;\n        }\n        return false;\n    }\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (matchModuleDeclaration()) {\n            throwError({}, Messages.NestedModule);\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseProgramElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            }\n        }\n\n        if (matchModuleDeclaration()) {\n            return parseModuleDeclaration();\n        }\n\n        return parseSourceElement();\n    }\n\n    function parseProgramElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseProgramElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseProgramElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseModuleElement() {\n        return parseSourceElement();\n    }\n\n    function parseModuleElements() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseModuleElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseModuleBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseModuleElements();\n\n        expect('}');\n\n        return delegate.createBlockStatement(block);\n    }\n\n    function parseProgram() {\n        var body;\n        strict = false;\n        peek();\n        body = parseProgramElements();\n        return delegate.createProgram(body);\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (extra.comments.length > 0) {\n            if (extra.comments[extra.comments.length - 1].range[1] > start) {\n                return;\n            }\n        }\n\n        extra.comments.push({\n            type: type,\n            value: value,\n            range: [start, end],\n            loc: loc\n        });\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch.charCodeAt(0))) {\n                ++index;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function filterCommentLocation() {\n        var i, entry, comment, comments = [];\n\n        for (i = 0; i < extra.comments.length; ++i) {\n            entry = extra.comments[i];\n            comment = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                comment.range = entry.range;\n            }\n            if (extra.loc) {\n                comment.loc = entry.loc;\n            }\n            comments.push(comment);\n        }\n\n        extra.comments = comments;\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function LocationMarker() {\n        this.range = [index, index];\n        this.loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            },\n            end: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n    }\n\n    LocationMarker.prototype = {\n        constructor: LocationMarker,\n\n        end: function () {\n            this.range[1] = index;\n            this.loc.end.line = lineNumber;\n            this.loc.end.column = index - lineStart;\n        },\n\n        applyGroup: function (node) {\n            if (extra.range) {\n                node.groupRange = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.groupLoc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n                node = delegate.postProcess(node);\n            }\n        },\n\n        apply: function (node) {\n            var nodeType = typeof node;\n            assert(nodeType === \"object\",\n                \"Applying location marker to an unexpected node type: \" +\n                    nodeType);\n\n            if (extra.range) {\n                node.range = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n                node = delegate.postProcess(node);\n            }\n        }\n    };\n\n    function createLocationMarker() {\n        return new LocationMarker();\n    }\n\n    function trackGroupExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n        expect('(');\n\n        ++state.parenthesizedCount;\n\n        state.allowArrowFunction = !state.allowArrowFunction;\n        expr = parseExpression();\n        state.allowArrowFunction = false;\n\n        if (expr.type === 'ArrowFunctionExpression') {\n            marker.end();\n            marker.apply(expr);\n        } else {\n            expect(')');\n            marker.end();\n            marker.applyGroup(expr);\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || lookahead.type === Token.Template) {\n            if (match('[')) {\n                expr = delegate.createMemberExpression('[', expr, parseComputedMember());\n                marker.end();\n                marker.apply(expr);\n            } else if (match('.')) {\n                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpressionAllowCall() {\n        var marker, expr, args;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n                marker.end();\n                marker.apply(expr);\n            } else if (match('[')) {\n                expr = delegate.createMemberExpression('[', expr, parseComputedMember());\n                marker.end();\n                marker.apply(expr);\n            } else if (match('.')) {\n                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function filterGroup(node) {\n        var n, i, entry;\n\n        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};\n        for (i in node) {\n            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n                entry = node[i];\n                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n                    n[i] = entry;\n                } else {\n                    n[i] = filterGroup(entry);\n                }\n            }\n        }\n        return n;\n    }\n\n    function wrapTrackingFunction(range, loc) {\n\n        return function (parseFunction) {\n\n            function isBinary(node) {\n                return node.type === Syntax.LogicalExpression ||\n                    node.type === Syntax.BinaryExpression;\n            }\n\n            function visit(node) {\n                var start, end;\n\n                if (isBinary(node.left)) {\n                    visit(node.left);\n                }\n                if (isBinary(node.right)) {\n                    visit(node.right);\n                }\n\n                if (range) {\n                    if (node.left.groupRange || node.right.groupRange) {\n                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n                        node.range = [start, end];\n                    } else if (typeof node.range === 'undefined') {\n                        start = node.left.range[0];\n                        end = node.right.range[1];\n                        node.range = [start, end];\n                    }\n                }\n                if (loc) {\n                    if (node.left.groupLoc || node.right.groupLoc) {\n                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n                        node.loc = {\n                            start: start,\n                            end: end\n                        };\n                        node = delegate.postProcess(node);\n                    } else if (typeof node.loc === 'undefined') {\n                        node.loc = {\n                            start: node.left.loc.start,\n                            end: node.right.loc.end\n                        };\n                        node = delegate.postProcess(node);\n                    }\n                }\n            }\n\n            return function () {\n                var marker, node;\n\n                skipComment();\n\n                marker = createLocationMarker();\n                node = parseFunction.apply(null, arguments);\n                marker.end();\n\n                if (range && typeof node.range === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (loc && typeof node.loc === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (isBinary(node)) {\n                    visit(node);\n                }\n\n                return node;\n            };\n        };\n    }\n\n    function patch() {\n\n        var wrapTracking;\n\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (extra.range || extra.loc) {\n\n            extra.parseGroupExpression = parseGroupExpression;\n            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n            parseGroupExpression = trackGroupExpression;\n            parseLeftHandSideExpression = trackLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n\n            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n\n            extra.parseAssignmentExpression = parseAssignmentExpression;\n            extra.parseBinaryExpression = parseBinaryExpression;\n            extra.parseBlock = parseBlock;\n            extra.parseFunctionSourceElements = parseFunctionSourceElements;\n            extra.parseCatchClause = parseCatchClause;\n            extra.parseComputedMember = parseComputedMember;\n            extra.parseConditionalExpression = parseConditionalExpression;\n            extra.parseConstLetDeclaration = parseConstLetDeclaration;\n            extra.parseExportBatchSpecifier = parseExportBatchSpecifier;\n            extra.parseExportDeclaration = parseExportDeclaration;\n            extra.parseExportSpecifier = parseExportSpecifier;\n            extra.parseExpression = parseExpression;\n            extra.parseForVariableDeclaration = parseForVariableDeclaration;\n            extra.parseFunctionDeclaration = parseFunctionDeclaration;\n            extra.parseFunctionExpression = parseFunctionExpression;\n            extra.parseParams = parseParams;\n            extra.parseImportDeclaration = parseImportDeclaration;\n            extra.parseImportSpecifier = parseImportSpecifier;\n            extra.parseModuleDeclaration = parseModuleDeclaration;\n            extra.parseModuleBlock = parseModuleBlock;\n            extra.parseNewExpression = parseNewExpression;\n            extra.parseNonComputedProperty = parseNonComputedProperty;\n            extra.parseObjectProperty = parseObjectProperty;\n            extra.parseObjectPropertyKey = parseObjectPropertyKey;\n            extra.parsePostfixExpression = parsePostfixExpression;\n            extra.parsePrimaryExpression = parsePrimaryExpression;\n            extra.parseProgram = parseProgram;\n            extra.parsePropertyFunction = parsePropertyFunction;\n            extra.parseSpreadOrAssignmentExpression = parseSpreadOrAssignmentExpression;\n            extra.parseTemplateElement = parseTemplateElement;\n            extra.parseTemplateLiteral = parseTemplateLiteral;\n            extra.parseStatement = parseStatement;\n            extra.parseSwitchCase = parseSwitchCase;\n            extra.parseUnaryExpression = parseUnaryExpression;\n            extra.parseVariableDeclaration = parseVariableDeclaration;\n            extra.parseVariableIdentifier = parseVariableIdentifier;\n            extra.parseMethodDefinition = parseMethodDefinition;\n            extra.parseClassDeclaration = parseClassDeclaration;\n            extra.parseClassExpression = parseClassExpression;\n            extra.parseClassBody = parseClassBody;\n\n            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n            parseBinaryExpression = wrapTracking(extra.parseBinaryExpression);\n            parseBlock = wrapTracking(extra.parseBlock);\n            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n            parseCatchClause = wrapTracking(extra.parseCatchClause);\n            parseComputedMember = wrapTracking(extra.parseComputedMember);\n            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n            parseExportBatchSpecifier = wrapTracking(parseExportBatchSpecifier);\n            parseExportDeclaration = wrapTracking(parseExportDeclaration);\n            parseExportSpecifier = wrapTracking(parseExportSpecifier);\n            parseExpression = wrapTracking(extra.parseExpression);\n            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n            parseParams = wrapTracking(extra.parseParams);\n            parseImportDeclaration = wrapTracking(extra.parseImportDeclaration);\n            parseImportSpecifier = wrapTracking(extra.parseImportSpecifier);\n            parseModuleDeclaration = wrapTracking(extra.parseModuleDeclaration);\n            parseModuleBlock = wrapTracking(extra.parseModuleBlock);\n            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n            parseNewExpression = wrapTracking(extra.parseNewExpression);\n            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n            parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n            parseProgram = wrapTracking(extra.parseProgram);\n            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n            parseTemplateElement = wrapTracking(extra.parseTemplateElement);\n            parseTemplateLiteral = wrapTracking(extra.parseTemplateLiteral);\n            parseSpreadOrAssignmentExpression = wrapTracking(extra.parseSpreadOrAssignmentExpression);\n            parseStatement = wrapTracking(extra.parseStatement);\n            parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n            parseMethodDefinition = wrapTracking(extra.parseMethodDefinition);\n            parseClassDeclaration = wrapTracking(extra.parseClassDeclaration);\n            parseClassExpression = wrapTracking(extra.parseClassExpression);\n            parseClassBody = wrapTracking(extra.parseClassBody);\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (extra.range || extra.loc) {\n            parseAssignmentExpression = extra.parseAssignmentExpression;\n            parseBinaryExpression = extra.parseBinaryExpression;\n            parseBlock = extra.parseBlock;\n            parseFunctionSourceElements = extra.parseFunctionSourceElements;\n            parseCatchClause = extra.parseCatchClause;\n            parseComputedMember = extra.parseComputedMember;\n            parseConditionalExpression = extra.parseConditionalExpression;\n            parseConstLetDeclaration = extra.parseConstLetDeclaration;\n            parseExportBatchSpecifier = extra.parseExportBatchSpecifier;\n            parseExportDeclaration = extra.parseExportDeclaration;\n            parseExportSpecifier = extra.parseExportSpecifier;\n            parseExpression = extra.parseExpression;\n            parseForVariableDeclaration = extra.parseForVariableDeclaration;\n            parseFunctionDeclaration = extra.parseFunctionDeclaration;\n            parseFunctionExpression = extra.parseFunctionExpression;\n            parseImportDeclaration = extra.parseImportDeclaration;\n            parseImportSpecifier = extra.parseImportSpecifier;\n            parseGroupExpression = extra.parseGroupExpression;\n            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n            parseModuleDeclaration = extra.parseModuleDeclaration;\n            parseModuleBlock = extra.parseModuleBlock;\n            parseNewExpression = extra.parseNewExpression;\n            parseNonComputedProperty = extra.parseNonComputedProperty;\n            parseObjectProperty = extra.parseObjectProperty;\n            parseObjectPropertyKey = extra.parseObjectPropertyKey;\n            parsePostfixExpression = extra.parsePostfixExpression;\n            parsePrimaryExpression = extra.parsePrimaryExpression;\n            parseProgram = extra.parseProgram;\n            parsePropertyFunction = extra.parsePropertyFunction;\n            parseTemplateElement = extra.parseTemplateElement;\n            parseTemplateLiteral = extra.parseTemplateLiteral;\n            parseSpreadOrAssignmentExpression = extra.parseSpreadOrAssignmentExpression;\n            parseStatement = extra.parseStatement;\n            parseSwitchCase = extra.parseSwitchCase;\n            parseUnaryExpression = extra.parseUnaryExpression;\n            parseVariableDeclaration = extra.parseVariableDeclaration;\n            parseVariableIdentifier = extra.parseVariableIdentifier;\n            parseMethodDefinition = extra.parseMethodDefinition;\n            parseClassDeclaration = extra.parseClassDeclaration;\n            parseClassExpression = extra.parseClassExpression;\n            parseClassBody = extra.parseClassBody;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    // This is used to modify the delegate.\n\n    function extend(object, properties) {\n        var entry, result = {};\n\n        for (entry in object) {\n            if (object.hasOwnProperty(entry)) {\n                result[entry] = object[entry];\n            }\n        }\n\n        for (entry in properties) {\n            if (properties.hasOwnProperty(entry)) {\n                result[entry] = properties[entry];\n            }\n        }\n\n        return result;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowDefault: true,\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        patch();\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowDefault: false,\n            allowIn: true,\n            labelSet: {},\n            parenthesizedCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            yieldAllowed: false,\n            yieldFound: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                delegate = extend(delegate, {\n                    'postProcess': function (node) {\n                        node.loc.source = toString(options.source);\n                        return node;\n                    }\n                });\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.range || extra.loc) {\n                program.body = filterGroup(program.body);\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json and component.json.\n    exports.version = '1.1.0-dev-harmony';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/esprima-es6.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/esprima-es6.js?");

/***/ },
/* 39 */
/***/ function(module, exports) {

	eval("\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/mock/empty.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/mock/empty.js?");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(39);\nvar path = __webpack_require__(42);\nvar pkg = __webpack_require__(43);\nvar sweet = __webpack_require__(44);\nvar syn = __webpack_require__(16);\nvar argv = __webpack_require__(52).usage('Usage: sjs [options] path/to/file.js').alias('v', 'version').describe('v', 'Output version info').boolean('version').alias('o', 'output').describe('o', 'Output file path').alias('m', 'module').describe('m', 'use a module file for loading macro definitions. Use ./ or ../ for relative path otherwise looks up in installed npm packages').alias('w', 'watch').describe('w', 'watch a file').boolean('watch').alias('t', 'tokens').describe('t', 'just emit the expanded tokens without parsing an AST').alias('a', 'ast').describe('a', 'just emit the expanded AST').alias('p', 'no-parse').describe('p', 'print out the expanded result but do not run through the parser (or apply hygienic renamings)').boolean('no-parse').alias('s', 'stdin').describe('s', 'read from stdin').boolean('stdin').alias('c', 'sourcemap').describe('c', 'generate a sourcemap').boolean('sourcemap').alias('n', 'num-expands').describe('n', 'the maximum number of expands to perform').alias('h', 'step-hygiene').describe('h', 'display hygienic renames when stepping with \"--num-expands\"').alias('r', 'readable-names').describe('r', 'remove as many hygienic renames as possible (ES5 code only!)').boolean('readable-names').describe('format-indent', 'number of spaces for indentation').alias('l', 'load-readtable').describe('load-readtable', 'readtable module to install').argv;\nexports.run = function () {\n    if (argv.version) {\n        return console.log('Sweet.js version: ' + pkg.version);\n    }\n    var infile = argv._[0];\n    var outfile = argv.output;\n    var watch = argv.watch;\n    var tokens = argv.tokens;\n    var ast = argv.ast;\n    var sourcemap = argv.sourcemap;\n    var noparse = argv['no-parse'];\n    var numexpands = argv['num-expands'];\n    var displayHygiene = argv['step-hygiene'];\n    var readableNames = argv['readable-names'];\n    var formatIndent = parseInt(argv['format-indent'], 10);\n    var readtableModules = argv['load-readtable'];\n    if (formatIndent !== formatIndent) {\n        formatIndent = 4;\n    }\n    var file;\n    if (infile) {\n        file = fs.readFileSync(infile, 'utf8');\n    } else if (argv.stdin) {\n        file = fs.readFileSync('/dev/stdin', 'utf8');\n    } else if (argv._.length === 0) {\n        console.log(__webpack_require__(52).help());\n        return;\n    }\n    var cwd = process.cwd();\n    var modules = typeof argv.module === 'string' ? [argv.module] : argv.module;\n    modules = (modules || []).map(function (path$2) {\n        return sweet.loadNodeModule(cwd, path$2);\n    });\n    if (readtableModules) {\n        readtableModules = Array.isArray(readtableModules) ? readtableModules : [readtableModules];\n        readtableModules.forEach(function (mod) {\n            sweet.setReadtable(mod);\n        });\n    }\n    var options = {\n        filename: infile,\n        modules: modules,\n        ast: ast,\n        readableNames: readableNames,\n        escodegen: { format: { indent: { style: Array(formatIndent + 1).join(' ') } } }\n    };\n    function doCompile() {\n        if (sourcemap) {\n            options.sourceMap = true;\n            var result = sweet.compile(file, options);\n            var mapfile = path.basename(outfile) + '.map';\n            fs.writeFileSync(outfile, result.code + '\\n//# sourceMappingURL=' + mapfile, 'utf8');\n            fs.writeFileSync(outfile + '.map', result.sourceMap, 'utf8');\n        } else {\n            fs.writeFileSync(outfile, sweet.compile(file, options).code, 'utf8');\n        }\n    }\n    if (watch && outfile) {\n        fs.watch(infile, function () {\n            file = fs.readFileSync(infile, 'utf8');\n            try {\n                doCompile();\n            } catch (e) {\n                console.log(e);\n            }\n        });\n    } else if (outfile) {\n        doCompile();\n    } else if (tokens) {\n        console.log(sweet.expand(file, modules, { maxExpands: numexpands }));\n    } else if (ast) {\n        console.log(JSON.stringify(sweet.compile(file, options), null, formatIndent));\n    } else if (noparse) {\n        var expanded = sweet.expand(file, modules, { maxExpands: numexpands });\n        var unparsedString = syn.prettyPrint(expanded, displayHygiene);\n        console.log(unparsedString);\n    } else {\n        options.maxExpands = numexpands;\n        console.log(sweet.compile(file, options).code);\n    }\n};\n//# sourceMappingURL=sjs.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/sjs.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/sjs.js?");

/***/ },
/* 41 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/process/browser.js?");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/path-browserify/index.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/path-browserify/index.js?");

/***/ },
/* 43 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"sweet.js@^0.7.4\",\n\t\t\t\"/home/cs/Projects/rlet\"\n\t\t]\n\t],\n\t\"_from\": \"sweet.js@>=0.7.4 <0.8.0\",\n\t\"_id\": \"sweet.js@0.7.4\",\n\t\"_inCache\": true,\n\t\"_location\": \"/sweet.js\",\n\t\"_npmUser\": {\n\t\t\"email\": \"tim.disney@gmail.com\",\n\t\t\"name\": \"disnet\"\n\t},\n\t\"_npmVersion\": \"2.0.0\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"sweet.js\",\n\t\t\"raw\": \"sweet.js@^0.7.4\",\n\t\t\"rawSpec\": \"^0.7.4\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=0.7.4 <0.8.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/sweet.js/-/sweet.js-0.7.4.tgz\",\n\t\"_shasum\": \"6ad0a39a8d2f0280325e951d5df7cbd5399a3135\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"sweet.js@^0.7.4\",\n\t\"_where\": \"/home/cs/Projects/rlet\",\n\t\"author\": {\n\t\t\"name\": \"Tim Disney\"\n\t},\n\t\"bin\": {\n\t\t\"sjs\": \"bin/sjs\"\n\t},\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/mozilla/sweet.js/issues\"\n\t},\n\t\"dependencies\": {\n\t\t\"escodegen\": \"1.6.x\",\n\t\t\"escope\": \"1.0.x\",\n\t\t\"optimist\": \"~0.3.4\",\n\t\t\"resolve\": \"~0.6.1\",\n\t\t\"underscore\": \"~1.3.3\"\n\t},\n\t\"description\": \"Hygienic Macros for JavaScript\",\n\t\"devDependencies\": {\n\t\t\"contracts-js\": \"^0.6.0\",\n\t\t\"esfuzz\": \"git+https://github.com/disnet/esfuzz\",\n\t\t\"expect.js\": \"0.1.x\",\n\t\t\"grunt-cli\": \"0.1.x\",\n\t\t\"grunt-contrib-copy\": \"~0.4.1\",\n\t\t\"grunt-contrib-jshint\": \"~0.7.2\",\n\t\t\"grunt-contrib-watch\": \"~0.6.1\",\n\t\t\"grunt-mocha-test\": \"~0.7.0\",\n\t\t\"harmony-reflect\": \"^1.0.0\",\n\t\t\"mocha\": \"~1.3.2\",\n\t\t\"source-map\": \"~0.1.31\"\n\t},\n\t\"directories\": {\n\t\t\"test\": \"test\"\n\t},\n\t\"dist\": {\n\t\t\"shasum\": \"6ad0a39a8d2f0280325e951d5df7cbd5399a3135\",\n\t\t\"tarball\": \"http://registry.npmjs.org/sweet.js/-/sweet.js-0.7.4.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.4.0\"\n\t},\n\t\"gitHead\": \"8016a8a47bc64e9ade4ee06e16a2fb34592465ee\",\n\t\"homepage\": \"https://github.com/mozilla/sweet.js\",\n\t\"installable\": true,\n\t\"keywords\": [\n\t\t\"javascript\",\n\t\t\"macros\"\n\t],\n\t\"license\": \"BSD\",\n\t\"licenses\": [\n\t\t{\n\t\t\t\"type\": \"BSD\",\n\t\t\t\"url\": \"http://github.com/mozilla/sweet.js/master/LICENSE.BSD\"\n\t\t}\n\t],\n\t\"main\": \"lib/sweet.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"disnet\",\n\t\t\t\"email\": \"tim.disney@gmail.com\"\n\t\t}\n\t],\n\t\"name\": \"sweet.js\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/mozilla/sweet.js.git\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"node --harmony ./node_modules/.bin/grunt full --stack\"\n\t},\n\t\"version\": \"0.7.4\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/package.json\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/package.json?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process, __filename) {(function (root, factory) {\n    if (true) {\n        var path = __webpack_require__(42);\n        var fs = __webpack_require__(39);\n        var resolveSync = __webpack_require__(45);\n        var codegen = __webpack_require__(19);\n        var lib = path.join(path.dirname(fs.realpathSync(__filename)), '../macros');\n        var stxcaseModule = fs.readFileSync(lib + '/stxcase.js', 'utf8');\n        var moduleCache = {};\n        var cwd = process.cwd();\n        var requireModule = function (id, filename) {\n            var basedir = filename ? path.dirname(filename) : cwd;\n            var key = basedir + id;\n            if (!moduleCache[key]) {\n                moduleCache[key] = __webpack_require__(36)(resolveSync(id, { basedir: basedir }));\n            }\n            return moduleCache[key];\n        };\n        factory(exports, __webpack_require__(15), __webpack_require__(13), __webpack_require__(14), __webpack_require__(16), stxcaseModule, __webpack_require__(49), __webpack_require__(19), fs, path, resolveSync, requireModule);\n        // Alow require('./example') for an example.sjs file.\n        (void 0)['.sjs'] = function (module, filename) {\n            var content = __webpack_require__(39).readFileSync(filename, 'utf8');\n            module._compile(codegen.generate(exports.parse(content, exports.loadedMacros)), filename);\n        };\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([\n            'exports',\n            'underscore',\n            './parser',\n            './expander',\n            './syntax',\n            'text!./stxcase.js',\n            'escope'\n        ], factory);\n    }\n}(this, function (exports$2, _, parser, expander, syn, stxcaseModule, escope, gen, fs, path, resolveSync, requireModule) {\n    var // escodegen still doesn't quite support AMD: https://github.com/Constellation/escodegen/issues/115\n    codegen = typeof escodegen !== 'undefined' ? escodegen : gen;\n    var expand = makeExpand(expander.expand);\n    var expandModule = makeExpand(expander.expandModule);\n    var stxcaseCtx;\n    var baseReadtable = Object.create({\n        extend: function (obj) {\n            var extended = Object.create(this);\n            Object.keys(obj).forEach(function (ch) {\n                extended[ch] = obj[ch];\n            });\n            return extended;\n        }\n    });\n    parser.setReadtable(baseReadtable, syn);\n    function ensureStxcaseCtx() {\n        if (!stxcaseCtx) {\n            var oldReadtable = parser.currentReadtable();\n            parser.setReadtable(baseReadtable, syn);\n            stxcaseCtx = expander.expandModule(parser.read(stxcaseModule));\n            parser.setReadtable(oldReadtable);\n        }\n    }\n    function makeExpand(expandFn) {\n        return function expand$2(code, modules, options) {\n            var program, toString;\n            modules = modules || [];\n            ensureStxcaseCtx();\n            toString = String;\n            if (typeof code !== 'string' && !(code instanceof String)) {\n                code = toString(code);\n            }\n            var source$2 = code;\n            if (source$2.length > 0) {\n                if (typeof source$2[0] === 'undefined') {\n                    if (// Try first to convert to a string. This is good as fast path\n                        // for old IE which understands string indexing for string\n                        // literals only and not for string object.\n                        code instanceof String) {\n                        source$2 = code.valueOf();\n                    }\n                    if (// Force accessing the characters via an array.\n                        typeof source$2[0] === 'undefined') {\n                        source$2 = stringToArray(code);\n                    }\n                }\n            }\n            var readTree = parser.read(source$2);\n            try {\n                return expandFn(readTree, [stxcaseCtx].concat(modules), options);\n            } catch (err) {\n                if (err instanceof syn.MacroSyntaxError) {\n                    throw new SyntaxError(syn.printSyntaxError(source$2, err));\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n    function expandSyntax(stx, modules, options) {\n        ensureStxcaseCtx();\n        var isSyntax = syn.isSyntax(stx);\n        options = options || {};\n        options.flatten = false;\n        if (!isSyntax) {\n            stx = syn.tokensToSyntax(stx);\n        }\n        try {\n            var result = expander.expand(stx, [stxcaseCtx].concat(modules), options);\n            return isSyntax ? result : syn.syntaxToTokens(result);\n        } catch (err) {\n            if (err instanceof syn.MacroSyntaxError) {\n                throw new SyntaxError(syn.printSyntaxError(source, err));\n            } else {\n                throw err;\n            }\n        }\n    }\n    function parse(code, modules, options) {\n        if (code === '') {\n            // old version of esprima doesn't play nice with the empty string\n            // and loc/range info so until we can upgrade hack in a single space\n            code = ' ';\n        }\n        modules = modules ? loadedMacros.concat(modules) : modules;\n        return parser.parse(expand(code, modules, options));\n    }\n    function compile(code, options) {\n        var output, result = {};\n        options = options || {};\n        options.requireModule = options.requireModule || requireModule;\n        var ast = parse(code, options.modules || [], options);\n        if (options.readableNames) {\n            ast = optimizeHygiene(ast);\n        }\n        if (options.ast) {\n            return ast;\n        }\n        if (options.sourceMap) {\n            output = codegen.generate(ast, _.extend({\n                comment: true,\n                sourceMap: options.filename,\n                sourceMapWithCode: true\n            }, options.escodegen));\n            result.code = output.code;\n            result.sourceMap = output.map.toString();\n        } else {\n            result.code = codegen.generate(ast, _.extend({ comment: true }, options.escodegen));\n        }\n        if (options.log)\n            result.log = options.log;\n        return result;\n    }\n    function setReadtable(readtableModule) {\n        var filename = resolveSync(readtableModule, { basedir: process.cwd() });\n        var readtable = __webpack_require__(36)(filename);\n        parser.setReadtable(__webpack_require__(36)(filename));\n    }\n    function currentReadtable() {\n        return parser.currentReadtable();\n    }\n    function loadNodeModule(root, moduleName, options) {\n        options = options || {};\n        if (moduleName[0] === '.') {\n            moduleName = path.resolve(root, moduleName);\n        }\n        var filename = resolveSync(moduleName, {\n            basedir: root,\n            extensions: [\n                '.js',\n                '.sjs'\n            ]\n        });\n        return expandModule(fs.readFileSync(filename, 'utf8'), undefined, {\n            filename: moduleName,\n            requireModule: options.requireModule || requireModule\n        });\n    }\n    function optimizeHygiene(ast) {\n        var // escope hack: sweet doesn't rename global vars. We wrap in a closure\n        // to create a 'static` scope for all of the vars sweet renamed.\n        wrapper = parse('(function(){})()');\n        wrapper.body[0].expression.callee.body.body = ast.body;\n        function sansUnique(name) {\n            var match = name.match(/^(.+)\\$[\\d]+$/);\n            return match ? match[1] : null;\n        }\n        function wouldShadow(name, scope) {\n            while (scope) {\n                if (scope.scrubbed && scope.scrubbed.has(name)) {\n                    return scope.scrubbed.get(name);\n                }\n                scope = scope.upper;\n            }\n            return 0;\n        }\n        var scopes = escope.analyze(wrapper).scopes;\n        var globalScope;\n        // The first pass over the scope collects any non-static references,\n        // which means references from the global scope. We need to make these\n        // verboten so we don't accidently mangle a name to match. This could\n        // cause seriously hard to find bugs if you were just testing with\n        // --readable-names on.\n        scopes.forEach(function (scope) {\n            scope.scrubbed = new expander.StringMap();\n            if (// There aren't any references declared in the global scope since\n                // we wrapped our input in a static closure.\n                !scope.isStatic()) {\n                globalScope = scope;\n                return;\n            }\n            scope.references.forEach(function (ref) {\n                if (!ref.isStatic()) {\n                    globalScope.scrubbed.set(ref.identifier.name, 1);\n                }\n            });\n        });\n        // The second pass mangles the names to get rid of the hygiene tag\n        // wherever possible.\n        scopes.forEach(function (scope) {\n            if (// No need to rename things in the global scope.\n                !scope.isStatic()) {\n                return;\n            }\n            scope.variables.forEach(function (variable) {\n                var name = sansUnique(variable.name);\n                if (!name) {\n                    return;\n                }\n                var level = wouldShadow(name, scope);\n                if (level) {\n                    scope.scrubbed.set(name, level + 1);\n                    name = name + '$' + (level + 1);\n                } else {\n                    scope.scrubbed.set(name, 1);\n                }\n                variable.identifiers.forEach(function (i) {\n                    i.name = name;\n                });\n                variable.references.forEach(function (r) {\n                    r.identifier.name = name;\n                });\n            });\n        });\n        return ast;\n    }\n    var loadedMacros = [];\n    function loadMacro(relative_file) {\n        loadedMacros.push(loadNodeModule(process.cwd(), relative_file));\n    }\n    exports$2.expand = expand;\n    exports$2.expandSyntax = expandSyntax;\n    exports$2.parse = parse;\n    exports$2.compile = compile;\n    exports$2.setReadtable = setReadtable;\n    exports$2.currentReadtable = currentReadtable;\n    exports$2.loadModule = expandModule;\n    exports$2.loadNodeModule = loadNodeModule;\n    exports$2.loadedMacros = loadedMacros;\n    exports$2.loadMacro = loadMacro;\n}));\n//# sourceMappingURL=sweet.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41), \"/index.js\"))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/lib/sweet.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/lib/sweet.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("var core = __webpack_require__(46);\nvar fs = __webpack_require__(39);\nvar path = __webpack_require__(42);\nvar caller = __webpack_require__(47);\nvar nodeModulesPaths = __webpack_require__(48);\n\nmodule.exports = function (x, opts) {\n    if (!opts) opts = {};\n    var isFile = opts.isFile || function (file) {\n        try { var stat = fs.statSync(file) }\n        catch (err) { if (err && err.code === 'ENOENT') return false }\n        return stat.isFile() || stat.isFIFO();\n    };\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    \n    var extensions = opts.extensions || [ '.js' ];\n    var y = opts.basedir || path.dirname(caller());\n\n    opts.paths = opts.paths || [];\n\n    if (x.match(/^(?:\\.\\.?\\/|\\/|([A-Za-z]:)?\\\\)/)) {\n        var m = loadAsFileSync(path.resolve(y, x))\n            || loadAsDirectorySync(path.resolve(y, x));\n        if (m) return m;\n    } else {\n        var n = loadNodeModulesSync(x, y);\n        if (n) return n;\n    }\n    \n    if (core[x]) return x;\n    \n    throw new Error(\"Cannot find module '\" + x + \"' from '\" + y + \"'\");\n    \n    function loadAsFileSync (x) {\n        if (isFile(x)) {\n            return x;\n        }\n        \n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n    \n    function loadAsDirectorySync (x) {\n        var pkgfile = path.join(x, '/package.json');\n        if (isFile(pkgfile)) {\n            var body = readFileSync(pkgfile, 'utf8');\n            try {\n                var pkg = JSON.parse(body);\n                if (opts.packageFilter) {\n                    pkg = opts.packageFilter(pkg, x);\n                }\n                \n                if (pkg.main) {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                }\n            }\n            catch (err) {}\n        }\n        \n        return loadAsFileSync(path.join( x, '/index'));\n    }\n    \n    function loadNodeModulesSync (x, start) {\n        var dirs = nodeModulesPaths(start, opts);\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            var m = loadAsFileSync(path.join( dir, '/', x));\n            if (m) return m;\n            var n = loadAsDirectorySync(path.join( dir, '/', x ));\n            if (n) return n;\n        }\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/resolve/lib/sync.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/resolve/lib/sync.js?");

/***/ },
/* 46 */
/***/ function(module, exports) {

	eval("module.exports = [\n\t\"assert\",\n\t\"buffer_ieee754\",\n\t\"buffer\",\n\t\"child_process\",\n\t\"cluster\",\n\t\"console\",\n\t\"constants\",\n\t\"crypto\",\n\t\"_debugger\",\n\t\"dgram\",\n\t\"dns\",\n\t\"domain\",\n\t\"events\",\n\t\"freelist\",\n\t\"fs\",\n\t\"http\",\n\t\"https\",\n\t\"_linklist\",\n\t\"module\",\n\t\"net\",\n\t\"os\",\n\t\"path\",\n\t\"punycode\",\n\t\"querystring\",\n\t\"readline\",\n\t\"repl\",\n\t\"stream\",\n\t\"string_decoder\",\n\t\"sys\",\n\t\"timers\",\n\t\"tls\",\n\t\"tty\",\n\t\"url\",\n\t\"util\",\n\t\"vm\",\n\t\"zlib\"\n];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/resolve/lib/core.json\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/resolve/lib/core.json?");

/***/ },
/* 47 */
/***/ function(module, exports) {

	eval("module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/resolve/lib/caller.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/resolve/lib/caller.js?");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(42);\n\n\nmodule.exports = function (start, opts) {\n    var modules = opts.moduleDirectory || 'node_modules';\n    var prefix = '/';\n    if (/^([A-Za-z]:)/.test(start)) {\n        prefix = '';\n    } else if (/^\\\\\\\\/.test(start)) {\n        prefix = '\\\\\\\\';\n    }\n    var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/;\n    var parts = start.split(splitRe);\n\n    var dirs = [];\n    for (var i = parts.length - 1; i >= 0; i--) {\n        if (parts[i] === modules) continue;\n        var dir = path.join(\n            path.join.apply(path, parts.slice(0, i + 1)),\n            modules\n        );\n        dirs.push(prefix + dir);\n    }\n    if(process.platform === 'win32'){\n        dirs[dirs.length-1] = dirs[dirs.length-1].replace(\":\", \":\\\\\");\n    }\n    return dirs.concat(opts.paths);\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/resolve/lib/node-modules-paths.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/resolve/lib/node-modules-paths.js?");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Escope (<a href=\"http://github.com/Constellation/escope\">escope</a>) is an <a\n * href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>\n * scope analyzer extracted from the <a\n * href=\"http://github.com/Constellation/esmangle\">esmangle project</a/>.\n * <p>\n * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that\n * program where different occurrences of the same identifier refer to the same\n * variable. With each scope the contained variables are collected, and each\n * identifier reference in code is linked to its corresponding variable (if\n * possible).\n * <p>\n * <em>escope</em> works on a syntax tree of the parsed source code which has\n * to adhere to the <a\n * href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">\n * Mozilla Parser API</a>. E.g. <a href=\"http://esprima.org\">esprima</a> is a parser\n * that produces such syntax trees.\n * <p>\n * The main interface is the {@link analyze} function.\n * @module\n */\n\n/*jslint bitwise:true */\n/*global exports:true, define:true, require:true*/\n(function (factory, global) {\n    'use strict';\n\n    function namespace(str, obj) {\n        var i, iz, names, name;\n        names = str.split('.');\n        for (i = 0, iz = names.length; i < iz; ++i) {\n            name = names[i];\n            if (obj.hasOwnProperty(name)) {\n                obj = obj[name];\n            } else {\n                obj = (obj[name] = {});\n            }\n        }\n        return obj;\n    }\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // and plain browser loading,\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(50)], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports, estraverse) {\n            factory(exports, global, estraverse);\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== 'undefined') {\n        factory(exports, global, require('estraverse'));\n    } else {\n        factory(namespace('escope', global), global, global.estraverse);\n    }\n}(function (exports, global, estraverse) {\n    'use strict';\n\n    var Syntax,\n        Map,\n        currentScope,\n        globalScope,\n        scopes,\n        options;\n\n    Syntax = estraverse.Syntax;\n\n    if (typeof global.Map !== 'undefined') {\n        // ES6 Map\n        Map = global.Map;\n    } else {\n        Map = function Map() {\n            this.__data = {};\n        };\n\n        Map.prototype.get = function MapGet(key) {\n            key = '$' + key;\n            if (this.__data.hasOwnProperty(key)) {\n                return this.__data[key];\n            }\n            return undefined;\n        };\n\n        Map.prototype.has = function MapHas(key) {\n            key = '$' + key;\n            return this.__data.hasOwnProperty(key);\n        };\n\n        Map.prototype.set = function MapSet(key, val) {\n            key = '$' + key;\n            this.__data[key] = val;\n        };\n\n        Map.prototype['delete'] = function MapDelete(key) {\n            key = '$' + key;\n            return delete this.__data[key];\n        };\n    }\n\n    function assert(cond, text) {\n        if (!cond) {\n            throw new Error(text);\n        }\n    }\n\n    function defaultOptions() {\n        return {\n            optimistic: false,\n            directive: false,\n            ecmaVersion: 5\n        };\n    }\n\n    function updateDeeply(target, override) {\n        var key, val;\n\n        function isHashObject(target) {\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n\n    /**\n     * A Reference represents a single occurrence of an identifier in code.\n     * @class Reference\n     */\n    function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal) {\n        /**\n         * Identifier syntax node.\n         * @member {esprima#Identifier} Reference#identifier\n         */\n        this.identifier = ident;\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Reference#from\n         */\n        this.from = scope;\n        /**\n         * Whether the reference comes from a dynamic scope (such as 'eval',\n         * 'with', etc.), and may be trapped by dynamic scopes.\n         * @member {boolean} Reference#tainted\n         */\n        this.tainted = false;\n        /**\n         * The variable this reference is resolved with.\n         * @member {Variable} Reference#resolved\n         */\n        this.resolved = null;\n        /**\n         * The read-write mode of the reference. (Value is one of {@link\n         * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).\n         * @member {number} Reference#flag\n         * @private\n         */\n        this.flag = flag;\n        if (this.isWrite()) {\n            /**\n             * If reference is writeable, this is the tree being written to it.\n             * @member {esprima#Node} Reference#writeExpr\n             */\n            this.writeExpr = writeExpr;\n        }\n        /**\n         * Whether the Reference might refer to a global variable.\n         * @member {boolean} Reference#__maybeImplicitGlobal\n         * @private\n         */\n        this.__maybeImplicitGlobal = maybeImplicitGlobal;\n    }\n\n    /**\n     * @constant Reference.READ\n     * @private\n     */\n    Reference.READ = 0x1;\n    /**\n     * @constant Reference.WRITE\n     * @private\n     */\n    Reference.WRITE = 0x2;\n    /**\n     * @constant Reference.RW\n     * @private\n     */\n    Reference.RW = 0x3;\n\n    /**\n     * Whether the reference is static.\n     * @method Reference#isStatic\n     * @return {boolean}\n     */\n    Reference.prototype.isStatic = function isStatic() {\n        return !this.tainted && this.resolved && this.resolved.scope.isStatic();\n    };\n\n    /**\n     * Whether the reference is writeable.\n     * @method Reference#isWrite\n     * @return {boolean}\n     */\n    Reference.prototype.isWrite = function isWrite() {\n        return this.flag & Reference.WRITE;\n    };\n\n    /**\n     * Whether the reference is readable.\n     * @method Reference#isRead\n     * @return {boolean}\n     */\n    Reference.prototype.isRead = function isRead() {\n        return this.flag & Reference.READ;\n    };\n\n    /**\n     * Whether the reference is read-only.\n     * @method Reference#isReadOnly\n     * @return {boolean}\n     */\n    Reference.prototype.isReadOnly = function isReadOnly() {\n        return this.flag === Reference.READ;\n    };\n\n    /**\n     * Whether the reference is write-only.\n     * @method Reference#isWriteOnly\n     * @return {boolean}\n     */\n    Reference.prototype.isWriteOnly = function isWriteOnly() {\n        return this.flag === Reference.WRITE;\n    };\n\n    /**\n     * Whether the reference is read-write.\n     * @method Reference#isReadWrite\n     * @return {boolean}\n     */\n    Reference.prototype.isReadWrite = function isReadWrite() {\n        return this.flag === Reference.RW;\n    };\n\n    /**\n     * A Variable represents a locally scoped identifier. These include arguments to\n     * functions.\n     * @class Variable\n     */\n    function Variable(name, scope) {\n        /**\n         * The variable name, as given in the source code.\n         * @member {String} Variable#name\n         */\n        this.name = name;\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as AST nodes.\n         * @member {esprima.Identifier[]} Variable#identifiers\n         */\n        this.identifiers = [];\n        /**\n         * List of {@link Reference|references} of this variable (excluding parameter entries)\n         * in its defining scope and all nested scopes. For defining\n         * occurrences only see {@link Variable#defs}.\n         * @member {Reference[]} Variable#references\n         */\n        this.references = [];\n\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as custom objects.\n         * @typedef {Object} DefEntry\n         * @property {String} DefEntry.type - the type of the occurrence (e.g.\n         *      \"Parameter\", \"Variable\", ...)\n         * @property {esprima.Identifier} DefEntry.name - the identifier AST node of the occurrence\n         * @property {esprima.Node} DefEntry.node - the enclosing node of the\n         *      identifier\n         * @property {esprima.Node} [DefEntry.parent] - the enclosing statement\n         *      node of the identifier\n         * @member {DefEntry[]} Variable#defs\n         */\n        this.defs = [];\n\n        this.tainted = false;\n        /**\n         * Whether this is a stack variable.\n         * @member {boolean} Variable#stack\n         */\n        this.stack = true;\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Variable#scope\n         */\n        this.scope = scope;\n    }\n\n    Variable.CatchClause = 'CatchClause';\n    Variable.Parameter = 'Parameter';\n    Variable.FunctionName = 'FunctionName';\n    Variable.Variable = 'Variable';\n    Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';\n\n    function isStrictScope(scope, block) {\n        var body, i, iz, stmt, expr;\n\n        // When upper scope is exists and strict, inner scope is also strict.\n        if (scope.upper && scope.upper.isStrict) {\n            return true;\n        }\n\n        if (scope.type === 'function') {\n            body = block.body;\n        } else if (scope.type === 'global') {\n            body = block;\n        } else {\n            return false;\n        }\n\n        if (options.directive) {\n            for (i = 0, iz = body.body.length; i < iz; ++i) {\n                stmt = body.body[i];\n                if (stmt.type !== 'DirectiveStatement') {\n                    break;\n                }\n                if (stmt.raw === '\"use strict\"' || stmt.raw === '\\'use strict\\'') {\n                    return true;\n                }\n            }\n        } else {\n            for (i = 0, iz = body.body.length; i < iz; ++i) {\n                stmt = body.body[i];\n                if (stmt.type !== Syntax.ExpressionStatement) {\n                    break;\n                }\n                expr = stmt.expression;\n                if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {\n                    break;\n                }\n                if (expr.raw != null) {\n                    if (expr.raw === '\"use strict\"' || expr.raw === '\\'use strict\\'') {\n                        return true;\n                    }\n                } else {\n                    if (expr.value === 'use strict') {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @class Scope\n     */\n    function Scope(block, opt) {\n        var variable, body;\n\n        /**\n         * One of 'catch', 'with', 'function' or 'global'.\n         * @member {String} Scope#type\n         */\n        this.type =\n            (block.type === Syntax.CatchClause) ? 'catch' :\n            (block.type === Syntax.WithStatement) ? 'with' :\n            (block.type === Syntax.Program) ? 'global' : 'function';\n         /**\n         * The scoped {@link Variable}s of this scope, as <code>{ Variable.name\n         * : Variable }</code>.\n         * @member {Map} Scope#set\n         */\n        this.set = new Map();\n        /**\n         * The tainted variables of this scope, as <code>{ Variable.name :\n         * boolean }</code>.\n         * @member {Map} Scope#taints */\n        this.taints = new Map();\n        /**\n         * Generally, through the lexical scoping of JS you can always know\n         * which variable an identifier in the source code refers to. There are\n         * a few exceptions to this rule. With 'global' and 'with' scopes you\n         * can only decide at runtime which variable a reference refers to.\n         * Moreover, if 'eval()' is used in a scope, it might introduce new\n         * bindings in this or its prarent scopes.\n         * All those scopes are considered 'dynamic'.\n         * @member {boolean} Scope#dynamic\n         */\n        this.dynamic = this.type === 'global' || this.type === 'with';\n        /**\n         * A reference to the scope-defining syntax node.\n         * @member {esprima.Node} Scope#block\n         */\n        this.block = block;\n         /**\n         * The {@link Reference|references} that are not resolved with this scope.\n         * @member {Reference[]} Scope#through\n         */\n        this.through = [];\n         /**\n         * The scoped {@link Variable}s of this scope. In the case of a\n         * 'function' scope this includes the automatic argument <em>arguments</em> as\n         * its first element, as well as all further formal arguments.\n         * @member {Variable[]} Scope#variables\n         */\n        this.variables = [];\n         /**\n         * Any variable {@link Reference|reference} found in this scope. This\n         * includes occurrences of local variables as well as variables from\n         * parent scopes (including the global scope). For local variables\n         * this also includes defining occurrences (like in a 'var' statement).\n         * In a 'function' scope this does not include the occurrences of the\n         * formal parameter in the parameter list.\n         * @member {Reference[]} Scope#references\n         */\n        this.references = [];\n         /**\n         * List of {@link Reference}s that are left to be resolved (i.e. which\n         * need to be linked to the variable they refer to). Used internally to\n         * resolve bindings during scope analysis. On a finalized scope\n         * analysis, all sopes have <em>left</em> value <strong>null</strong>.\n         * @member {Reference[]} Scope#left\n         */\n        this.left = [];\n         /**\n         * For 'global' and 'function' scopes, this is a self-reference. For\n         * other scope types this is the <em>variableScope</em> value of the\n         * parent scope.\n         * @member {Scope} Scope#variableScope\n         */\n        this.variableScope =\n            (this.type === 'global' || this.type === 'function') ? this : currentScope.variableScope;\n         /**\n         * Whether this scope is created by a FunctionExpression.\n         * @member {boolean} Scope#functionExpressionScope\n         */\n        this.functionExpressionScope = false;\n         /**\n         * Whether this is a scope that contains an 'eval()' invocation.\n         * @member {boolean} Scope#directCallToEvalScope\n         */\n        this.directCallToEvalScope = false;\n         /**\n         * @member {boolean} Scope#thisFound\n         */\n        this.thisFound = false;\n        body = this.type === 'function' ? block.body : block;\n        if (opt.naming) {\n            this.__define(block.id, {\n                type: Variable.FunctionName,\n                name: block.id,\n                node: block\n            });\n            this.functionExpressionScope = true;\n        } else {\n            if (this.type === 'function') {\n                variable = new Variable('arguments', this);\n                this.taints.set('arguments', true);\n                this.set.set('arguments', variable);\n                this.variables.push(variable);\n            }\n\n            if (block.type === Syntax.FunctionExpression && block.id) {\n                new Scope(block, { naming: true });\n            }\n        }\n\n         /**\n         * Reference to the parent {@link Scope|scope}.\n         * @member {Scope} Scope#upper\n         */\n        this.upper = currentScope;\n         /**\n         * Whether 'use strict' is in effect in this scope.\n         * @member {boolean} Scope#isStrict\n         */\n        this.isStrict = isStrictScope(this, block);\n\n         /**\n         * List of nested {@link Scope}s.\n         * @member {Scope[]} Scope#childScopes\n         */\n        this.childScopes = [];\n        if (currentScope) {\n            currentScope.childScopes.push(this);\n        }\n\n\n        // RAII\n        currentScope = this;\n        if (this.type === 'global') {\n            globalScope = this;\n            globalScope.implicit = {\n                set: new Map(),\n                variables: []\n            };\n        }\n        scopes.push(this);\n    }\n\n    Scope.prototype.__close = function __close() {\n        var i, iz, ref, current, node, implicit;\n\n        // Because if this is global environment, upper is null\n        if (!this.dynamic || options.optimistic) {\n            // static resolve\n            for (i = 0, iz = this.left.length; i < iz; ++i) {\n                ref = this.left[i];\n                if (!this.__resolve(ref)) {\n                    this.__delegateToUpperScope(ref);\n                }\n            }\n        } else {\n            // this is \"global\" / \"with\" / \"function with eval\" environment\n            if (this.type === 'with') {\n                for (i = 0, iz = this.left.length; i < iz; ++i) {\n                    ref = this.left[i];\n                    ref.tainted = true;\n                    this.__delegateToUpperScope(ref);\n                }\n            } else {\n                for (i = 0, iz = this.left.length; i < iz; ++i) {\n                    // notify all names are through to global\n                    ref = this.left[i];\n                    current = this;\n                    do {\n                        current.through.push(ref);\n                        current = current.upper;\n                    } while (current);\n                }\n            }\n        }\n\n        if (this.type === 'global') {\n            implicit = [];\n            for (i = 0, iz = this.left.length; i < iz; ++i) {\n                ref = this.left[i];\n                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {\n                    implicit.push(ref.__maybeImplicitGlobal);\n                }\n            }\n\n            // create an implicit global variable from assignment expression\n            for (i = 0, iz = implicit.length; i < iz; ++i) {\n                node = implicit[i];\n                this.__defineImplicit(node.left, {\n                    type: Variable.ImplicitGlobalVariable,\n                    name: node.left,\n                    node: node\n                });\n            }\n        }\n\n        this.left = null;\n        currentScope = this.upper;\n    };\n\n    Scope.prototype.__resolve = function __resolve(ref) {\n        var variable, name;\n        name = ref.identifier.name;\n        if (this.set.has(name)) {\n            variable = this.set.get(name);\n            variable.references.push(ref);\n            variable.stack = variable.stack && ref.from.variableScope === this.variableScope;\n            if (ref.tainted) {\n                variable.tainted = true;\n                this.taints.set(variable.name, true);\n            }\n            ref.resolved = variable;\n            return true;\n        }\n        return false;\n    };\n\n    Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {\n        if (this.upper) {\n            this.upper.left.push(ref);\n        }\n        this.through.push(ref);\n    };\n\n    Scope.prototype.__defineImplicit = function __defineImplicit(node, info) {\n        var name, variable;\n        if (node && node.type === Syntax.Identifier) {\n            name = node.name;\n            if (!this.implicit.set.has(name)) {\n                variable = new Variable(name, this);\n                variable.identifiers.push(node);\n                variable.defs.push(info);\n                this.implicit.set.set(name, variable);\n                this.implicit.variables.push(variable);\n            } else {\n                variable = this.implicit.set.get(name);\n                variable.identifiers.push(node);\n                variable.defs.push(info);\n            }\n        }\n    };\n\n    Scope.prototype.__define = function __define(node, info) {\n        var name, variable;\n        if (node && node.type === Syntax.Identifier) {\n            name = node.name;\n            if (!this.set.has(name)) {\n                variable = new Variable(name, this);\n                variable.identifiers.push(node);\n                variable.defs.push(info);\n                this.set.set(name, variable);\n                this.variables.push(variable);\n            } else {\n                variable = this.set.get(name);\n                variable.identifiers.push(node);\n                variable.defs.push(info);\n            }\n        }\n    };\n\n    Scope.prototype.__referencing = function __referencing(node, assign, writeExpr, maybeImplicitGlobal) {\n        var ref;\n        // because Array element may be null\n        if (node && node.type === Syntax.Identifier) {\n            ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal);\n            this.references.push(ref);\n            this.left.push(ref);\n        }\n    };\n\n    Scope.prototype.__detectEval = function __detectEval() {\n        var current;\n        current = this;\n        this.directCallToEvalScope = true;\n        do {\n            current.dynamic = true;\n            current = current.upper;\n        } while (current);\n    };\n\n    Scope.prototype.__detectThis = function __detectThis() {\n        this.thisFound = true;\n    };\n\n    Scope.prototype.__isClosed = function isClosed() {\n        return this.left === null;\n    };\n\n    // API Scope#resolve(name)\n    // returns resolved reference\n    Scope.prototype.resolve = function resolve(ident) {\n        var ref, i, iz;\n        assert(this.__isClosed(), 'scope should be closed');\n        assert(ident.type === Syntax.Identifier, 'target should be identifier');\n        for (i = 0, iz = this.references.length; i < iz; ++i) {\n            ref = this.references[i];\n            if (ref.identifier === ident) {\n                return ref;\n            }\n        }\n        return null;\n    };\n\n    // API Scope#isStatic\n    // returns this scope is static\n    Scope.prototype.isStatic = function isStatic() {\n        return !this.dynamic;\n    };\n\n    // API Scope#isArgumentsMaterialized\n    // return this scope has materialized arguments\n    Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {\n        // TODO(Constellation)\n        // We can more aggressive on this condition like this.\n        //\n        // function t() {\n        //     // arguments of t is always hidden.\n        //     function arguments() {\n        //     }\n        // }\n        var variable;\n\n        // This is not function scope\n        if (this.type !== 'function') {\n            return true;\n        }\n\n        if (!this.isStatic()) {\n            return true;\n        }\n\n        variable = this.set.get('arguments');\n        assert(variable, 'always have arguments variable');\n        return variable.tainted || variable.references.length  !== 0;\n    };\n\n    // API Scope#isThisMaterialized\n    // return this scope has materialized `this` reference\n    Scope.prototype.isThisMaterialized = function isThisMaterialized() {\n        // This is not function scope\n        if (this.type !== 'function') {\n            return true;\n        }\n        if (!this.isStatic()) {\n            return true;\n        }\n        return this.thisFound;\n    };\n\n    Scope.mangledName = '__$escope$__';\n\n    Scope.prototype.attach = function attach() {\n        if (!this.functionExpressionScope) {\n            this.block[Scope.mangledName] = this;\n        }\n    };\n\n    Scope.prototype.detach = function detach() {\n        if (!this.functionExpressionScope) {\n            delete this.block[Scope.mangledName];\n        }\n    };\n\n    Scope.prototype.isUsedName = function (name) {\n        if (this.set.has(name)) {\n            return true;\n        }\n        for (var i = 0, iz = this.through.length; i < iz; ++i) {\n            if (this.through[i].identifier.name === name) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * @class ScopeManager\n     */\n    function ScopeManager(scopes) {\n        this.scopes = scopes;\n        this.attached = false;\n    }\n\n    // Returns appropliate scope for this node\n    ScopeManager.prototype.__get = function __get(node) {\n        var i, iz, scope;\n        if (this.attached) {\n            return node[Scope.mangledName] || null;\n        }\n        if (Scope.isScopeRequired(node)) {\n            for (i = 0, iz = this.scopes.length; i < iz; ++i) {\n                scope = this.scopes[i];\n                if (!scope.functionExpressionScope) {\n                    if (scope.block === node) {\n                        return scope;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    ScopeManager.prototype.acquire = function acquire(node) {\n        return this.__get(node);\n    };\n\n    ScopeManager.prototype.release = function release(node) {\n        var scope = this.__get(node);\n        if (scope) {\n            scope = scope.upper;\n            while (scope) {\n                if (!scope.functionExpressionScope) {\n                    return scope;\n                }\n                scope = scope.upper;\n            }\n        }\n        return null;\n    };\n\n    ScopeManager.prototype.attach = function attach() {\n        var i, iz;\n        for (i = 0, iz = this.scopes.length; i < iz; ++i) {\n            this.scopes[i].attach();\n        }\n        this.attached = true;\n    };\n\n    ScopeManager.prototype.detach = function detach() {\n        var i, iz;\n        for (i = 0, iz = this.scopes.length; i < iz; ++i) {\n            this.scopes[i].detach();\n        }\n        this.attached = false;\n    };\n\n    Scope.isScopeRequired = function isScopeRequired(node) {\n        return Scope.isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;\n    };\n\n    Scope.isVariableScopeRequired = function isVariableScopeRequired(node) {\n        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;\n    };\n\n    /**\n     * Main interface function. Takes an Esprima syntax tree and returns the\n     * analyzed scopes.\n     * @function analyze\n     * @param {esprima.Tree} tree\n     * @param {Object} providedOptions - Options that tailor the scope analysis\n     * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag\n     * @param {boolean} [providedOptions.directive=false]- the directive flag\n     * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls\n     * @return {ScopeManager}\n     */\n    function analyze(tree, providedOptions) {\n        var resultScopes;\n\n        options = updateDeeply(defaultOptions(), providedOptions);\n        resultScopes = scopes = [];\n        currentScope = null;\n        globalScope = null;\n\n        // attach scope and collect / resolve names\n        estraverse.traverse(tree, {\n            enter: function enter(node) {\n                var i, iz, decl;\n                if (Scope.isScopeRequired(node)) {\n                    new Scope(node, {});\n                }\n\n                switch (node.type) {\n                case Syntax.AssignmentExpression:\n                    if (node.operator === '=') {\n                        currentScope.__referencing(node.left, Reference.WRITE, node.right, (!currentScope.isStrict && node.left.name != null) && node);\n                    } else {\n                        currentScope.__referencing(node.left, Reference.RW, node.right);\n                    }\n                    currentScope.__referencing(node.right);\n                    break;\n\n                case Syntax.ArrayExpression:\n                    for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                        currentScope.__referencing(node.elements[i]);\n                    }\n                    break;\n\n                case Syntax.BlockStatement:\n                    break;\n\n                case Syntax.BinaryExpression:\n                    currentScope.__referencing(node.left);\n                    currentScope.__referencing(node.right);\n                    break;\n\n                case Syntax.BreakStatement:\n                    break;\n\n                case Syntax.CallExpression:\n                    currentScope.__referencing(node.callee);\n                    for (i = 0, iz = node['arguments'].length; i < iz; ++i) {\n                        currentScope.__referencing(node['arguments'][i]);\n                    }\n\n                    // check this is direct call to eval\n                    if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {\n                        currentScope.variableScope.__detectEval();\n                    }\n                    break;\n\n                case Syntax.CatchClause:\n                    currentScope.__define(node.param, {\n                        type: Variable.CatchClause,\n                        name: node.param,\n                        node: node\n                    });\n                    break;\n\n                case Syntax.ConditionalExpression:\n                    currentScope.__referencing(node.test);\n                    currentScope.__referencing(node.consequent);\n                    currentScope.__referencing(node.alternate);\n                    break;\n\n                case Syntax.ContinueStatement:\n                    break;\n\n                case Syntax.DirectiveStatement:\n                    break;\n\n                case Syntax.DoWhileStatement:\n                    currentScope.__referencing(node.test);\n                    break;\n\n                case Syntax.DebuggerStatement:\n                    break;\n\n                case Syntax.EmptyStatement:\n                    break;\n\n                case Syntax.ExpressionStatement:\n                    currentScope.__referencing(node.expression);\n                    break;\n\n                case Syntax.ForStatement:\n                    currentScope.__referencing(node.init);\n                    currentScope.__referencing(node.test);\n                    currentScope.__referencing(node.update);\n                    break;\n\n                case Syntax.ForInStatement:\n                    if (node.left.type === Syntax.VariableDeclaration) {\n                        currentScope.__referencing(node.left.declarations[0].id, Reference.WRITE, null, false);\n                    } else {\n                        currentScope.__referencing(node.left, Reference.WRITE, null, (!currentScope.isStrict && node.left.name != null) && node);\n                    }\n                    currentScope.__referencing(node.right);\n                    break;\n\n                case Syntax.FunctionDeclaration:\n                    // FunctionDeclaration name is defined in upper scope\n                    currentScope.upper.__define(node.id, {\n                        type: Variable.FunctionName,\n                        name: node.id,\n                        node: node\n                    });\n                    for (i = 0, iz = node.params.length; i < iz; ++i) {\n                        currentScope.__define(node.params[i], {\n                            type: Variable.Parameter,\n                            name: node.params[i],\n                            node: node,\n                            index: i\n                        });\n                    }\n                    break;\n\n                case Syntax.FunctionExpression:\n                    // id is defined in upper scope\n                    for (i = 0, iz = node.params.length; i < iz; ++i) {\n                        currentScope.__define(node.params[i], {\n                            type: Variable.Parameter,\n                            name: node.params[i],\n                            node: node,\n                            index: i\n                        });\n                    }\n                    break;\n\n                case Syntax.Identifier:\n                    break;\n\n                case Syntax.IfStatement:\n                    currentScope.__referencing(node.test);\n                    break;\n\n                case Syntax.Literal:\n                    break;\n\n                case Syntax.LabeledStatement:\n                    break;\n\n                case Syntax.LogicalExpression:\n                    currentScope.__referencing(node.left);\n                    currentScope.__referencing(node.right);\n                    break;\n\n                case Syntax.MemberExpression:\n                    currentScope.__referencing(node.object);\n                    if (node.computed) {\n                        currentScope.__referencing(node.property);\n                    }\n                    break;\n\n                case Syntax.NewExpression:\n                    currentScope.__referencing(node.callee);\n                    for (i = 0, iz = node['arguments'].length; i < iz; ++i) {\n                        currentScope.__referencing(node['arguments'][i]);\n                    }\n                    break;\n\n                case Syntax.ObjectExpression:\n                    for (i = 0; i < node.properties.length; i++) {\n                        if (node.properties[i].kind === 'init') {\n                            currentScope.__referencing(node.properties[i].value);\n                        }\n                    }\n                    break;\n\n                case Syntax.Program:\n                    break;\n\n                case Syntax.Property:\n                    break;\n\n                case Syntax.ReturnStatement:\n                    currentScope.__referencing(node.argument);\n                    break;\n\n                case Syntax.SequenceExpression:\n                    for (i = 0, iz = node.expressions.length; i < iz; ++i) {\n                        currentScope.__referencing(node.expressions[i]);\n                    }\n                    break;\n\n                case Syntax.SwitchStatement:\n                    currentScope.__referencing(node.discriminant);\n                    break;\n\n                case Syntax.SwitchCase:\n                    currentScope.__referencing(node.test);\n                    break;\n\n                case Syntax.ThisExpression:\n                    currentScope.variableScope.__detectThis();\n                    break;\n\n                case Syntax.ThrowStatement:\n                    currentScope.__referencing(node.argument);\n                    break;\n\n                case Syntax.TryStatement:\n                    break;\n\n                case Syntax.UnaryExpression:\n                    currentScope.__referencing(node.argument);\n                    break;\n\n                case Syntax.UpdateExpression:\n                    currentScope.__referencing(node.argument, Reference.RW, null);\n                    break;\n\n                case Syntax.VariableDeclaration:\n                    for (i = 0, iz = node.declarations.length; i < iz; ++i) {\n                        decl = node.declarations[i];\n                        currentScope.variableScope.__define(decl.id, {\n                            type: Variable.Variable,\n                            name: decl.id,\n                            node: decl,\n                            index: i,\n                            parent: node\n                        });\n                        if (decl.init) {\n                            // initializer is found\n                            currentScope.__referencing(decl.id, Reference.WRITE, decl.init, false);\n                            currentScope.__referencing(decl.init);\n                        }\n                    }\n                    break;\n\n                case Syntax.VariableDeclarator:\n                    break;\n\n                case Syntax.WhileStatement:\n                    currentScope.__referencing(node.test);\n                    break;\n\n                case Syntax.WithStatement:\n                    // WithStatement object is referenced at upper scope\n                    currentScope.upper.__referencing(node.object);\n                    break;\n                }\n            },\n\n            leave: function leave(node) {\n                while (currentScope && node === currentScope.block) {\n                    currentScope.__close();\n                }\n            }\n        });\n\n        assert(currentScope === null);\n        globalScope = null;\n        scopes = null;\n        options = null;\n\n        return new ScopeManager(resultScopes);\n    }\n\n    /** @name module:escope.version */\n    exports.version = '1.0.3';\n    /** @name module:escope.Reference */\n    exports.Reference = Reference;\n    /** @name module:escope.Variable */\n    exports.Variable = Variable;\n    /** @name module:escope.Scope */\n    exports.Scope = Scope;\n    /** @name module:escope.ScopeManager */\n    exports.ScopeManager = ScopeManager;\n    /** @name module:escope.analyze */\n    exports.analyze = analyze;\n}, this));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/~/escope/escope.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/~/escope/escope.js?");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        isArray,\n        VisitorOption,\n        VisitorKeys,\n        objectCreate,\n        objectKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function ignoreJSHintError() { }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    ignoreJSHintError(shallowCopy);\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    function lowerBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                i = current + 1;\n                len -= diff + 1;\n            } else {\n                len = diff;\n            }\n        }\n        return i;\n    }\n    ignoreJSHintError(lowerBound);\n\n    objectCreate = Object.create || (function () {\n        function F() { }\n\n        return function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    })();\n\n    objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n            keys.push(key);\n        }\n        return keys;\n    };\n\n    function extend(to, from) {\n        var keys = objectKeys(from), key, i, len;\n        for (i = 0, len = keys.length; i < len; i += 1) {\n            key = keys[i];\n            to[key] = from[key];\n        }\n        return to;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],\n        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = visitor.fallback === 'iteration';\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = extend(objectCreate(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = element.wrap || node.type;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = objectKeys(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = element.wrap || node.type;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = objectKeys(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = __webpack_require__(51).version;\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/~/estraverse/estraverse.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/~/estraverse/estraverse.js?");

/***/ },
/* 51 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"estraverse@^2.0.0\",\n\t\t\t\"/home/cs/Projects/rlet/node_modules/sweet.js/node_modules/escope\"\n\t\t]\n\t],\n\t\"_from\": \"estraverse@>=2.0.0 <3.0.0\",\n\t\"_id\": \"estraverse@2.0.0\",\n\t\"_inCache\": true,\n\t\"_location\": \"/sweet.js/estraverse\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.0.0-alpha-5\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"estraverse\",\n\t\t\"raw\": \"estraverse@^2.0.0\",\n\t\t\"rawSpec\": \"^2.0.0\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=2.0.0 <3.0.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/sweet.js/escope\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-2.0.0.tgz\",\n\t\"_shasum\": \"5ae46963243600206674ccb24a09e16674fcdca1\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"estraverse@^2.0.0\",\n\t\"_where\": \"/home/cs/Projects/rlet/node_modules/sweet.js/node_modules/escope\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/estraverse/issues\"\n\t},\n\t\"dependencies\": {},\n\t\"description\": \"ECMAScript JS AST traversal functions\",\n\t\"devDependencies\": {\n\t\t\"chai\": \"^2.1.1\",\n\t\t\"coffee-script\": \"^1.8.0\",\n\t\t\"espree\": \"^1.11.0\",\n\t\t\"gulp\": \"^3.8.10\",\n\t\t\"gulp-bump\": \"^0.2.2\",\n\t\t\"gulp-filter\": \"^2.0.0\",\n\t\t\"gulp-git\": \"^1.0.1\",\n\t\t\"gulp-tag-version\": \"^1.2.1\",\n\t\t\"jshint\": \"^2.5.6\",\n\t\t\"mocha\": \"^2.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"5ae46963243600206674ccb24a09e16674fcdca1\",\n\t\t\"tarball\": \"http://registry.npmjs.org/estraverse/-/estraverse-2.0.0.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.10.0\"\n\t},\n\t\"gitHead\": \"d8bc726f126817cc03c7a4e751528edb19db0ffb\",\n\t\"homepage\": \"https://github.com/estools/estraverse\",\n\t\"installable\": true,\n\t\"licenses\": [\n\t\t{\n\t\t\t\"type\": \"BSD\",\n\t\t\t\"url\": \"http://github.com/estools/estraverse/raw/master/LICENSE.BSD\"\n\t\t}\n\t],\n\t\"main\": \"estraverse.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t}\n\t],\n\t\"name\": \"estraverse\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"http://github.com/estools/estraverse.git\"\n\t},\n\t\"scripts\": {\n\t\t\"lint\": \"jshint estraverse.js\",\n\t\t\"test\": \"npm run-script lint && npm run-script unit-test\",\n\t\t\"unit-test\": \"mocha --compilers coffee:coffee-script/register\"\n\t},\n\t\"version\": \"2.0.0\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sweet.js/~/estraverse/package.json\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/~/estraverse/package.json?");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(42);\nvar wordwrap = __webpack_require__(53);\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n        require('optimist')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n        require('optimist').argv\n    to get a parsed version of process.argv.\n*/\n\nvar inst = Argv(process.argv.slice(2));\nObject.keys(inst).forEach(function (key) {\n    Argv[key] = typeof inst[key] == 'function'\n        ? inst[key].bind(inst)\n        : inst[key];\n});\n\nvar exports = module.exports = Argv;\nfunction Argv (args, cwd) {\n    var self = {};\n    if (!cwd) cwd = process.cwd();\n    \n    self.$0 = process.argv\n        .slice(0,2)\n        .map(function (x) {\n            var b = rebase(cwd, x);\n            return x.match(/^\\//) && b.length < x.length\n                ? b : x\n        })\n        .join(' ')\n    ;\n    \n    if (process.env._ != undefined && process.argv[1] == process.env._) {\n        self.$0 = process.env._.replace(\n            path.dirname(process.execPath) + '/', ''\n        );\n    }\n    \n    var flags = { bools : {}, strings : {} };\n    \n    self.boolean = function (bools) {\n        if (!Array.isArray(bools)) {\n            bools = [].slice.call(arguments);\n        }\n        \n        bools.forEach(function (name) {\n            flags.bools[name] = true;\n        });\n        \n        return self;\n    };\n    \n    self.string = function (strings) {\n        if (!Array.isArray(strings)) {\n            strings = [].slice.call(arguments);\n        }\n        \n        strings.forEach(function (name) {\n            flags.strings[name] = true;\n        });\n        \n        return self;\n    };\n    \n    var aliases = {};\n    self.alias = function (x, y) {\n        if (typeof x === 'object') {\n            Object.keys(x).forEach(function (key) {\n                self.alias(key, x[key]);\n            });\n        }\n        else if (Array.isArray(y)) {\n            y.forEach(function (yy) {\n                self.alias(x, yy);\n            });\n        }\n        else {\n            var zs = (aliases[x] || []).concat(aliases[y] || []).concat(x, y);\n            aliases[x] = zs.filter(function (z) { return z != x });\n            aliases[y] = zs.filter(function (z) { return z != y });\n        }\n        \n        return self;\n    };\n    \n    var demanded = {};\n    self.demand = function (keys) {\n        if (typeof keys == 'number') {\n            if (!demanded._) demanded._ = 0;\n            demanded._ += keys;\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach(function (key) {\n                self.demand(key);\n            });\n        }\n        else {\n            demanded[keys] = true;\n        }\n        \n        return self;\n    };\n    \n    var usage;\n    self.usage = function (msg, opts) {\n        if (!opts && typeof msg === 'object') {\n            opts = msg;\n            msg = null;\n        }\n        \n        usage = msg;\n        \n        if (opts) self.options(opts);\n        \n        return self;\n    };\n    \n    function fail (msg) {\n        self.showHelp();\n        if (msg) console.error(msg);\n        process.exit(1);\n    }\n    \n    var checks = [];\n    self.check = function (f) {\n        checks.push(f);\n        return self;\n    };\n    \n    var defaults = {};\n    self.default = function (key, value) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.default(k, key[k]);\n            });\n        }\n        else {\n            defaults[key] = value;\n        }\n        \n        return self;\n    };\n    \n    var descriptions = {};\n    self.describe = function (key, desc) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.describe(k, key[k]);\n            });\n        }\n        else {\n            descriptions[key] = desc;\n        }\n        return self;\n    };\n    \n    self.parse = function (args) {\n        return Argv(args).argv;\n    };\n    \n    self.option = self.options = function (key, opt) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (opt.alias) self.alias(key, opt.alias);\n            if (opt.demand) self.demand(key);\n            if (typeof opt.default !== 'undefined') {\n                self.default(key, opt.default);\n            }\n            \n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n            }\n            \n            var desc = opt.describe || opt.description || opt.desc;\n            if (desc) {\n                self.describe(key, desc);\n            }\n        }\n        \n        return self;\n    };\n    \n    var wrap = null;\n    self.wrap = function (cols) {\n        wrap = cols;\n        return self;\n    };\n    \n    self.showHelp = function (fn) {\n        if (!fn) fn = console.error;\n        fn(self.help());\n    };\n    \n    self.help = function () {\n        var keys = Object.keys(\n            Object.keys(descriptions)\n            .concat(Object.keys(demanded))\n            .concat(Object.keys(defaults))\n            .reduce(function (acc, key) {\n                if (key !== '_') acc[key] = true;\n                return acc;\n            }, {})\n        );\n        \n        var help = keys.length ? [ 'Options:' ] : [];\n        \n        if (usage) {\n            help.unshift(usage.replace(/\\$0/g, self.$0), '');\n        }\n        \n        var switches = keys.reduce(function (acc, key) {\n            acc[key] = [ key ].concat(aliases[key] || [])\n                .map(function (sw) {\n                    return (sw.length > 1 ? '--' : '-') + sw\n                })\n                .join(', ')\n            ;\n            return acc;\n        }, {});\n        \n        var switchlen = longest(Object.keys(switches).map(function (s) {\n            return switches[s] || '';\n        }));\n        \n        var desclen = longest(Object.keys(descriptions).map(function (d) { \n            return descriptions[d] || '';\n        }));\n        \n        keys.forEach(function (key) {\n            var kswitch = switches[key];\n            var desc = descriptions[key] || '';\n            \n            if (wrap) {\n                desc = wordwrap(switchlen + 4, wrap)(desc)\n                    .slice(switchlen + 4)\n                ;\n            }\n            \n            var spadding = new Array(\n                Math.max(switchlen - kswitch.length + 3, 0)\n            ).join(' ');\n            \n            var dpadding = new Array(\n                Math.max(desclen - desc.length + 1, 0)\n            ).join(' ');\n            \n            var type = null;\n            \n            if (flags.bools[key]) type = '[boolean]';\n            if (flags.strings[key]) type = '[string]';\n            \n            if (!wrap && dpadding.length > 0) {\n                desc += dpadding;\n            }\n            \n            var prelude = '  ' + kswitch + spadding;\n            var extra = [\n                type,\n                demanded[key]\n                    ? '[required]'\n                    : null\n                ,\n                defaults[key] !== undefined\n                    ? '[default: ' + JSON.stringify(defaults[key]) + ']'\n                    : null\n                ,\n            ].filter(Boolean).join('  ');\n            \n            var body = [ desc, extra ].filter(Boolean).join('  ');\n            \n            if (wrap) {\n                var dlines = desc.split('\\n');\n                var dlen = dlines.slice(-1)[0].length\n                    + (dlines.length === 1 ? prelude.length : 0)\n                \n                body = desc + (dlen + extra.length > wrap - 2\n                    ? '\\n'\n                        + new Array(wrap - extra.length + 1).join(' ')\n                        + extra\n                    : new Array(wrap - extra.length - dlen + 1).join(' ')\n                        + extra\n                );\n            }\n            \n            help.push(prelude + body);\n        });\n        \n        help.push('');\n        return help.join('\\n');\n    };\n    \n    Object.defineProperty(self, 'argv', {\n        get : parseArgs,\n        enumerable : true,\n    });\n    \n    function parseArgs () {\n        var argv = { _ : [], $0 : self.$0 };\n        Object.keys(flags.bools).forEach(function (key) {\n            setArg(key, defaults[key] || false);\n        });\n        \n        function setArg (key, val) {\n            var num = Number(val);\n            var value = typeof val !== 'string' || isNaN(num) ? val : num;\n            if (flags.strings[key]) value = val;\n            \n            setKey(argv, key.split('.'), value);\n            \n            (aliases[key] || []).forEach(function (x) {\n                argv[x] = argv[key];\n            });\n        }\n        \n        for (var i = 0; i < args.length; i++) {\n            var arg = args[i];\n            \n            if (arg === '--') {\n                argv._.push.apply(argv._, args.slice(i + 1));\n                break;\n            }\n            else if (arg.match(/^--.+=/)) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n                setArg(m[1], m[2]);\n            }\n            else if (arg.match(/^--no-.+/)) {\n                var key = arg.match(/^--no-(.+)/)[1];\n                setArg(key, false);\n            }\n            else if (arg.match(/^--.+/)) {\n                var key = arg.match(/^--(.+)/)[1];\n                var next = args[i + 1];\n                if (next !== undefined && !next.match(/^-/)\n                && !flags.bools[key]\n                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                    setArg(key, next);\n                    i++;\n                }\n                else if (/^(true|false)$/.test(next)) {\n                    setArg(key, next === 'true');\n                    i++;\n                }\n                else {\n                    setArg(key, true);\n                }\n            }\n            else if (arg.match(/^-[^-]+/)) {\n                var letters = arg.slice(1,-1).split('');\n                \n                var broken = false;\n                for (var j = 0; j < letters.length; j++) {\n                    if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                        setArg(letters[j], arg.slice(j+2));\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], true);\n                    }\n                }\n                \n                if (!broken) {\n                    var key = arg.slice(-1)[0];\n                    \n                    if (args[i+1] && !args[i+1].match(/^-/)\n                    && !flags.bools[key]\n                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                        setArg(key, args[i+1]);\n                        i++;\n                    }\n                    else if (args[i+1] && /true|false/.test(args[i+1])) {\n                        setArg(key, args[i+1] === 'true');\n                        i++;\n                    }\n                    else {\n                        setArg(key, true);\n                    }\n                }\n            }\n            else {\n                var n = Number(arg);\n                argv._.push(flags.strings['_'] || isNaN(n) ? arg : n);\n            }\n        }\n        \n        Object.keys(defaults).forEach(function (key) {\n            if (!(key in argv)) {\n                argv[key] = defaults[key];\n                if (key in aliases) {\n                    argv[aliases[key]] = defaults[key];\n                }\n            }\n        });\n        \n        if (demanded._ && argv._.length < demanded._) {\n            fail('Not enough non-option arguments: got '\n                + argv._.length + ', need at least ' + demanded._\n            );\n        }\n        \n        var missing = [];\n        Object.keys(demanded).forEach(function (key) {\n            if (!argv[key]) missing.push(key);\n        });\n        \n        if (missing.length) {\n            fail('Missing required arguments: ' + missing.join(', '));\n        }\n        \n        checks.forEach(function (f) {\n            try {\n                if (f(argv) === false) {\n                    fail('Argument check failed: ' + f.toString());\n                }\n            }\n            catch (err) {\n                fail(err)\n            }\n        });\n        \n        return argv;\n    }\n    \n    function longest (xs) {\n        return Math.max.apply(\n            null,\n            xs.map(function (x) { return x.length })\n        );\n    }\n    \n    return self;\n};\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase;\nfunction rebase (base, dir) {\n    var ds = path.normalize(dir).split('/').slice(1);\n    var bs = path.normalize(base).split('/').slice(1);\n    \n    for (var i = 0; ds[i] && ds[i] == bs[i]; i++);\n    ds.splice(0, i); bs.splice(0, i);\n    \n    var p = path.normalize(\n        bs.map(function () { return '..' }).concat(ds).join('/')\n    ).replace(/\\/$/,'').replace(/^$/, '.');\n    return p.match(/^[.\\/]/) ? p : './' + p;\n};\n\nfunction setKey (obj, keys, value) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        if (o[key] === undefined) o[key] = {};\n        o = o[key];\n    });\n    \n    var key = keys[keys.length - 1];\n    if (o[key] === undefined || typeof o[key] === 'boolean') {\n        o[key] = value;\n    }\n    else if (Array.isArray(o[key])) {\n        o[key].push(value);\n    }\n    else {\n        o[key] = [ o[key], value ];\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/optimist/index.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/optimist/index.js?");

/***/ },
/* 53 */
/***/ function(module, exports) {

	eval("var wordwrap = module.exports = function (start, stop, params) {\n    if (typeof start === 'object') {\n        params = start;\n        start = params.start;\n        stop = params.stop;\n    }\n    \n    if (typeof stop === 'object') {\n        params = stop;\n        start = start || params.start;\n        stop = undefined;\n    }\n    \n    if (!stop) {\n        stop = start;\n        start = 0;\n    }\n    \n    if (!params) params = {};\n    var mode = params.mode || 'soft';\n    var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n    \n    return function (text) {\n        var chunks = text.toString()\n            .split(re)\n            .reduce(function (acc, x) {\n                if (mode === 'hard') {\n                    for (var i = 0; i < x.length; i += stop - start) {\n                        acc.push(x.slice(i, i + stop - start));\n                    }\n                }\n                else acc.push(x)\n                return acc;\n            }, [])\n        ;\n        \n        return chunks.reduce(function (lines, rawChunk) {\n            if (rawChunk === '') return lines;\n            \n            var chunk = rawChunk.replace(/\\t/g, '    ');\n            \n            var i = lines.length - 1;\n            if (lines[i].length + chunk.length > stop) {\n                lines[i] = lines[i].replace(/\\s+$/, '');\n                \n                chunk.split(/\\n/).forEach(function (c) {\n                    lines.push(\n                        new Array(start + 1).join(' ')\n                        + c.replace(/^\\s+/, '')\n                    );\n                });\n            }\n            else if (chunk.match(/\\n/)) {\n                var xs = chunk.split(/\\n/);\n                lines[i] += xs.shift();\n                xs.forEach(function (c) {\n                    lines.push(\n                        new Array(start + 1).join(' ')\n                        + c.replace(/^\\s+/, '')\n                    );\n                });\n            }\n            else {\n                lines[i] += chunk;\n            }\n            \n            return lines;\n        }, [ new Array(start + 1).join(' ') ]).join('\\n');\n    };\n};\n\nwordwrap.soft = wordwrap;\n\nwordwrap.hard = function (start, stop) {\n    return wordwrap(start, stop, { mode : 'hard' });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/wordwrap/index.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/wordwrap/index.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n/**\n * Main interface function. Takes an Esprima syntax tree and returns the\n * analyzed scopes.\n * @function analyze\n * @param {esprima.Tree} tree\n * @param {Object} providedOptions - Options that tailor the scope analysis\n * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag\n * @param {boolean} [providedOptions.directive=false]- the directive flag\n * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls\n * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole\n * script is executed under node.js environment. When enabled, escope adds\n * a function scope immediately following the global scope.\n * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'\n * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered\n * @return {ScopeManager}\n */\nexports.analyze = analyze;\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>\n  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Escope (<a href=\"http://github.com/estools/escope\">escope</a>) is an <a\n * href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>\n * scope analyzer extracted from the <a\n * href=\"http://github.com/estools/esmangle\">esmangle project</a/>.\n * <p>\n * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that\n * program where different occurrences of the same identifier refer to the same\n * variable. With each scope the contained variables are collected, and each\n * identifier reference in code is linked to its corresponding variable (if\n * possible).\n * <p>\n * <em>escope</em> works on a syntax tree of the parsed source code which has\n * to adhere to the <a\n * href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">\n * Mozilla Parser API</a>. E.g. <a href=\"http://esprima.org\">esprima</a> is a parser\n * that produces such syntax trees.\n * <p>\n * The main interface is the {@link analyze} function.\n * @module escope\n */\n\n/*jslint bitwise:true */\n\nvar assert = _interopRequire(__webpack_require__(55));\n\nvar ScopeManager = _interopRequire(__webpack_require__(59));\n\nvar Referencer = _interopRequire(__webpack_require__(125));\n\nvar Reference = _interopRequire(__webpack_require__(122));\n\nvar Variable = _interopRequire(__webpack_require__(123));\n\nvar Scope = _interopRequire(__webpack_require__(105));\n\nvar version = __webpack_require__(131).version;\n\nfunction defaultOptions() {\n    return {\n        optimistic: false,\n        directive: false,\n        nodejsScope: false,\n        sourceType: \"script\", // one of ['script', 'module']\n        ecmaVersion: 5\n    };\n}\n\nfunction updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n        return typeof target === \"object\" && target instanceof Object && !(target instanceof RegExp);\n    }\n\n    for (key in override) {\n        if (override.hasOwnProperty(key)) {\n            val = override[key];\n            if (isHashObject(val)) {\n                if (isHashObject(target[key])) {\n                    updateDeeply(target[key], val);\n                } else {\n                    target[key] = updateDeeply({}, val);\n                }\n            } else {\n                target[key] = val;\n            }\n        }\n    }\n    return target;\n}\nfunction analyze(tree, providedOptions) {\n    var scopeManager, referencer, options;\n\n    options = updateDeeply(defaultOptions(), providedOptions);\n\n    scopeManager = new ScopeManager(options);\n\n    referencer = new Referencer(scopeManager);\n    referencer.visit(tree);\n\n    assert(scopeManager.__currentScope === null, \"currentScope should be null.\");\n\n    return scopeManager;\n}\n\nexports.version = version;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\nexports.Reference = Reference;\nexports.Variable = Variable;\nexports.Scope = Scope;\nexports.ScopeManager = ScopeManager;\n\n/** @name module:escope.version */\n\n/** @name module:escope.Reference */\n\n/** @name module:escope.Variable */\n\n/** @name module:escope.Scope */\n\n/** @name module:escope.ScopeManager */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBNkdnQixPQUFPLEdBQVAsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBM0RoQixNQUFNLDJCQUFNLFFBQVE7O0lBRXBCLFlBQVksMkJBQU0saUJBQWlCOztJQUNuQyxVQUFVLDJCQUFNLGNBQWM7O0lBQzlCLFNBQVMsMkJBQU0sYUFBYTs7SUFDNUIsUUFBUSwyQkFBTSxZQUFZOztJQUMxQixLQUFLLDJCQUFNLFNBQVM7O0lBQ2xCLE9BQU8sV0FBUSxpQkFBaUIsRUFBaEMsT0FBTzs7QUFFaEIsU0FBUyxjQUFjLEdBQUc7QUFDdEIsV0FBTztBQUNILGtCQUFVLEVBQUUsS0FBSztBQUNqQixpQkFBUyxFQUFFLEtBQUs7QUFDaEIsbUJBQVcsRUFBRSxLQUFLO0FBQ2xCLGtCQUFVLEVBQUUsUUFBUTtBQUNwQixtQkFBVyxFQUFFLENBQUM7S0FDakIsQ0FBQztDQUNMOztBQUVELFNBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDcEMsUUFBSSxHQUFHLEVBQUUsR0FBRyxDQUFDOztBQUViLGFBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUMxQixlQUFPLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxNQUFNLFlBQVksTUFBTSxJQUFJLEVBQUUsTUFBTSxZQUFZLE1BQU0sQ0FBQSxBQUFDLENBQUM7S0FDaEc7O0FBRUQsU0FBSyxHQUFHLElBQUksUUFBUSxFQUFFO0FBQ2xCLFlBQUksUUFBUSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUM5QixlQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BCLGdCQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNuQixvQkFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDM0IsZ0NBQVksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQ2xDLE1BQU07QUFDSCwwQkFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQ3ZDO2FBQ0osTUFBTTtBQUNILHNCQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO2FBQ3JCO1NBQ0o7S0FDSjtBQUNELFdBQU8sTUFBTSxDQUFDO0NBQ2pCO0FBa0JNLFNBQVMsT0FBTyxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUU7QUFDM0MsUUFBSSxZQUFZLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQzs7QUFFdEMsV0FBTyxHQUFHLFlBQVksQ0FBQyxjQUFjLEVBQUUsRUFBRSxlQUFlLENBQUMsQ0FBQzs7QUFFMUQsZ0JBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFekMsY0FBVSxHQUFHLElBQUksVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzFDLGNBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXZCLFVBQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxLQUFLLElBQUksRUFBRSw4QkFBOEIsQ0FBQyxDQUFDOztBQUU3RSxXQUFPLFlBQVksQ0FBQztDQUN2Qjs7UUFJRyxPQUFPLEdBQVAsT0FBTzs7O1FBRVAsU0FBUyxHQUFULFNBQVM7UUFFVCxRQUFRLEdBQVIsUUFBUTtRQUVSLEtBQUssR0FBTCxLQUFLO1FBRUwsWUFBWSxHQUFaLFlBQVkiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBBbGV4IFNldmlsbGUgPGhpQGFsZXhhbmRlcnNldmlsbGUuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTQgVGhpYWdvIGRlIEFycnVkYSA8dHBhZGlsaGE4NEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLyoqXG4gKiBFc2NvcGUgKDxhIGhyZWY9XCJodHRwOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29wZVwiPmVzY29wZTwvYT4pIGlzIGFuIDxhXG4gKiBocmVmPVwiaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9zdGFuZGFyZHMvRWNtYS0yNjIuaHRtXCI+RUNNQVNjcmlwdDwvYT5cbiAqIHNjb3BlIGFuYWx5emVyIGV4dHJhY3RlZCBmcm9tIHRoZSA8YVxuICogaHJlZj1cImh0dHA6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNtYW5nbGVcIj5lc21hbmdsZSBwcm9qZWN0PC9hLz4uXG4gKiA8cD5cbiAqIDxlbT5lc2NvcGU8L2VtPiBmaW5kcyBsZXhpY2FsIHNjb3BlcyBpbiBhIHNvdXJjZSBwcm9ncmFtLCBpLmUuIGFyZWFzIG9mIHRoYXRcbiAqIHByb2dyYW0gd2hlcmUgZGlmZmVyZW50IG9jY3VycmVuY2VzIG9mIHRoZSBzYW1lIGlkZW50aWZpZXIgcmVmZXIgdG8gdGhlIHNhbWVcbiAqIHZhcmlhYmxlLiBXaXRoIGVhY2ggc2NvcGUgdGhlIGNvbnRhaW5lZCB2YXJpYWJsZXMgYXJlIGNvbGxlY3RlZCwgYW5kIGVhY2hcbiAqIGlkZW50aWZpZXIgcmVmZXJlbmNlIGluIGNvZGUgaXMgbGlua2VkIHRvIGl0cyBjb3JyZXNwb25kaW5nIHZhcmlhYmxlIChpZlxuICogcG9zc2libGUpLlxuICogPHA+XG4gKiA8ZW0+ZXNjb3BlPC9lbT4gd29ya3Mgb24gYSBzeW50YXggdHJlZSBvZiB0aGUgcGFyc2VkIHNvdXJjZSBjb2RlIHdoaWNoIGhhc1xuICogdG8gYWRoZXJlIHRvIHRoZSA8YVxuICogaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcIj5cbiAqIE1vemlsbGEgUGFyc2VyIEFQSTwvYT4uIEUuZy4gPGEgaHJlZj1cImh0dHA6Ly9lc3ByaW1hLm9yZ1wiPmVzcHJpbWE8L2E+IGlzIGEgcGFyc2VyXG4gKiB0aGF0IHByb2R1Y2VzIHN1Y2ggc3ludGF4IHRyZWVzLlxuICogPHA+XG4gKiBUaGUgbWFpbiBpbnRlcmZhY2UgaXMgdGhlIHtAbGluayBhbmFseXplfSBmdW5jdGlvbi5cbiAqIEBtb2R1bGUgZXNjb3BlXG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTp0cnVlICovXG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuaW1wb3J0IFNjb3BlTWFuYWdlciBmcm9tICcuL3Njb3BlLW1hbmFnZXInO1xuaW1wb3J0IFJlZmVyZW5jZXIgZnJvbSAnLi9yZWZlcmVuY2VyJztcbmltcG9ydCBSZWZlcmVuY2UgZnJvbSAnLi9yZWZlcmVuY2UnO1xuaW1wb3J0IFZhcmlhYmxlIGZyb20gJy4vdmFyaWFibGUnO1xuaW1wb3J0IFNjb3BlIGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICBkaXJlY3RpdmU6IGZhbHNlLFxuICAgICAgICBub2RlanNTY29wZTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVR5cGU6ICdzY3JpcHQnLCAgLy8gb25lIG9mIFsnc2NyaXB0JywgJ21vZHVsZSddXG4gICAgICAgIGVjbWFWZXJzaW9uOiA1XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVlcGx5KHRhcmdldCwgb3ZlcnJpZGUpIHtcbiAgICB2YXIga2V5LCB2YWw7XG5cbiAgICBmdW5jdGlvbiBpc0hhc2hPYmplY3QodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgIGlmIChvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YWwgPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVlcGx5KHRhcmdldFtrZXldLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdXBkYXRlRGVlcGx5KHt9LCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYWluIGludGVyZmFjZSBmdW5jdGlvbi4gVGFrZXMgYW4gRXNwcmltYSBzeW50YXggdHJlZSBhbmQgcmV0dXJucyB0aGVcbiAqIGFuYWx5emVkIHNjb3Blcy5cbiAqIEBmdW5jdGlvbiBhbmFseXplXG4gKiBAcGFyYW0ge2VzcHJpbWEuVHJlZX0gdHJlZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3ZpZGVkT3B0aW9ucyAtIE9wdGlvbnMgdGhhdCB0YWlsb3IgdGhlIHNjb3BlIGFuYWx5c2lzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm92aWRlZE9wdGlvbnMub3B0aW1pc3RpYz1mYWxzZV0gLSB0aGUgb3B0aW1pc3RpYyBmbGFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm92aWRlZE9wdGlvbnMuZGlyZWN0aXZlPWZhbHNlXS0gdGhlIGRpcmVjdGl2ZSBmbGFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm92aWRlZE9wdGlvbnMuaWdub3JlRXZhbD1mYWxzZV0tIHdoZXRoZXIgdG8gY2hlY2sgJ2V2YWwoKScgY2FsbHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5ub2RlanNTY29wZT1mYWxzZV0tIHdoZXRoZXIgdGhlIHdob2xlXG4gKiBzY3JpcHQgaXMgZXhlY3V0ZWQgdW5kZXIgbm9kZS5qcyBlbnZpcm9ubWVudC4gV2hlbiBlbmFibGVkLCBlc2NvcGUgYWRkc1xuICogYSBmdW5jdGlvbiBzY29wZSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIGdsb2JhbCBzY29wZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdmlkZWRPcHRpb25zLnNvdXJjZVR5cGU9J3NjcmlwdCddLSB0aGUgc291cmNlIHR5cGUgb2YgdGhlIHNjcmlwdC4gb25lIG9mICdzY3JpcHQnIGFuZCAnbW9kdWxlJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcm92aWRlZE9wdGlvbnMuZWNtYVZlcnNpb249NV0tIHdoaWNoIEVDTUFTY3JpcHQgdmVyc2lvbiBpcyBjb25zaWRlcmVkXG4gKiBAcmV0dXJuIHtTY29wZU1hbmFnZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplKHRyZWUsIHByb3ZpZGVkT3B0aW9ucykge1xuICAgIHZhciBzY29wZU1hbmFnZXIsIHJlZmVyZW5jZXIsIG9wdGlvbnM7XG5cbiAgICBvcHRpb25zID0gdXBkYXRlRGVlcGx5KGRlZmF1bHRPcHRpb25zKCksIHByb3ZpZGVkT3B0aW9ucyk7XG5cbiAgICBzY29wZU1hbmFnZXIgPSBuZXcgU2NvcGVNYW5hZ2VyKG9wdGlvbnMpO1xuXG4gICAgcmVmZXJlbmNlciA9IG5ldyBSZWZlcmVuY2VyKHNjb3BlTWFuYWdlcik7XG4gICAgcmVmZXJlbmNlci52aXNpdCh0cmVlKTtcblxuICAgIGFzc2VydChzY29wZU1hbmFnZXIuX19jdXJyZW50U2NvcGUgPT09IG51bGwsICdjdXJyZW50U2NvcGUgc2hvdWxkIGJlIG51bGwuJyk7XG5cbiAgICByZXR1cm4gc2NvcGVNYW5hZ2VyO1xufVxuXG5leHBvcnQge1xuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLnZlcnNpb24gKi9cbiAgICB2ZXJzaW9uLFxuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLlJlZmVyZW5jZSAqL1xuICAgIFJlZmVyZW5jZSxcbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS5WYXJpYWJsZSAqL1xuICAgIFZhcmlhYmxlLFxuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLlNjb3BlICovXG4gICAgU2NvcGUsXG4gICAgLyoqIEBuYW1lIG1vZHVsZTplc2NvcGUuU2NvcGVNYW5hZ2VyICovXG4gICAgU2NvcGVNYW5hZ2VyXG59O1xuXG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/index.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/index.js?");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar util = __webpack_require__(56);\n\nvar pSlice = Array.prototype.slice;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n  else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = stackStartFunction.name;\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && !isFinite(value)) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b)) {\n    return a === b;\n  }\n  var aIsArgs = isArguments(a),\n      bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  var ka = objectKeys(a),\n      kb = objectKeys(b),\n      key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/assert/assert.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/assert/assert.js?");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(57);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(58);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/util/util.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/util/util.js?");

/***/ },
/* 57 */
/***/ function(module, exports) {

	eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/util/support/isBufferBrowser.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/util/support/isBufferBrowser.js?");

/***/ },
/* 58 */
/***/ function(module, exports) {

	eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/inherits/inherits_browser.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar WeakMap = _interopRequire(__webpack_require__(60));\n\nvar _scope = __webpack_require__(105);\n\nvar Scope = _interopRequire(_scope);\n\nvar assert = _interopRequire(__webpack_require__(55));\n\nvar GlobalScope = _scope.GlobalScope;\nvar CatchScope = _scope.CatchScope;\nvar WithScope = _scope.WithScope;\nvar ModuleScope = _scope.ModuleScope;\nvar ClassScope = _scope.ClassScope;\nvar SwitchScope = _scope.SwitchScope;\nvar FunctionScope = _scope.FunctionScope;\nvar ForScope = _scope.ForScope;\nvar TDZScope = _scope.TDZScope;\nvar FunctionExpressionNameScope = _scope.FunctionExpressionNameScope;\nvar BlockScope = _scope.BlockScope;\n\n/**\n * @class ScopeManager\n */\n\nvar ScopeManager = (function () {\n    function ScopeManager(options) {\n        _classCallCheck(this, ScopeManager);\n\n        this.scopes = [];\n        this.globalScope = null;\n        this.__nodeToScope = new WeakMap();\n        this.__currentScope = null;\n        this.__options = options;\n        this.__declaredVariables = new WeakMap();\n    }\n\n    _createClass(ScopeManager, {\n        __useDirective: {\n            value: function __useDirective() {\n                return this.__options.directive;\n            }\n        },\n        __isOptimistic: {\n            value: function __isOptimistic() {\n                return this.__options.optimistic;\n            }\n        },\n        __ignoreEval: {\n            value: function __ignoreEval() {\n                return this.__options.ignoreEval;\n            }\n        },\n        __isNodejsScope: {\n            value: function __isNodejsScope() {\n                return this.__options.nodejsScope;\n            }\n        },\n        isModule: {\n            value: function isModule() {\n                return this.__options.sourceType === \"module\";\n            }\n        },\n        __get: {\n\n            // Returns appropriate scope for this node.\n\n            value: function __get(node) {\n                return this.__nodeToScope.get(node);\n            }\n        },\n        getDeclaredVariables: {\n\n            /**\n             * Get variables that are declared by the node.\n             *\n             * \"are declared by the node\" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.\n             * If the node declares nothing, this method returns an empty array.\n             * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.\n             *\n             * @param {Esprima.Node} node - a node to get.\n             * @returns {Variable[]} variables that declared by the node.\n             */\n\n            value: function getDeclaredVariables(node) {\n                return this.__declaredVariables.get(node) || [];\n            }\n        },\n        acquire: {\n\n            /**\n             * acquire scope from node.\n             * @method ScopeManager#acquire\n             * @param {Esprima.Node} node - node for the acquired scope.\n             * @param {boolean=} inner - look up the most inner scope, default value is false.\n             * @return {Scope?}\n             */\n\n            value: function acquire(node, inner) {\n                var scopes, scope, i, iz;\n\n                function predicate(scope) {\n                    if (scope.type === \"function\" && scope.functionExpressionScope) {\n                        return false;\n                    }\n                    if (scope.type === \"TDZ\") {\n                        return false;\n                    }\n                    return true;\n                }\n\n                scopes = this.__get(node);\n                if (!scopes || scopes.length === 0) {\n                    return null;\n                }\n\n                // Heuristic selection from all scopes.\n                // If you would like to get all scopes, please use ScopeManager#acquireAll.\n                if (scopes.length === 1) {\n                    return scopes[0];\n                }\n\n                if (inner) {\n                    for (i = scopes.length - 1; i >= 0; --i) {\n                        scope = scopes[i];\n                        if (predicate(scope)) {\n                            return scope;\n                        }\n                    }\n                } else {\n                    for (i = 0, iz = scopes.length; i < iz; ++i) {\n                        scope = scopes[i];\n                        if (predicate(scope)) {\n                            return scope;\n                        }\n                    }\n                }\n\n                return null;\n            }\n        },\n        acquireAll: {\n\n            /**\n             * acquire all scopes from node.\n             * @method ScopeManager#acquireAll\n             * @param {Esprima.Node} node - node for the acquired scope.\n             * @return {Scope[]?}\n             */\n\n            value: function acquireAll(node) {\n                return this.__get(node);\n            }\n        },\n        release: {\n\n            /**\n             * release the node.\n             * @method ScopeManager#release\n             * @param {Esprima.Node} node - releasing node.\n             * @param {boolean=} inner - look up the most inner scope, default value is false.\n             * @return {Scope?} upper scope for the node.\n             */\n\n            value: function release(node, inner) {\n                var scopes, scope;\n                scopes = this.__get(node);\n                if (scopes && scopes.length) {\n                    scope = scopes[0].upper;\n                    if (!scope) {\n                        return null;\n                    }\n                    return this.acquire(scope.block, inner);\n                }\n                return null;\n            }\n        },\n        attach: {\n            value: function attach() {}\n        },\n        detach: {\n            value: function detach() {}\n        },\n        __nestScope: {\n            value: function __nestScope(scope) {\n                if (scope instanceof GlobalScope) {\n                    assert(this.__currentScope === null);\n                    this.globalScope = scope;\n                }\n                this.__currentScope = scope;\n                return scope;\n            }\n        },\n        __nestGlobalScope: {\n            value: function __nestGlobalScope(node) {\n                return this.__nestScope(new GlobalScope(this, node));\n            }\n        },\n        __nestBlockScope: {\n            value: function __nestBlockScope(node, isMethodDefinition) {\n                return this.__nestScope(new BlockScope(this, this.__currentScope, node));\n            }\n        },\n        __nestFunctionScope: {\n            value: function __nestFunctionScope(node, isMethodDefinition) {\n                return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));\n            }\n        },\n        __nestForScope: {\n            value: function __nestForScope(node) {\n                return this.__nestScope(new ForScope(this, this.__currentScope, node));\n            }\n        },\n        __nestCatchScope: {\n            value: function __nestCatchScope(node) {\n                return this.__nestScope(new CatchScope(this, this.__currentScope, node));\n            }\n        },\n        __nestWithScope: {\n            value: function __nestWithScope(node) {\n                return this.__nestScope(new WithScope(this, this.__currentScope, node));\n            }\n        },\n        __nestClassScope: {\n            value: function __nestClassScope(node) {\n                return this.__nestScope(new ClassScope(this, this.__currentScope, node));\n            }\n        },\n        __nestSwitchScope: {\n            value: function __nestSwitchScope(node) {\n                return this.__nestScope(new SwitchScope(this, this.__currentScope, node));\n            }\n        },\n        __nestModuleScope: {\n            value: function __nestModuleScope(node) {\n                return this.__nestScope(new ModuleScope(this, this.__currentScope, node));\n            }\n        },\n        __nestTDZScope: {\n            value: function __nestTDZScope(node) {\n                return this.__nestScope(new TDZScope(this, this.__currentScope, node));\n            }\n        },\n        __nestFunctionExpressionNameScope: {\n            value: function __nestFunctionExpressionNameScope(node) {\n                return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));\n            }\n        },\n        __isES6: {\n            value: function __isES6() {\n                return this.__options.ecmaVersion >= 6;\n            }\n        }\n    });\n\n    return ScopeManager;\n})();\n\nmodule.exports = ScopeManager;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjb3BlLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3Qk8sT0FBTywyQkFBTSxjQUFjOztxQkFDaEIsU0FBUzs7SUFBcEIsS0FBSzs7SUFDTCxNQUFNLDJCQUFNLFFBQVE7O0lBR3ZCLFdBQVcsVUFBWCxXQUFXO0lBQ1gsVUFBVSxVQUFWLFVBQVU7SUFDVixTQUFTLFVBQVQsU0FBUztJQUNULFdBQVcsVUFBWCxXQUFXO0lBQ1gsVUFBVSxVQUFWLFVBQVU7SUFDVixXQUFXLFVBQVgsV0FBVztJQUNYLGFBQWEsVUFBYixhQUFhO0lBQ2IsUUFBUSxVQUFSLFFBQVE7SUFDUixRQUFRLFVBQVIsUUFBUTtJQUNSLDJCQUEyQixVQUEzQiwyQkFBMkI7SUFDM0IsVUFBVSxVQUFWLFVBQVU7Ozs7OztJQU1PLFlBQVk7QUFDbEIsYUFETSxZQUFZLENBQ2pCLE9BQU8sRUFBRTs4QkFESixZQUFZOztBQUV6QixZQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNqQixZQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztBQUN4QixZQUFJLENBQUMsYUFBYSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7QUFDbkMsWUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDM0IsWUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7QUFDekIsWUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7S0FDNUM7O2lCQVJnQixZQUFZO0FBVTdCLHNCQUFjO21CQUFBLDBCQUFHO0FBQ2IsdUJBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUM7YUFDbkM7O0FBRUQsc0JBQWM7bUJBQUEsMEJBQUc7QUFDYix1QkFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQzthQUNwQzs7QUFFRCxvQkFBWTttQkFBQSx3QkFBRztBQUNYLHVCQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO2FBQ3BDOztBQUVELHVCQUFlO21CQUFBLDJCQUFHO0FBQ2QsdUJBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7YUFDckM7O0FBRUQsZ0JBQVE7bUJBQUEsb0JBQUc7QUFDUCx1QkFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsS0FBSyxRQUFRLENBQUM7YUFDakQ7O0FBR0QsYUFBSzs7OzttQkFBQSxlQUFDLElBQUksRUFBRTtBQUNSLHVCQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3ZDOztBQVlELDRCQUFvQjs7Ozs7Ozs7Ozs7OzttQkFBQSw4QkFBQyxJQUFJLEVBQUU7QUFDdkIsdUJBQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDbkQ7O0FBU0QsZUFBTzs7Ozs7Ozs7OzttQkFBQSxpQkFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0FBQ2pCLG9CQUFJLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7QUFFekIseUJBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUN0Qix3QkFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFVBQVUsSUFBSSxLQUFLLENBQUMsdUJBQXVCLEVBQUU7QUFDNUQsK0JBQU8sS0FBSyxDQUFDO3FCQUNoQjtBQUNELHdCQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxFQUFFO0FBQ3RCLCtCQUFPLEtBQUssQ0FBQztxQkFDaEI7QUFDRCwyQkFBTyxJQUFJLENBQUM7aUJBQ2Y7O0FBRUQsc0JBQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFCLG9CQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ2hDLDJCQUFPLElBQUksQ0FBQztpQkFDZjs7OztBQUlELG9CQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3JCLDJCQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDcEI7O0FBRUQsb0JBQUksS0FBSyxFQUFFO0FBQ1AseUJBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDckMsNkJBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsNEJBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ2xCLG1DQUFPLEtBQUssQ0FBQzt5QkFDaEI7cUJBQ0o7aUJBQ0osTUFBTTtBQUNILHlCQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUN6Qyw2QkFBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQiw0QkFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDbEIsbUNBQU8sS0FBSyxDQUFDO3lCQUNoQjtxQkFDSjtpQkFDSjs7QUFFRCx1QkFBTyxJQUFJLENBQUM7YUFDZjs7QUFRRCxrQkFBVTs7Ozs7Ozs7O21CQUFBLG9CQUFDLElBQUksRUFBRTtBQUNiLHVCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDM0I7O0FBU0QsZUFBTzs7Ozs7Ozs7OzttQkFBQSxpQkFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0FBQ2pCLG9CQUFJLE1BQU0sRUFBRSxLQUFLLENBQUM7QUFDbEIsc0JBQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFCLG9CQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQ3pCLHlCQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUN4Qix3QkFBSSxDQUFDLEtBQUssRUFBRTtBQUNSLCtCQUFPLElBQUksQ0FBQztxQkFDZjtBQUNELDJCQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDM0M7QUFDRCx1QkFBTyxJQUFJLENBQUM7YUFDZjs7QUFFRCxjQUFNO21CQUFBLGtCQUFHLEVBQUc7O0FBRVosY0FBTTttQkFBQSxrQkFBRyxFQUFHOztBQUVaLG1CQUFXO21CQUFBLHFCQUFDLEtBQUssRUFBRTtBQUNmLG9CQUFJLEtBQUssWUFBWSxXQUFXLEVBQUU7QUFDOUIsMEJBQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQ3JDLHdCQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztpQkFDNUI7QUFDRCxvQkFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7QUFDNUIsdUJBQU8sS0FBSyxDQUFDO2FBQ2hCOztBQUVELHlCQUFpQjttQkFBQSwyQkFBQyxJQUFJLEVBQUU7QUFDcEIsdUJBQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN4RDs7QUFFRCx3QkFBZ0I7bUJBQUEsMEJBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFO0FBQ3ZDLHVCQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUM1RTs7QUFFRCwyQkFBbUI7bUJBQUEsNkJBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFO0FBQzFDLHVCQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixDQUFDLENBQUMsQ0FBQzthQUNuRzs7QUFFRCxzQkFBYzttQkFBQSx3QkFBQyxJQUFJLEVBQUU7QUFDakIsdUJBQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzFFOztBQUVELHdCQUFnQjttQkFBQSwwQkFBQyxJQUFJLEVBQUU7QUFDbkIsdUJBQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzVFOztBQUVELHVCQUFlO21CQUFBLHlCQUFDLElBQUksRUFBRTtBQUNsQix1QkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDM0U7O0FBRUQsd0JBQWdCO21CQUFBLDBCQUFDLElBQUksRUFBRTtBQUNuQix1QkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDNUU7O0FBRUQseUJBQWlCO21CQUFBLDJCQUFDLElBQUksRUFBRTtBQUNwQix1QkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDN0U7O0FBRUQseUJBQWlCO21CQUFBLDJCQUFDLElBQUksRUFBRTtBQUNwQix1QkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDN0U7O0FBRUQsc0JBQWM7bUJBQUEsd0JBQUMsSUFBSSxFQUFFO0FBQ2pCLHVCQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUMxRTs7QUFFRCx5Q0FBaUM7bUJBQUEsMkNBQUMsSUFBSSxFQUFFO0FBQ3BDLHVCQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzdGOztBQUVELGVBQU87bUJBQUEsbUJBQUc7QUFDTix1QkFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7YUFDMUM7Ozs7V0E1TGdCLFlBQVk7OztpQkFBWixZQUFZIiwiZmlsZSI6InNjb3BlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCBXZWFrTWFwIGZyb20gJ2VzNi13ZWFrLW1hcCc7XG5pbXBvcnQgU2NvcGUgZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7XG4gICAgR2xvYmFsU2NvcGUsXG4gICAgQ2F0Y2hTY29wZSxcbiAgICBXaXRoU2NvcGUsXG4gICAgTW9kdWxlU2NvcGUsXG4gICAgQ2xhc3NTY29wZSxcbiAgICBTd2l0Y2hTY29wZSxcbiAgICBGdW5jdGlvblNjb3BlLFxuICAgIEZvclNjb3BlLFxuICAgIFREWlNjb3BlLFxuICAgIEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZSxcbiAgICBCbG9ja1Njb3BlXG59IGZyb20gJy4vc2NvcGUnO1xuXG4vKipcbiAqIEBjbGFzcyBTY29wZU1hbmFnZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NvcGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgIHRoaXMuZ2xvYmFsU2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9fbm9kZVRvU2NvcGUgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9fY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9fZGVjbGFyZWRWYXJpYWJsZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cblxuICAgIF9fdXNlRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIF9faXNPcHRpbWlzdGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMub3B0aW1pc3RpYztcbiAgICB9XG5cbiAgICBfX2lnbm9yZUV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5pZ25vcmVFdmFsO1xuICAgIH1cblxuICAgIF9faXNOb2RlanNTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zLm5vZGVqc1Njb3BlO1xuICAgIH1cblxuICAgIGlzTW9kdWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZSc7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhcHByb3ByaWF0ZSBzY29wZSBmb3IgdGhpcyBub2RlLlxuICAgIF9fZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19ub2RlVG9TY29wZS5nZXQobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhcmlhYmxlcyB0aGF0IGFyZSBkZWNsYXJlZCBieSB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqIFwiYXJlIGRlY2xhcmVkIGJ5IHRoZSBub2RlXCIgbWVhbnMgdGhlIG5vZGUgaXMgc2FtZSBhcyBgVmFyaWFibGUuZGVmc1tdLm5vZGVgIG9yIGBWYXJpYWJsZS5kZWZzW10ucGFyZW50YC5cbiAgICAgKiBJZiB0aGUgbm9kZSBkZWNsYXJlcyBub3RoaW5nLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICAgICAqIENBVVRJT046IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29wZS9wdWxsLzY5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VzcHJpbWEuTm9kZX0gbm9kZSAtIGEgbm9kZSB0byBnZXQuXG4gICAgICogQHJldHVybnMge1ZhcmlhYmxlW119IHZhcmlhYmxlcyB0aGF0IGRlY2xhcmVkIGJ5IHRoZSBub2RlLlxuICAgICAqL1xuICAgIGdldERlY2xhcmVkVmFyaWFibGVzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcy5nZXQobm9kZSkgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZSBzY29wZSBmcm9tIG5vZGUuXG4gICAgICogQG1ldGhvZCBTY29wZU1hbmFnZXIjYWNxdWlyZVxuICAgICAqIEBwYXJhbSB7RXNwcmltYS5Ob2RlfSBub2RlIC0gbm9kZSBmb3IgdGhlIGFjcXVpcmVkIHNjb3BlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlubmVyIC0gbG9vayB1cCB0aGUgbW9zdCBpbm5lciBzY29wZSwgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHtTY29wZT99XG4gICAgICovXG4gICAgYWNxdWlyZShub2RlLCBpbm5lcikge1xuICAgICAgICB2YXIgc2NvcGVzLCBzY29wZSwgaSwgaXo7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJlZGljYXRlKHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzY29wZS5mdW5jdGlvbkV4cHJlc3Npb25TY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZS50eXBlID09PSAnVERaJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGVzID0gdGhpcy5fX2dldChub2RlKTtcbiAgICAgICAgaWYgKCFzY29wZXMgfHwgc2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZXVyaXN0aWMgc2VsZWN0aW9uIGZyb20gYWxsIHNjb3Blcy5cbiAgICAgICAgLy8gSWYgeW91IHdvdWxkIGxpa2UgdG8gZ2V0IGFsbCBzY29wZXMsIHBsZWFzZSB1c2UgU2NvcGVNYW5hZ2VyI2FjcXVpcmVBbGwuXG4gICAgICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBzY29wZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzY29wZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlIGFsbCBzY29wZXMgZnJvbSBub2RlLlxuICAgICAqIEBtZXRob2QgU2NvcGVNYW5hZ2VyI2FjcXVpcmVBbGxcbiAgICAgKiBAcGFyYW0ge0VzcHJpbWEuTm9kZX0gbm9kZSAtIG5vZGUgZm9yIHRoZSBhY3F1aXJlZCBzY29wZS5cbiAgICAgKiBAcmV0dXJuIHtTY29wZVtdP31cbiAgICAgKi9cbiAgICBhY3F1aXJlQWxsKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19nZXQobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVsZWFzZSB0aGUgbm9kZS5cbiAgICAgKiBAbWV0aG9kIFNjb3BlTWFuYWdlciNyZWxlYXNlXG4gICAgICogQHBhcmFtIHtFc3ByaW1hLk5vZGV9IG5vZGUgLSByZWxlYXNpbmcgbm9kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbm5lciAtIGxvb2sgdXAgdGhlIG1vc3QgaW5uZXIgc2NvcGUsIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG4gICAgICogQHJldHVybiB7U2NvcGU/fSB1cHBlciBzY29wZSBmb3IgdGhlIG5vZGUuXG4gICAgICovXG4gICAgcmVsZWFzZShub2RlLCBpbm5lcikge1xuICAgICAgICB2YXIgc2NvcGVzLCBzY29wZTtcbiAgICAgICAgc2NvcGVzID0gdGhpcy5fX2dldChub2RlKTtcbiAgICAgICAgaWYgKHNjb3BlcyAmJiBzY29wZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzY29wZSA9IHNjb3Blc1swXS51cHBlcjtcbiAgICAgICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmUoc2NvcGUuYmxvY2ssIGlubmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhdHRhY2goKSB7IH1cblxuICAgIGRldGFjaCgpIHsgfVxuXG4gICAgX19uZXN0U2NvcGUoc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLl9fY3VycmVudFNjb3BlID09PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsU2NvcGUgPSBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3VycmVudFNjb3BlID0gc2NvcGU7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBfX25lc3RHbG9iYWxTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBHbG9iYWxTY29wZSh0aGlzLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0QmxvY2tTY29wZShub2RlLCBpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IEJsb2NrU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdEZ1bmN0aW9uU2NvcGUobm9kZSwgaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBGdW5jdGlvblNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUsIGlzTWV0aG9kRGVmaW5pdGlvbikpO1xuICAgIH1cblxuICAgIF9fbmVzdEZvclNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IEZvclNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RDYXRjaFNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IENhdGNoU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdFdpdGhTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBXaXRoU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdENsYXNzU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgQ2xhc3NTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0U3dpdGNoU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgU3dpdGNoU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdE1vZHVsZVNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IE1vZHVsZVNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RURFpTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBURFpTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0RnVuY3Rpb25FeHByZXNzaW9uTmFtZVNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19pc0VTNigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgfVxufVxuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/scope-manager.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/scope-manager.js?");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(61)() ? WeakMap : __webpack_require__(62);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-weak-map/index.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-weak-map/index.js?");

/***/ },
/* 61 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\tvar weakMap, x;\n\tif (typeof WeakMap !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tweakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(weakMap) !== '[object WeakMap]') return false;\n\tif (typeof weakMap.set !== 'function') return false;\n\tif (weakMap.set({}, 1) !== weakMap) return false;\n\tif (typeof weakMap.delete !== 'function') return false;\n\tif (typeof weakMap.has !== 'function') return false;\n\tif (weakMap.get(x) !== 'one') return false;\n\n\treturn true;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-weak-map/is-implemented.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-weak-map/is-implemented.js?");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar setPrototypeOf    = __webpack_require__(63)\n  , object            = __webpack_require__(69)\n  , value             = __webpack_require__(67)\n  , randomUniq        = __webpack_require__(70)\n  , d                 = __webpack_require__(71)\n  , getIterator       = __webpack_require__(83)\n  , forOf             = __webpack_require__(103)\n  , toStringTagSymbol = __webpack_require__(95).toStringTag\n  , isNative          = __webpack_require__(104)\n\n  , isArray = Array.isArray, defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf\n  , WeakMapPoly;\n\nmodule.exports = WeakMapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], self;\n\tif (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {\n\t\tself = setPrototypeOf(new WeakMap(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) {\n\t\tif (!isArray(iterable)) iterable = getIterator(iterable);\n\t}\n\tdefineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));\n\tif (!iterable) return self;\n\tforOf(iterable, function (val) {\n\t\tvalue(val);\n\t\tself.set(val[0], val[1]);\n\t});\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);\n\tWeakMapPoly.prototype = Object.create(WeakMap.prototype, {\n\t\tconstructor: d(WeakMapPoly)\n\t});\n}\n\nObject.defineProperties(WeakMapPoly.prototype, {\n\tdelete: d(function (key) {\n\t\tif (hasOwnProperty.call(object(key), this.__weakMapData__)) {\n\t\t\tdelete key[this.__weakMapData__];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}),\n\tget: d(function (key) {\n\t\tif (hasOwnProperty.call(object(key), this.__weakMapData__)) {\n\t\t\treturn key[this.__weakMapData__];\n\t\t}\n\t}),\n\thas: d(function (key) {\n\t\treturn hasOwnProperty.call(object(key), this.__weakMapData__);\n\t}),\n\tset: d(function (key, value) {\n\t\tdefineProperty(object(key), this.__weakMapData__, d('c', value));\n\t\treturn this;\n\t}),\n\ttoString: d(function () { return '[object WeakMap]'; })\n});\ndefineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-weak-map/polyfill.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-weak-map/polyfill.js?");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(64)()\n\t? Object.setPrototypeOf\n\t: __webpack_require__(65);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/set-prototype-of/index.js\n ** module id = 63\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/set-prototype-of/index.js?");

/***/ },
/* 64 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf\n  , x = {};\n\nmodule.exports = function (/*customCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf\n\t  , customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== 'function') return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/set-prototype-of/is-implemented.js\n ** module id = 64\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/set-prototype-of/is-implemented.js?");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n'use strict';\n\nvar isObject      = __webpack_require__(66)\n  , value         = __webpack_require__(67)\n\n  , isPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty = Object.defineProperty\n  , nullDesc = { configurable: true, enumerable: false, writable: true,\n\t\tvalue: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif ((prototype === null) || isObject(prototype)) return obj;\n\tthrow new TypeError('Prototype must be null or an object');\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = isPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, 'level', { configurable: false,\n\t\tenumerable: false, writable: false, value: status.level });\n}((function () {\n\tvar x = Object.create(null), y = {}, set\n\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');\n\n\tif (desc) {\n\t\ttry {\n\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\tset.call(x, y);\n\t\t} catch (ignore) { }\n\t\tif (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };\n\t}\n\n\tx.__proto__ = y;\n\tif (Object.getPrototypeOf(x) === y) return { level: 2 };\n\n\tx = {};\n\tx.__proto__ = y;\n\tif (Object.getPrototypeOf(x) === y) return { level: 1 };\n\n\treturn false;\n}())));\n\n__webpack_require__(68);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/set-prototype-of/shim.js\n ** module id = 65\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/set-prototype-of/shim.js?");

/***/ },
/* 66 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (x) {\n\treturn ((x != null) && map[typeof x]) || false;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/is-object.js\n ** module id = 66\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/is-object.js?");

/***/ },
/* 67 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/valid-value.js\n ** module id = 67\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/valid-value.js?");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n'use strict';\n\nvar create = Object.create, shim;\n\nif (!__webpack_require__(64)()) {\n\tshim = __webpack_require__(65);\n}\n\nmodule.exports = (function () {\n\tvar nullObject, props, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tprops = {};\n\tdesc = { configurable: false, enumerable: false, writable: true,\n\t\tvalue: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === '__proto__') {\n\t\t\tprops[name] = { configurable: true, enumerable: false, writable: true,\n\t\t\t\tvalue: undefined };\n\t\t\treturn;\n\t\t}\n\t\tprops[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, props);\n\n\tObject.defineProperty(shim, 'nullPolyfill', { configurable: false,\n\t\tenumerable: false, writable: false, value: nullObject });\n\n\treturn function (prototype, props) {\n\t\treturn create((prototype === null) ? nullObject : prototype, props);\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/create.js\n ** module id = 68\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/create.js?");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isObject = __webpack_require__(66);\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) throw new TypeError(value + \" is not an Object\");\n\treturn value;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/valid-object.js\n ** module id = 69\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/valid-object.js?");

/***/ },
/* 70 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar generated = Object.create(null)\n\n  , random = Math.random;\n\nmodule.exports = function () {\n\tvar str;\n\tdo { str = random().toString(36).slice(2); } while (generated[str]);\n\treturn str;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/string/random-uniq.js\n ** module id = 70\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/string/random-uniq.js?");

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar assign        = __webpack_require__(72)\n  , normalizeOpts = __webpack_require__(78)\n  , isCallable    = __webpack_require__(79)\n  , contains      = __webpack_require__(80)\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d/index.js\n ** module id = 71\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/d/index.js?");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(73)()\n\t? Object.assign\n\t: __webpack_require__(74);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/assign/index.js\n ** module id = 72\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/assign/index.js?");

/***/ },
/* 73 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/assign/is-implemented.js\n ** module id = 73\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/assign/is-implemented.js?");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar keys  = __webpack_require__(75)\n  , value = __webpack_require__(67)\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, …srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/assign/shim.js\n ** module id = 74\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/assign/shim.js?");

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(76)()\n\t? Object.keys\n\t: __webpack_require__(77);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/keys/index.js\n ** module id = 75\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/keys/index.js?");

/***/ },
/* 76 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/keys/is-implemented.js\n ** module id = 76\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/keys/is-implemented.js?");

/***/ },
/* 77 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/keys/shim.js\n ** module id = 77\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/keys/shim.js?");

/***/ },
/* 78 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/normalize-options.js\n ** module id = 78\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/normalize-options.js?");

/***/ },
/* 79 */
/***/ function(module, exports) {

	eval("// Deprecated\n\n'use strict';\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/is-callable.js\n ** module id = 79\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/is-callable.js?");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(81)()\n\t? String.prototype.contains\n\t: __webpack_require__(82);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/string/#/contains/index.js\n ** module id = 80\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/string/#/contains/index.js?");

/***/ },
/* 81 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/string/#/contains/is-implemented.js\n ** module id = 81\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/string/#/contains/is-implemented.js?");

/***/ },
/* 82 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/string/#/contains/shim.js\n ** module id = 82\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/string/#/contains/shim.js?");

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isArguments    = __webpack_require__(84)\n  , isString       = __webpack_require__(85)\n  , ArrayIterator  = __webpack_require__(86)\n  , StringIterator = __webpack_require__(100)\n  , iterable       = __webpack_require__(101)\n  , iteratorSymbol = __webpack_require__(95).iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/get.js\n ** module id = 83\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/get.js?");

/***/ },
/* 84 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar toString = Object.prototype.toString\n\n  , id = toString.call((function () { return arguments; }()));\n\nmodule.exports = function (x) { return (toString.call(x) === id); };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/function/is-arguments.js\n ** module id = 84\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/function/is-arguments.js?");

/***/ },
/* 85 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar toString = Object.prototype.toString\n\n  , id = toString.call('');\n\nmodule.exports = function (x) {\n\treturn (typeof x === 'string') || (x && (typeof x === 'object') &&\n\t\t((x instanceof String) || (toString.call(x) === id))) || false;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/string/is-string.js\n ** module id = 85\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/string/is-string.js?");

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar setPrototypeOf = __webpack_require__(63)\n  , contains       = __webpack_require__(80)\n  , d              = __webpack_require__(71)\n  , Iterator       = __webpack_require__(87)\n\n  , defineProperty = Object.defineProperty\n  , ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);\n\tIterator.call(this, arr);\n\tif (!kind) kind = 'value';\n\telse if (contains.call(kind, 'key+value')) kind = 'key+value';\n\telse if (contains.call(kind, 'key')) kind = 'key';\n\telse kind = 'value';\n\tdefineProperty(this, '__kind__', d('', kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(ArrayIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__list__[i];\n\t\tif (this.__kind__ === 'key+value') return [i, this.__list__[i]];\n\t\treturn i;\n\t}),\n\ttoString: d(function () { return '[object Array Iterator]'; })\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/array.js\n ** module id = 86\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/array.js?");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar clear    = __webpack_require__(88)\n  , assign   = __webpack_require__(72)\n  , callable = __webpack_require__(89)\n  , value    = __webpack_require__(67)\n  , d        = __webpack_require__(71)\n  , autoBind = __webpack_require__(90)\n  , Symbol   = __webpack_require__(95)\n\n  , defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) return new Iterator(list, context);\n\tdefineProperties(this, {\n\t\t__list__: d('w', value(list)),\n\t\t__context__: d('w', context),\n\t\t__nextIndex__: d('w', 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on('_add', this._onAdd);\n\tcontext.on('_delete', this._onDelete);\n\tcontext.on('_clear', this._onClear);\n};\n\ndefineProperties(Iterator.prototype, assign({\n\tconstructor: d(Iterator),\n\t_next: d(function () {\n\t\tvar i;\n\t\tif (!this.__list__) return;\n\t\tif (this.__redo__) {\n\t\t\ti = this.__redo__.shift();\n\t\t\tif (i !== undefined) return i;\n\t\t}\n\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\tnext: d(function () { return this._createResult(this._next()); }),\n\t_createResult: d(function (i) {\n\t\tif (i === undefined) return { done: true, value: undefined };\n\t\treturn { done: false, value: this._resolve(i) };\n\t}),\n\t_resolve: d(function (i) { return this.__list__[i]; }),\n\t_unBind: d(function () {\n\t\tthis.__list__ = null;\n\t\tdelete this.__redo__;\n\t\tif (!this.__context__) return;\n\t\tthis.__context__.off('_add', this._onAdd);\n\t\tthis.__context__.off('_delete', this._onDelete);\n\t\tthis.__context__.off('_clear', this._onClear);\n\t\tthis.__context__ = null;\n\t}),\n\ttoString: d(function () { return '[object Iterator]'; })\n}, autoBind({\n\t_onAdd: d(function (index) {\n\t\tif (index >= this.__nextIndex__) return;\n\t\t++this.__nextIndex__;\n\t\tif (!this.__redo__) {\n\t\t\tdefineProperty(this, '__redo__', d('c', [index]));\n\t\t\treturn;\n\t\t}\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t}, this);\n\t\tthis.__redo__.push(index);\n\t}),\n\t_onDelete: d(function (index) {\n\t\tvar i;\n\t\tif (index >= this.__nextIndex__) return;\n\t\t--this.__nextIndex__;\n\t\tif (!this.__redo__) return;\n\t\ti = this.__redo__.indexOf(index);\n\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo > index) this.__redo__[i] = --redo;\n\t\t}, this);\n\t}),\n\t_onClear: d(function () {\n\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\tthis.__nextIndex__ = 0;\n\t})\n})));\n\ndefineProperty(Iterator.prototype, Symbol.iterator, d(function () {\n\treturn this;\n}));\ndefineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/index.js\n ** module id = 87\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/index.js?");

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n'use strict';\n\nvar value = __webpack_require__(67);\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/array/#/clear.js\n ** module id = 88\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/array/#/clear.js?");

/***/ },
/* 89 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/valid-callable.js\n ** module id = 89\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/valid-callable.js?");

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar copy       = __webpack_require__(91)\n  , map        = __webpack_require__(92)\n  , callable   = __webpack_require__(89)\n  , validValue = __webpack_require__(67)\n\n  , bind = Function.prototype.bind, defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, bindTo) {\n\tvar value = validValue(desc) && callable(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, bindTo*/) {\n\tvar bindTo = arguments[1];\n\treturn map(props, function (desc, name) {\n\t\treturn define(name, desc, bindTo);\n\t});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d/auto-bind.js\n ** module id = 90\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/d/auto-bind.js?");

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar assign = __webpack_require__(72)\n  , value  = __webpack_require__(67);\n\nmodule.exports = function (obj) {\n\tvar copy = Object(value(obj));\n\tif (copy !== obj) return copy;\n\treturn assign({}, obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/copy.js\n ** module id = 91\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/copy.js?");

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar callable = __webpack_require__(89)\n  , forEach  = __webpack_require__(93)\n\n  , call = Function.prototype.call;\n\nmodule.exports = function (obj, cb/*, thisArg*/) {\n\tvar o = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, obj, index) {\n\t\to[key] = call.call(cb, thisArg, value, key, obj, index);\n\t});\n\treturn o;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/map.js\n ** module id = 92\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/map.js?");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(94)('forEach');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/for-each.js\n ** module id = 93\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/for-each.js?");

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n'use strict';\n\nvar callable = __webpack_require__(89)\n  , value    = __webpack_require__(67)\n\n  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys\n  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb/*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== 'function') method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!propertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/_iterate.js\n ** module id = 94\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/_iterate.js?");

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(96)() ? Symbol : __webpack_require__(97);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-symbol/index.js\n ** module id = 95\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-symbol/index.js?");

/***/ },
/* 96 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\tif (typeof Symbol.iterator === 'symbol') return true;\n\n\t// Return 'true' for polyfills\n\tif (typeof Symbol.isConcatSpreadable !== 'object') return false;\n\tif (typeof Symbol.iterator !== 'object') return false;\n\tif (typeof Symbol.toPrimitive !== 'object') return false;\n\tif (typeof Symbol.toStringTag !== 'object') return false;\n\tif (typeof Symbol.unscopables !== 'object') return false;\n\n\treturn true;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-symbol/is-implemented.js\n ** module id = 96\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-symbol/is-implemented.js?");

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	eval("// ES2015 Symbol polyfill for environments that do not support it (or partially support it_\n\n'use strict';\n\nvar d              = __webpack_require__(71)\n  , validateSymbol = __webpack_require__(98)\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);\n\nif (typeof Symbol === 'function') NativeSymbol = Symbol;\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name, ie11BugWorkaround;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(SymbolPolyfill, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = SymbolPolyfill(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\n\t// If there's native implementation of given symbol, let's fallback to it\n\t// to ensure proper interoperability with other native functions e.g. Array.from\n\thasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),\n\tisConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\tSymbolPolyfill('isConcatSpreadable')),\n\titerator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),\n\tmatch: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),\n\treplace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),\n\tsearch: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),\n\tspecies: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),\n\tsplit: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),\n\ttoPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),\n\ttoStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),\n\tunscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))\n});\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d('', function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('',\n\tfunction () { return validateSymbol(this); }));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-symbol/polyfill.js\n ** module id = 97\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-symbol/polyfill.js?");

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isSymbol = __webpack_require__(99);\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-symbol/validate-symbol.js\n ** module id = 98\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-symbol/validate-symbol.js?");

/***/ },
/* 99 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function (x) {\n\treturn (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-symbol/is-symbol.js\n ** module id = 99\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-symbol/is-symbol.js?");

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n'use strict';\n\nvar setPrototypeOf = __webpack_require__(63)\n  , d              = __webpack_require__(71)\n  , Iterator       = __webpack_require__(87)\n\n  , defineProperty = Object.defineProperty\n  , StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) return new StringIterator(str);\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, '__length__', d('', str.length));\n\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(StringIterator),\n\t_next: d(function () {\n\t\tif (!this.__list__) return;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t}),\n\ttoString: d(function () { return '[object String Iterator]'; })\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/string.js\n ** module id = 100\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/string.js?");

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isIterable = __webpack_require__(102);\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/valid-iterable.js\n ** module id = 101\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/valid-iterable.js?");

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isArguments    = __webpack_require__(84)\n  , isString       = __webpack_require__(85)\n  , iteratorSymbol = __webpack_require__(95).iterator\n\n  , isArray = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (value == null) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn (typeof value[iteratorSymbol] === 'function');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/is-iterable.js\n ** module id = 102\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/is-iterable.js?");

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isArguments = __webpack_require__(84)\n  , callable    = __webpack_require__(89)\n  , isString    = __webpack_require__(85)\n  , get         = __webpack_require__(83)\n\n  , isArray = Array.isArray, call = Function.prototype.call\n  , some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb/*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = 'array';\n\telse if (isString(iterable)) mode = 'string';\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () { broken = true; };\n\tif (mode === 'array') {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\tif (broken) return true;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === 'string') {\n\t\tl = iterable.length;\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif ((i + 1) < l) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-iterator/for-of.js\n ** module id = 103\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-iterator/for-of.js?");

/***/ },
/* 104 */
/***/ function(module, exports) {

	eval("// Exports true if environment provides native `WeakMap` implementation, whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof WeakMap !== 'function') return false;\n\treturn (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-weak-map/is-native-implemented.js\n ** module id = 104\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-weak-map/is-native-implemented.js?");

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar Syntax = __webpack_require__(106).Syntax;\n\nvar Map = _interopRequire(__webpack_require__(108));\n\nvar Reference = _interopRequire(__webpack_require__(122));\n\nvar Variable = _interopRequire(__webpack_require__(123));\n\nvar Definition = _interopRequire(__webpack_require__(124));\n\nvar assert = _interopRequire(__webpack_require__(55));\n\nfunction isStrictScope(scope, block, isMethodDefinition, useDirective) {\n    var body, i, iz, stmt, expr;\n\n    // When upper scope is exists and strict, inner scope is also strict.\n    if (scope.upper && scope.upper.isStrict) {\n        return true;\n    }\n\n    // ArrowFunctionExpression's scope is always strict scope.\n    if (block.type === Syntax.ArrowFunctionExpression) {\n        return true;\n    }\n\n    if (isMethodDefinition) {\n        return true;\n    }\n\n    if (scope.type === \"class\" || scope.type === \"module\") {\n        return true;\n    }\n\n    if (scope.type === \"block\" || scope.type === \"switch\") {\n        return false;\n    }\n\n    if (scope.type === \"function\") {\n        if (block.type === Syntax.Program) {\n            body = block;\n        } else {\n            body = block.body;\n        }\n    } else if (scope.type === \"global\") {\n        body = block;\n    } else {\n        return false;\n    }\n\n    // Search 'use strict' directive.\n    if (useDirective) {\n        for (i = 0, iz = body.body.length; i < iz; ++i) {\n            stmt = body.body[i];\n            if (stmt.type !== Syntax.DirectiveStatement) {\n                break;\n            }\n            if (stmt.raw === \"\\\"use strict\\\"\" || stmt.raw === \"'use strict'\") {\n                return true;\n            }\n        }\n    } else {\n        for (i = 0, iz = body.body.length; i < iz; ++i) {\n            stmt = body.body[i];\n            if (stmt.type !== Syntax.ExpressionStatement) {\n                break;\n            }\n            expr = stmt.expression;\n            if (expr.type !== Syntax.Literal || typeof expr.value !== \"string\") {\n                break;\n            }\n            if (expr.raw != null) {\n                if (expr.raw === \"\\\"use strict\\\"\" || expr.raw === \"'use strict'\") {\n                    return true;\n                }\n            } else {\n                if (expr.value === \"use strict\") {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nfunction registerScope(scopeManager, scope) {\n    var scopes;\n\n    scopeManager.scopes.push(scope);\n\n    scopes = scopeManager.__nodeToScope.get(scope.block);\n    if (scopes) {\n        scopes.push(scope);\n    } else {\n        scopeManager.__nodeToScope.set(scope.block, [scope]);\n    }\n}\n\nfunction shouldBeStatically(def) {\n    return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== \"var\";\n}\n\n/**\n * @class Scope\n */\n\nvar Scope = (function () {\n    function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {\n        _classCallCheck(this, Scope);\n\n        /**\n         * One of 'TDZ', 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.\n         * @member {String} Scope#type\n         */\n        this.type = type;\n        /**\n        * The scoped {@link Variable}s of this scope, as <code>{ Variable.name\n        * : Variable }</code>.\n        * @member {Map} Scope#set\n        */\n        this.set = new Map();\n        /**\n         * The tainted variables of this scope, as <code>{ Variable.name :\n         * boolean }</code>.\n         * @member {Map} Scope#taints */\n        this.taints = new Map();\n        /**\n         * Generally, through the lexical scoping of JS you can always know\n         * which variable an identifier in the source code refers to. There are\n         * a few exceptions to this rule. With 'global' and 'with' scopes you\n         * can only decide at runtime which variable a reference refers to.\n         * Moreover, if 'eval()' is used in a scope, it might introduce new\n         * bindings in this or its parent scopes.\n         * All those scopes are considered 'dynamic'.\n         * @member {boolean} Scope#dynamic\n         */\n        this.dynamic = this.type === \"global\" || this.type === \"with\";\n        /**\n         * A reference to the scope-defining syntax node.\n         * @member {esprima.Node} Scope#block\n         */\n        this.block = block;\n        /**\n        * The {@link Reference|references} that are not resolved with this scope.\n        * @member {Reference[]} Scope#through\n        */\n        this.through = [];\n        /**\n        * The scoped {@link Variable}s of this scope. In the case of a\n        * 'function' scope this includes the automatic argument <em>arguments</em> as\n        * its first element, as well as all further formal arguments.\n        * @member {Variable[]} Scope#variables\n        */\n        this.variables = [];\n        /**\n        * Any variable {@link Reference|reference} found in this scope. This\n        * includes occurrences of local variables as well as variables from\n        * parent scopes (including the global scope). For local variables\n        * this also includes defining occurrences (like in a 'var' statement).\n        * In a 'function' scope this does not include the occurrences of the\n        * formal parameter in the parameter list.\n        * @member {Reference[]} Scope#references\n        */\n        this.references = [];\n\n        /**\n        * For 'global' and 'function' scopes, this is a self-reference. For\n        * other scope types this is the <em>variableScope</em> value of the\n        * parent scope.\n        * @member {Scope} Scope#variableScope\n        */\n        this.variableScope = this.type === \"global\" || this.type === \"function\" || this.type === \"module\" ? this : upperScope.variableScope;\n        /**\n        * Whether this scope is created by a FunctionExpression.\n        * @member {boolean} Scope#functionExpressionScope\n        */\n        this.functionExpressionScope = false;\n        /**\n        * Whether this is a scope that contains an 'eval()' invocation.\n        * @member {boolean} Scope#directCallToEvalScope\n        */\n        this.directCallToEvalScope = false;\n        /**\n        * @member {boolean} Scope#thisFound\n        */\n        this.thisFound = false;\n\n        this.__left = [];\n\n        /**\n        * Reference to the parent {@link Scope|scope}.\n        * @member {Scope} Scope#upper\n        */\n        this.upper = upperScope;\n        /**\n        * Whether 'use strict' is in effect in this scope.\n        * @member {boolean} Scope#isStrict\n        */\n        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());\n\n        /**\n        * List of nested {@link Scope}s.\n        * @member {Scope[]} Scope#childScopes\n        */\n        this.childScopes = [];\n        if (this.upper) {\n            this.upper.childScopes.push(this);\n        }\n\n        this.__declaredVariables = scopeManager.__declaredVariables;\n\n        registerScope(scopeManager, this);\n    }\n\n    _createClass(Scope, {\n        __shouldStaticallyClose: {\n            value: function __shouldStaticallyClose(scopeManager) {\n                return !this.dynamic || scopeManager.__isOptimistic();\n            }\n        },\n        __shouldStaticallyCloseForGlobal: {\n            value: function __shouldStaticallyCloseForGlobal(ref) {\n                // On global scope, let/const/class declarations should be resolved statically.\n                var name = ref.identifier.name;\n                if (!this.set.has(name)) {\n                    return false;\n                }\n\n                var variable = this.set.get(name);\n                var defs = variable.defs;\n                return defs.length > 0 && defs.every(shouldBeStatically);\n            }\n        },\n        __staticCloseRef: {\n            value: function __staticCloseRef(ref) {\n                if (!this.__resolve(ref)) {\n                    this.__delegateToUpperScope(ref);\n                }\n            }\n        },\n        __dynamicCloseRef: {\n            value: function __dynamicCloseRef(ref) {\n                // notify all names are through to global\n                var current = this;\n                do {\n                    current.through.push(ref);\n                    current = current.upper;\n                } while (current);\n            }\n        },\n        __globalCloseRef: {\n            value: function __globalCloseRef(ref) {\n                // let/const/class declarations should be resolved statically.\n                // others should be resolved dynamically.\n                if (this.__shouldStaticallyCloseForGlobal(ref)) {\n                    this.__staticCloseRef(ref);\n                } else {\n                    this.__dynamicCloseRef(ref);\n                }\n            }\n        },\n        __close: {\n            value: function __close(scopeManager) {\n                var closeRef;\n                if (this.__shouldStaticallyClose(scopeManager)) {\n                    closeRef = this.__staticCloseRef;\n                } else if (this.type !== \"global\") {\n                    closeRef = this.__dynamicCloseRef;\n                } else {\n                    closeRef = this.__globalCloseRef;\n                }\n\n                // Try Resolving all references in this scope.\n                for (var i = 0, iz = this.__left.length; i < iz; ++i) {\n                    var ref = this.__left[i];\n                    closeRef.call(this, ref);\n                }\n                this.__left = null;\n\n                return this.upper;\n            }\n        },\n        __resolve: {\n            value: function __resolve(ref) {\n                var variable, name;\n                name = ref.identifier.name;\n                if (this.set.has(name)) {\n                    variable = this.set.get(name);\n                    variable.references.push(ref);\n                    variable.stack = variable.stack && ref.from.variableScope === this.variableScope;\n                    if (ref.tainted) {\n                        variable.tainted = true;\n                        this.taints.set(variable.name, true);\n                    }\n                    ref.resolved = variable;\n                    return true;\n                }\n                return false;\n            }\n        },\n        __delegateToUpperScope: {\n            value: function __delegateToUpperScope(ref) {\n                if (this.upper) {\n                    this.upper.__left.push(ref);\n                }\n                this.through.push(ref);\n            }\n        },\n        __addDeclaredVariablesOfNode: {\n            value: function __addDeclaredVariablesOfNode(variable, node) {\n                if (node == null) {\n                    return;\n                }\n\n                var variables = this.__declaredVariables.get(node);\n                if (variables == null) {\n                    variables = [];\n                    this.__declaredVariables.set(node, variables);\n                }\n                if (variables.indexOf(variable) === -1) {\n                    variables.push(variable);\n                }\n            }\n        },\n        __defineGeneric: {\n            value: function __defineGeneric(name, set, variables, node, def) {\n                var variable;\n\n                variable = set.get(name);\n                if (!variable) {\n                    variable = new Variable(name, this);\n                    set.set(name, variable);\n                    variables.push(variable);\n                }\n\n                if (def) {\n                    variable.defs.push(def);\n                    if (def.type !== Variable.TDZ) {\n                        this.__addDeclaredVariablesOfNode(variable, def.node);\n                        this.__addDeclaredVariablesOfNode(variable, def.parent);\n                    }\n                }\n                if (node) {\n                    variable.identifiers.push(node);\n                }\n            }\n        },\n        __define: {\n            value: function __define(node, def) {\n                if (node && node.type === Syntax.Identifier) {\n                    this.__defineGeneric(node.name, this.set, this.variables, node, def);\n                }\n            }\n        },\n        __referencing: {\n            value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {\n                // because Array element may be null\n                if (!node || node.type !== Syntax.Identifier) {\n                    return;\n                }\n\n                // Specially handle like `this`.\n                if (node.name === \"super\") {\n                    return;\n                }\n\n                var ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);\n                this.references.push(ref);\n                this.__left.push(ref);\n            }\n        },\n        __detectEval: {\n            value: function __detectEval() {\n                var current;\n                current = this;\n                this.directCallToEvalScope = true;\n                do {\n                    current.dynamic = true;\n                    current = current.upper;\n                } while (current);\n            }\n        },\n        __detectThis: {\n            value: function __detectThis() {\n                this.thisFound = true;\n            }\n        },\n        __isClosed: {\n            value: function __isClosed() {\n                return this.__left === null;\n            }\n        },\n        resolve: {\n\n            /**\n             * returns resolved {Reference}\n             * @method Scope#resolve\n             * @param {Esprima.Identifier} ident - identifier to be resolved.\n             * @return {Reference}\n             */\n\n            value: function resolve(ident) {\n                var ref, i, iz;\n                assert(this.__isClosed(), \"Scope should be closed.\");\n                assert(ident.type === Syntax.Identifier, \"Target should be identifier.\");\n                for (i = 0, iz = this.references.length; i < iz; ++i) {\n                    ref = this.references[i];\n                    if (ref.identifier === ident) {\n                        return ref;\n                    }\n                }\n                return null;\n            }\n        },\n        isStatic: {\n\n            /**\n             * returns this scope is static\n             * @method Scope#isStatic\n             * @return {boolean}\n             */\n\n            value: function isStatic() {\n                return !this.dynamic;\n            }\n        },\n        isArgumentsMaterialized: {\n\n            /**\n             * returns this scope has materialized arguments\n             * @method Scope#isArgumentsMaterialized\n             * @return {boolean}\n             */\n\n            value: function isArgumentsMaterialized() {\n                return true;\n            }\n        },\n        isThisMaterialized: {\n\n            /**\n             * returns this scope has materialized `this` reference\n             * @method Scope#isThisMaterialized\n             * @return {boolean}\n             */\n\n            value: function isThisMaterialized() {\n                return true;\n            }\n        },\n        isUsedName: {\n            value: function isUsedName(name) {\n                if (this.set.has(name)) {\n                    return true;\n                }\n                for (var i = 0, iz = this.through.length; i < iz; ++i) {\n                    if (this.through[i].identifier.name === name) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    });\n\n    return Scope;\n})();\n\nexports[\"default\"] = Scope;\n\nvar GlobalScope = exports.GlobalScope = (function (_Scope) {\n    function GlobalScope(scopeManager, block) {\n        _classCallCheck(this, GlobalScope);\n\n        _get(Object.getPrototypeOf(GlobalScope.prototype), \"constructor\", this).call(this, scopeManager, \"global\", null, block, false);\n        this.implicit = {\n            set: new Map(),\n            variables: [],\n            /**\n            * List of {@link Reference}s that are left to be resolved (i.e. which\n            * need to be linked to the variable they refer to).\n            * @member {Reference[]} Scope#implicit#left\n            */\n            left: []\n        };\n    }\n\n    _inherits(GlobalScope, _Scope);\n\n    _createClass(GlobalScope, {\n        __close: {\n            value: function __close(scopeManager) {\n                var implicit = [];\n                for (var i = 0, iz = this.__left.length; i < iz; ++i) {\n                    var ref = this.__left[i];\n                    if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {\n                        implicit.push(ref.__maybeImplicitGlobal);\n                    }\n                }\n\n                // create an implicit global variable from assignment expression\n                for (var i = 0, iz = implicit.length; i < iz; ++i) {\n                    var info = implicit[i];\n                    this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));\n                }\n\n                this.implicit.left = this.__left;\n\n                return _get(Object.getPrototypeOf(GlobalScope.prototype), \"__close\", this).call(this, scopeManager);\n            }\n        },\n        __defineImplicit: {\n            value: function __defineImplicit(node, def) {\n                if (node && node.type === Syntax.Identifier) {\n                    this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);\n                }\n            }\n        }\n    });\n\n    return GlobalScope;\n})(Scope);\n\nvar ModuleScope = exports.ModuleScope = (function (_Scope2) {\n    function ModuleScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, ModuleScope);\n\n        _get(Object.getPrototypeOf(ModuleScope.prototype), \"constructor\", this).call(this, scopeManager, \"module\", upperScope, block, false);\n    }\n\n    _inherits(ModuleScope, _Scope2);\n\n    return ModuleScope;\n})(Scope);\n\nvar FunctionExpressionNameScope = exports.FunctionExpressionNameScope = (function (_Scope3) {\n    function FunctionExpressionNameScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, FunctionExpressionNameScope);\n\n        _get(Object.getPrototypeOf(FunctionExpressionNameScope.prototype), \"constructor\", this).call(this, scopeManager, \"function-expression-name\", upperScope, block, false);\n        this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));\n        this.functionExpressionScope = true;\n    }\n\n    _inherits(FunctionExpressionNameScope, _Scope3);\n\n    return FunctionExpressionNameScope;\n})(Scope);\n\nvar CatchScope = exports.CatchScope = (function (_Scope4) {\n    function CatchScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, CatchScope);\n\n        _get(Object.getPrototypeOf(CatchScope.prototype), \"constructor\", this).call(this, scopeManager, \"catch\", upperScope, block, false);\n    }\n\n    _inherits(CatchScope, _Scope4);\n\n    return CatchScope;\n})(Scope);\n\nvar WithScope = exports.WithScope = (function (_Scope5) {\n    function WithScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, WithScope);\n\n        _get(Object.getPrototypeOf(WithScope.prototype), \"constructor\", this).call(this, scopeManager, \"with\", upperScope, block, false);\n    }\n\n    _inherits(WithScope, _Scope5);\n\n    _createClass(WithScope, {\n        __close: {\n            value: function __close(scopeManager) {\n                if (this.__shouldStaticallyClose(scopeManager)) {\n                    return _get(Object.getPrototypeOf(WithScope.prototype), \"__close\", this).call(this, scopeManager);\n                }\n\n                for (var i = 0, iz = this.__left.length; i < iz; ++i) {\n                    var ref = this.__left[i];\n                    ref.tainted = true;\n                    this.__delegateToUpperScope(ref);\n                }\n                this.__left = null;\n\n                return this.upper;\n            }\n        }\n    });\n\n    return WithScope;\n})(Scope);\n\nvar TDZScope = exports.TDZScope = (function (_Scope6) {\n    function TDZScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, TDZScope);\n\n        _get(Object.getPrototypeOf(TDZScope.prototype), \"constructor\", this).call(this, scopeManager, \"TDZ\", upperScope, block, false);\n    }\n\n    _inherits(TDZScope, _Scope6);\n\n    return TDZScope;\n})(Scope);\n\nvar BlockScope = exports.BlockScope = (function (_Scope7) {\n    function BlockScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, BlockScope);\n\n        _get(Object.getPrototypeOf(BlockScope.prototype), \"constructor\", this).call(this, scopeManager, \"block\", upperScope, block, false);\n    }\n\n    _inherits(BlockScope, _Scope7);\n\n    return BlockScope;\n})(Scope);\n\nvar SwitchScope = exports.SwitchScope = (function (_Scope8) {\n    function SwitchScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, SwitchScope);\n\n        _get(Object.getPrototypeOf(SwitchScope.prototype), \"constructor\", this).call(this, scopeManager, \"switch\", upperScope, block, false);\n    }\n\n    _inherits(SwitchScope, _Scope8);\n\n    return SwitchScope;\n})(Scope);\n\nvar FunctionScope = exports.FunctionScope = (function (_Scope9) {\n    function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {\n        _classCallCheck(this, FunctionScope);\n\n        _get(Object.getPrototypeOf(FunctionScope.prototype), \"constructor\", this).call(this, scopeManager, \"function\", upperScope, block, isMethodDefinition);\n\n        // section 9.2.13, FunctionDeclarationInstantiation.\n        // NOTE Arrow functions never have an arguments objects.\n        if (this.block.type !== Syntax.ArrowFunctionExpression) {\n            this.__defineArguments();\n        }\n    }\n\n    _inherits(FunctionScope, _Scope9);\n\n    _createClass(FunctionScope, {\n        isArgumentsMaterialized: {\n            value: function isArgumentsMaterialized() {\n                // TODO(Constellation)\n                // We can more aggressive on this condition like this.\n                //\n                // function t() {\n                //     // arguments of t is always hidden.\n                //     function arguments() {\n                //     }\n                // }\n                if (this.block.type === Syntax.ArrowFunctionExpression) {\n                    return false;\n                }\n\n                if (!this.isStatic()) {\n                    return true;\n                }\n\n                var variable = this.set.get(\"arguments\");\n                assert(variable, \"Always have arguments variable.\");\n                return variable.tainted || variable.references.length !== 0;\n            }\n        },\n        isThisMaterialized: {\n            value: function isThisMaterialized() {\n                if (!this.isStatic()) {\n                    return true;\n                }\n                return this.thisFound;\n            }\n        },\n        __defineArguments: {\n            value: function __defineArguments() {\n                this.__defineGeneric(\"arguments\", this.set, this.variables, null, null);\n                this.taints.set(\"arguments\", true);\n            }\n        }\n    });\n\n    return FunctionScope;\n})(Scope);\n\nvar ForScope = exports.ForScope = (function (_Scope10) {\n    function ForScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, ForScope);\n\n        _get(Object.getPrototypeOf(ForScope.prototype), \"constructor\", this).call(this, scopeManager, \"for\", upperScope, block, false);\n    }\n\n    _inherits(ForScope, _Scope10);\n\n    return ForScope;\n})(Scope);\n\nvar ClassScope = exports.ClassScope = (function (_Scope11) {\n    function ClassScope(scopeManager, upperScope, block) {\n        _classCallCheck(this, ClassScope);\n\n        _get(Object.getPrototypeOf(ClassScope.prototype), \"constructor\", this).call(this, scopeManager, \"class\", upperScope, block, false);\n    }\n\n    _inherits(ClassScope, _Scope11);\n\n    return ClassScope;\n})(Scope);\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjb3BlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdCUyxNQUFNLFdBQVEsWUFBWSxFQUExQixNQUFNOztJQUNSLEdBQUcsMkJBQU0sU0FBUzs7SUFFbEIsU0FBUywyQkFBTSxhQUFhOztJQUM1QixRQUFRLDJCQUFNLFlBQVk7O0lBQzFCLFVBQVUsMkJBQU0sY0FBYzs7SUFDOUIsTUFBTSwyQkFBTSxRQUFROztBQUUzQixTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLGtCQUFrQixFQUFFLFlBQVksRUFBRTtBQUNuRSxRQUFJLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7OztBQUc1QixRQUFJLEtBQUssQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDckMsZUFBTyxJQUFJLENBQUM7S0FDZjs7O0FBR0QsUUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRTtBQUMvQyxlQUFPLElBQUksQ0FBQztLQUNmOztBQUVELFFBQUksa0JBQWtCLEVBQUU7QUFDcEIsZUFBTyxJQUFJLENBQUM7S0FDZjs7QUFFRCxRQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO0FBQ25ELGVBQU8sSUFBSSxDQUFDO0tBQ2Y7O0FBRUQsUUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUNuRCxlQUFPLEtBQUssQ0FBQztLQUNoQjs7QUFFRCxRQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFFO0FBQzNCLFlBQUksS0FBSyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsT0FBTyxFQUFFO0FBQy9CLGdCQUFJLEdBQUcsS0FBSyxDQUFDO1NBQ2hCLE1BQU07QUFDSCxnQkFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7U0FDckI7S0FDSixNQUFNLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7QUFDaEMsWUFBSSxHQUFHLEtBQUssQ0FBQztLQUNoQixNQUFNO0FBQ0gsZUFBTyxLQUFLLENBQUM7S0FDaEI7OztBQUdELFFBQUksWUFBWSxFQUFFO0FBQ2QsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQzVDLGdCQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixnQkFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtBQUN6QyxzQkFBTTthQUNUO0FBQ0QsZ0JBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxnQkFBYyxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssY0FBZ0IsRUFBRTtBQUM5RCx1QkFBTyxJQUFJLENBQUM7YUFDZjtTQUNKO0tBQ0osTUFBTTtBQUNILGFBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUM1QyxnQkFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsZ0JBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsbUJBQW1CLEVBQUU7QUFDMUMsc0JBQU07YUFDVDtBQUNELGdCQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUN2QixnQkFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxPQUFPLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUNoRSxzQkFBTTthQUNUO0FBQ0QsZ0JBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsb0JBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxnQkFBYyxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssY0FBZ0IsRUFBRTtBQUM5RCwyQkFBTyxJQUFJLENBQUM7aUJBQ2Y7YUFDSixNQUFNO0FBQ0gsb0JBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxZQUFZLEVBQUU7QUFDN0IsMkJBQU8sSUFBSSxDQUFDO2lCQUNmO2FBQ0o7U0FDSjtLQUNKO0FBQ0QsV0FBTyxLQUFLLENBQUM7Q0FDaEI7O0FBRUQsU0FBUyxhQUFhLENBQUMsWUFBWSxFQUFFLEtBQUssRUFBRTtBQUN4QyxRQUFJLE1BQU0sQ0FBQzs7QUFFWCxnQkFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWhDLFVBQU0sR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckQsUUFBSSxNQUFNLEVBQUU7QUFDUixjQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RCLE1BQU07QUFDSCxvQkFBWSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFFLEtBQUssQ0FBRSxDQUFDLENBQUM7S0FDMUQ7Q0FDSjs7QUFFRCxTQUFTLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtBQUM3QixXQUNJLEFBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsU0FBUyxJQUMvQixHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxRQUFRLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssS0FBSyxBQUFDLENBQy9EO0NBQ0w7Ozs7OztJQUtvQixLQUFLO0FBQ1gsYUFETSxLQUFLLENBQ1YsWUFBWSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLGtCQUFrQixFQUFFOzhCQUR0RCxLQUFLOzs7Ozs7QUFNbEIsWUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Ozs7OztBQU1qQixZQUFJLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Ozs7O0FBS3JCLFlBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7QUFXeEIsWUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQzs7Ozs7QUFLOUQsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Ozs7O0FBS25CLFlBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0FBT2xCLFlBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7O0FBVXBCLFlBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDOzs7Ozs7OztBQVFyQixZQUFJLENBQUMsYUFBYSxHQUNkLEFBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEdBQUksSUFBSSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUM7Ozs7O0FBS3JILFlBQUksQ0FBQyx1QkFBdUIsR0FBRyxLQUFLLENBQUM7Ozs7O0FBS3JDLFlBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7Ozs7QUFJbkMsWUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7O0FBRXZCLFlBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDOzs7Ozs7QUFNakIsWUFBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUM7Ozs7O0FBS3hCLFlBQUksQ0FBQyxRQUFRLEdBQUcsYUFBYSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsWUFBWSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7Ozs7OztBQU05RixZQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN0QixZQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDWixnQkFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3JDOztBQUVELFlBQUksQ0FBQyxtQkFBbUIsR0FBRyxZQUFZLENBQUMsbUJBQW1CLENBQUM7O0FBRTVELHFCQUFhLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3JDOztpQkF6R2dCLEtBQUs7QUEyR3RCLCtCQUF1QjttQkFBQSxpQ0FBQyxZQUFZLEVBQUU7QUFDbEMsdUJBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQyxjQUFjLEVBQUUsQ0FBRTthQUMzRDs7QUFFRCx3Q0FBZ0M7bUJBQUEsMENBQUMsR0FBRyxFQUFFOztBQUVsQyxvQkFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7QUFDL0Isb0JBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNyQiwyQkFBTyxLQUFLLENBQUM7aUJBQ2hCOztBQUVELG9CQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsQyxvQkFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztBQUN6Qix1QkFBTyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDNUQ7O0FBRUQsd0JBQWdCO21CQUFBLDBCQUFDLEdBQUcsRUFBRTtBQUNsQixvQkFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdEIsd0JBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDcEM7YUFDSjs7QUFFRCx5QkFBaUI7bUJBQUEsMkJBQUMsR0FBRyxFQUFFOztBQUVuQixvQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ25CLG1CQUFHO0FBQ0MsMkJBQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLDJCQUFPLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztpQkFDM0IsUUFBUSxPQUFPLEVBQUU7YUFDckI7O0FBRUQsd0JBQWdCO21CQUFBLDBCQUFDLEdBQUcsRUFBRTs7O0FBR2xCLG9CQUFJLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUM1Qyx3QkFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUM5QixNQUFNO0FBQ0gsd0JBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDL0I7YUFDSjs7QUFFRCxlQUFPO21CQUFBLGlCQUFDLFlBQVksRUFBRTtBQUNsQixvQkFBSSxRQUFRLENBQUM7QUFDYixvQkFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDNUMsNEJBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7aUJBQ3BDLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUMvQiw0QkFBUSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztpQkFDckMsTUFBTTtBQUNILDRCQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO2lCQUNwQzs7O0FBR0QscUJBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ2xELHdCQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLDRCQUFRLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDNUI7QUFDRCxvQkFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRW5CLHVCQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7YUFDckI7O0FBRUQsaUJBQVM7bUJBQUEsbUJBQUMsR0FBRyxFQUFFO0FBQ1gsb0JBQUksUUFBUSxFQUFFLElBQUksQ0FBQztBQUNuQixvQkFBSSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO0FBQzNCLG9CQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3BCLDRCQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDOUIsNEJBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlCLDRCQUFRLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDLGFBQWEsQ0FBQztBQUNqRix3QkFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ2IsZ0NBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLDRCQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO3FCQUN4QztBQUNELHVCQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUN4QiwyQkFBTyxJQUFJLENBQUM7aUJBQ2Y7QUFDRCx1QkFBTyxLQUFLLENBQUM7YUFDaEI7O0FBRUQsOEJBQXNCO21CQUFBLGdDQUFDLEdBQUcsRUFBRTtBQUN4QixvQkFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ1osd0JBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDL0I7QUFDRCxvQkFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDMUI7O0FBRUQsb0NBQTRCO21CQUFBLHNDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUU7QUFDekMsb0JBQUksSUFBSSxJQUFJLElBQUksRUFBRTtBQUNkLDJCQUFPO2lCQUNWOztBQUVELG9CQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ25ELG9CQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7QUFDbkIsNkJBQVMsR0FBRyxFQUFFLENBQUM7QUFDZix3QkFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7aUJBQ2pEO0FBQ0Qsb0JBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNwQyw2QkFBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDNUI7YUFDSjs7QUFFRCx1QkFBZTttQkFBQSx5QkFBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQzdDLG9CQUFJLFFBQVEsQ0FBQzs7QUFFYix3QkFBUSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekIsb0JBQUksQ0FBQyxRQUFRLEVBQUU7QUFDWCw0QkFBUSxHQUFHLElBQUksUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNwQyx1QkFBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDeEIsNkJBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzVCOztBQUVELG9CQUFJLEdBQUcsRUFBRTtBQUNMLDRCQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4Qix3QkFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDM0IsNEJBQUksQ0FBQyw0QkFBNEIsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RELDRCQUFJLENBQUMsNEJBQTRCLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDM0Q7aUJBQ0o7QUFDRCxvQkFBSSxJQUFJLEVBQUU7QUFDTiw0QkFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ25DO2FBQ0o7O0FBRUQsZ0JBQVE7bUJBQUEsa0JBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtBQUNoQixvQkFBSSxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsVUFBVSxFQUFFO0FBQ3pDLHdCQUFJLENBQUMsZUFBZSxDQUNaLElBQUksQ0FBQyxJQUFJLEVBQ1QsSUFBSSxDQUFDLEdBQUcsRUFDUixJQUFJLENBQUMsU0FBUyxFQUNkLElBQUksRUFDSixHQUFHLENBQUMsQ0FBQztpQkFDaEI7YUFDSjs7QUFFRCxxQkFBYTttQkFBQSx1QkFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFOztBQUV2RSxvQkFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxVQUFVLEVBQUU7QUFDMUMsMkJBQU87aUJBQ1Y7OztBQUdELG9CQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO0FBQ3ZCLDJCQUFPO2lCQUNWOztBQUVELG9CQUFJLEdBQUcsR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqSCxvQkFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUIsb0JBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3pCOztBQUVELG9CQUFZO21CQUFBLHdCQUFHO0FBQ1gsb0JBQUksT0FBTyxDQUFDO0FBQ1osdUJBQU8sR0FBRyxJQUFJLENBQUM7QUFDZixvQkFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQztBQUNsQyxtQkFBRztBQUNDLDJCQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN2QiwyQkFBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7aUJBQzNCLFFBQVEsT0FBTyxFQUFFO2FBQ3JCOztBQUVELG9CQUFZO21CQUFBLHdCQUFHO0FBQ1gsb0JBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO2FBQ3pCOztBQUVELGtCQUFVO21CQUFBLHNCQUFHO0FBQ1QsdUJBQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUM7YUFDL0I7O0FBUUQsZUFBTzs7Ozs7Ozs7O21CQUFBLGlCQUFDLEtBQUssRUFBRTtBQUNYLG9CQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBQ2Ysc0JBQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUseUJBQXlCLENBQUMsQ0FBQztBQUNyRCxzQkFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLFVBQVUsRUFBRSw4QkFBOEIsQ0FBQyxDQUFDO0FBQ3pFLHFCQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDbEQsdUJBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLHdCQUFJLEdBQUcsQ0FBQyxVQUFVLEtBQUssS0FBSyxFQUFFO0FBQzFCLCtCQUFPLEdBQUcsQ0FBQztxQkFDZDtpQkFDSjtBQUNELHVCQUFPLElBQUksQ0FBQzthQUNmOztBQU9ELGdCQUFROzs7Ozs7OzttQkFBQSxvQkFBRztBQUNQLHVCQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQzthQUN4Qjs7QUFPRCwrQkFBdUI7Ozs7Ozs7O21CQUFBLG1DQUFHO0FBQ3RCLHVCQUFPLElBQUksQ0FBQzthQUNmOztBQU9ELDBCQUFrQjs7Ozs7Ozs7bUJBQUEsOEJBQUc7QUFDakIsdUJBQU8sSUFBSSxDQUFDO2FBQ2Y7O0FBRUQsa0JBQVU7bUJBQUEsb0JBQUMsSUFBSSxFQUFFO0FBQ2Isb0JBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDcEIsMkJBQU8sSUFBSSxDQUFDO2lCQUNmO0FBQ0QscUJBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ25ELHdCQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUU7QUFDMUMsK0JBQU8sSUFBSSxDQUFDO3FCQUNmO2lCQUNKO0FBQ0QsdUJBQU8sS0FBSyxDQUFDO2FBQ2hCOzs7O1dBMVVnQixLQUFLOzs7cUJBQUwsS0FBSzs7SUE2VWIsV0FBVyxXQUFYLFdBQVc7QUFDVCxhQURGLFdBQVcsQ0FDUixZQUFZLEVBQUUsS0FBSyxFQUFFOzhCQUR4QixXQUFXOztBQUVoQixtQ0FGSyxXQUFXLDZDQUVWLFlBQVksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDbEQsWUFBSSxDQUFDLFFBQVEsR0FBRztBQUNaLGVBQUcsRUFBRSxJQUFJLEdBQUcsRUFBRTtBQUNkLHFCQUFTLEVBQUUsRUFBRTs7Ozs7O0FBTWIsZ0JBQUksRUFBRSxFQUFFO1NBQ1gsQ0FBQztLQUNMOztjQWJRLFdBQVc7O2lCQUFYLFdBQVc7QUFlcEIsZUFBTzttQkFBQSxpQkFBQyxZQUFZLEVBQUU7QUFDbEIsb0JBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNsQixxQkFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDbEQsd0JBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekIsd0JBQUksR0FBRyxDQUFDLHFCQUFxQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNqRSxnQ0FBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQztxQkFDNUM7aUJBQ0o7OztBQUdELHFCQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQy9DLHdCQUFJLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsd0JBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUMxQixJQUFJLFVBQVUsQ0FDVixRQUFRLENBQUMsc0JBQXNCLEVBQy9CLElBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLElBQUksRUFDVCxJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksQ0FDUCxDQUFDLENBQUM7aUJBRWQ7O0FBRUQsb0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7O0FBRWpDLGtEQXpDSyxXQUFXLHlDQXlDSyxZQUFZLEVBQUU7YUFDdEM7O0FBRUQsd0JBQWdCO21CQUFBLDBCQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDeEIsb0JBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLFVBQVUsRUFBRTtBQUN6Qyx3QkFBSSxDQUFDLGVBQWUsQ0FDWixJQUFJLENBQUMsSUFBSSxFQUNULElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFDdkIsSUFBSSxFQUNKLEdBQUcsQ0FBQyxDQUFDO2lCQUNoQjthQUNKOzs7O1dBckRRLFdBQVc7R0FBUyxLQUFLOztJQXdEekIsV0FBVyxXQUFYLFdBQVc7QUFDVCxhQURGLFdBQVcsQ0FDUixZQUFZLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRTs4QkFEcEMsV0FBVzs7QUFFaEIsbUNBRkssV0FBVyw2Q0FFVixZQUFZLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0tBQzNEOztjQUhRLFdBQVc7O1dBQVgsV0FBVztHQUFTLEtBQUs7O0lBTXpCLDJCQUEyQixXQUEzQiwyQkFBMkI7QUFDekIsYUFERiwyQkFBMkIsQ0FDeEIsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUU7OEJBRHBDLDJCQUEyQjs7QUFFaEMsbUNBRkssMkJBQTJCLDZDQUUxQixZQUFZLEVBQUUsMEJBQTBCLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDMUUsWUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUNkLElBQUksVUFBVSxDQUNWLFFBQVEsQ0FBQyxZQUFZLEVBQ3JCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsS0FBSyxFQUNMLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxDQUNQLENBQUMsQ0FBQztBQUNYLFlBQUksQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUM7S0FDdkM7O2NBYlEsMkJBQTJCOztXQUEzQiwyQkFBMkI7R0FBUyxLQUFLOztJQWdCekMsVUFBVSxXQUFWLFVBQVU7QUFDUixhQURGLFVBQVUsQ0FDUCxZQUFZLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRTs4QkFEcEMsVUFBVTs7QUFFZixtQ0FGSyxVQUFVLDZDQUVULFlBQVksRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7S0FDMUQ7O2NBSFEsVUFBVTs7V0FBVixVQUFVO0dBQVMsS0FBSzs7SUFNeEIsU0FBUyxXQUFULFNBQVM7QUFDUCxhQURGLFNBQVMsQ0FDTixZQUFZLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRTs4QkFEcEMsU0FBUzs7QUFFZCxtQ0FGSyxTQUFTLDZDQUVSLFlBQVksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7S0FDekQ7O2NBSFEsU0FBUzs7aUJBQVQsU0FBUztBQUtsQixlQUFPO21CQUFBLGlCQUFDLFlBQVksRUFBRTtBQUNsQixvQkFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDNUMsc0RBUEMsU0FBUyx5Q0FPVyxZQUFZLEVBQUU7aUJBQ3RDOztBQUVELHFCQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUNsRCx3QkFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6Qix1QkFBRyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDbkIsd0JBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDcEM7QUFDRCxvQkFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRW5CLHVCQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7YUFDckI7Ozs7V0FsQlEsU0FBUztHQUFTLEtBQUs7O0lBcUJ2QixRQUFRLFdBQVIsUUFBUTtBQUNOLGFBREYsUUFBUSxDQUNMLFlBQVksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFOzhCQURwQyxRQUFROztBQUViLG1DQUZLLFFBQVEsNkNBRVAsWUFBWSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtLQUN4RDs7Y0FIUSxRQUFROztXQUFSLFFBQVE7R0FBUyxLQUFLOztJQU10QixVQUFVLFdBQVYsVUFBVTtBQUNSLGFBREYsVUFBVSxDQUNQLFlBQVksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFOzhCQURwQyxVQUFVOztBQUVmLG1DQUZLLFVBQVUsNkNBRVQsWUFBWSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtLQUMxRDs7Y0FIUSxVQUFVOztXQUFWLFVBQVU7R0FBUyxLQUFLOztJQU14QixXQUFXLFdBQVgsV0FBVztBQUNULGFBREYsV0FBVyxDQUNSLFlBQVksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFOzhCQURwQyxXQUFXOztBQUVoQixtQ0FGSyxXQUFXLDZDQUVWLFlBQVksRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7S0FDM0Q7O2NBSFEsV0FBVzs7V0FBWCxXQUFXO0dBQVMsS0FBSzs7SUFNekIsYUFBYSxXQUFiLGFBQWE7QUFDWCxhQURGLGFBQWEsQ0FDVixZQUFZLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRTs4QkFEeEQsYUFBYTs7QUFFbEIsbUNBRkssYUFBYSw2Q0FFWixZQUFZLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsa0JBQWtCLEVBQUU7Ozs7QUFJdkUsWUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsdUJBQXVCLEVBQUU7QUFDcEQsZ0JBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1NBQzVCO0tBQ0o7O2NBVFEsYUFBYTs7aUJBQWIsYUFBYTtBQVd0QiwrQkFBdUI7bUJBQUEsbUNBQUc7Ozs7Ozs7OztBQVN0QixvQkFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsdUJBQXVCLEVBQUU7QUFDcEQsMkJBQU8sS0FBSyxDQUFDO2lCQUNoQjs7QUFFRCxvQkFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtBQUNsQiwyQkFBTyxJQUFJLENBQUM7aUJBQ2Y7O0FBRUQsb0JBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3pDLHNCQUFNLENBQUMsUUFBUSxFQUFFLGlDQUFpQyxDQUFDLENBQUM7QUFDcEQsdUJBQU8sUUFBUSxDQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sS0FBTSxDQUFDLENBQUM7YUFDaEU7O0FBRUQsMEJBQWtCO21CQUFBLDhCQUFHO0FBQ2pCLG9CQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO0FBQ2xCLDJCQUFPLElBQUksQ0FBQztpQkFDZjtBQUNELHVCQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7YUFDekI7O0FBRUQseUJBQWlCO21CQUFBLDZCQUFHO0FBQ2hCLG9CQUFJLENBQUMsZUFBZSxDQUNaLFdBQVcsRUFDWCxJQUFJLENBQUMsR0FBRyxFQUNSLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxFQUNKLElBQUksQ0FBQyxDQUFDO0FBQ2Qsb0JBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN0Qzs7OztXQWhEUSxhQUFhO0dBQVMsS0FBSzs7SUFtRDNCLFFBQVEsV0FBUixRQUFRO0FBQ04sYUFERixRQUFRLENBQ0wsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUU7OEJBRHBDLFFBQVE7O0FBRWIsbUNBRkssUUFBUSw2Q0FFUCxZQUFZLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0tBQ3hEOztjQUhRLFFBQVE7O1dBQVIsUUFBUTtHQUFTLEtBQUs7O0lBTXRCLFVBQVUsV0FBVixVQUFVO0FBQ1IsYUFERixVQUFVLENBQ1AsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUU7OEJBRHBDLFVBQVU7O0FBRWYsbUNBRkssVUFBVSw2Q0FFVCxZQUFZLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0tBQzFEOztjQUhRLFVBQVU7O1dBQVYsVUFBVTtHQUFTLEtBQUsiLCJmaWxlIjoic2NvcGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFN5bnRheCB9IGZyb20gJ2VzdHJhdmVyc2UnO1xuaW1wb3J0IE1hcCBmcm9tICdlczYtbWFwJztcblxuaW1wb3J0IFJlZmVyZW5jZSBmcm9tICcuL3JlZmVyZW5jZSc7XG5pbXBvcnQgVmFyaWFibGUgZnJvbSAnLi92YXJpYWJsZSc7XG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tICcuL2RlZmluaXRpb24nO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5mdW5jdGlvbiBpc1N0cmljdFNjb3BlKHNjb3BlLCBibG9jaywgaXNNZXRob2REZWZpbml0aW9uLCB1c2VEaXJlY3RpdmUpIHtcbiAgICB2YXIgYm9keSwgaSwgaXosIHN0bXQsIGV4cHI7XG5cbiAgICAvLyBXaGVuIHVwcGVyIHNjb3BlIGlzIGV4aXN0cyBhbmQgc3RyaWN0LCBpbm5lciBzY29wZSBpcyBhbHNvIHN0cmljdC5cbiAgICBpZiAoc2NvcGUudXBwZXIgJiYgc2NvcGUudXBwZXIuaXNTdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ncyBzY29wZSBpcyBhbHdheXMgc3RyaWN0IHNjb3BlLlxuICAgIGlmIChibG9jay50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUudHlwZSA9PT0gJ2NsYXNzJyB8fCBzY29wZS50eXBlID09PSAnbW9kdWxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUudHlwZSA9PT0gJ2Jsb2NrJyB8fCBzY29wZS50eXBlID09PSAnc3dpdGNoJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICBib2R5ID0gYmxvY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gYmxvY2suYm9keTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgYm9keSA9IGJsb2NrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZS5cbiAgICBpZiAodXNlRGlyZWN0aXZlKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gYm9keS5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHN0bXQgPSBib2R5LmJvZHlbaV07XG4gICAgICAgICAgICBpZiAoc3RtdC50eXBlICE9PSBTeW50YXguRGlyZWN0aXZlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5yYXcgPT09ICdcInVzZSBzdHJpY3RcIicgfHwgc3RtdC5yYXcgPT09ICdcXCd1c2Ugc3RyaWN0XFwnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBib2R5LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgc3RtdCA9IGJvZHkuYm9keVtpXTtcbiAgICAgICAgICAgIGlmIChzdG10LnR5cGUgIT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gc3RtdC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gU3ludGF4LkxpdGVyYWwgfHwgdHlwZW9mIGV4cHIudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5yYXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnJhdyA9PT0gJ1widXNlIHN0cmljdFwiJyB8fCBleHByLnJhdyA9PT0gJ1xcJ3VzZSBzdHJpY3RcXCcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNjb3BlKHNjb3BlTWFuYWdlciwgc2NvcGUpIHtcbiAgICB2YXIgc2NvcGVzO1xuXG4gICAgc2NvcGVNYW5hZ2VyLnNjb3Blcy5wdXNoKHNjb3BlKTtcblxuICAgIHNjb3BlcyA9IHNjb3BlTWFuYWdlci5fX25vZGVUb1Njb3BlLmdldChzY29wZS5ibG9jayk7XG4gICAgaWYgKHNjb3Blcykge1xuICAgICAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVNYW5hZ2VyLl9fbm9kZVRvU2NvcGUuc2V0KHNjb3BlLmJsb2NrLCBbIHNjb3BlIF0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQmVTdGF0aWNhbGx5KGRlZikge1xuICAgIHJldHVybiAoXG4gICAgICAgIChkZWYudHlwZSA9PT0gVmFyaWFibGUuQ2xhc3NOYW1lKSB8fFxuICAgICAgICAoZGVmLnR5cGUgPT09IFZhcmlhYmxlLlZhcmlhYmxlICYmIGRlZi5wYXJlbnQua2luZCAhPT0gJ3ZhcicpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgU2NvcGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdHlwZSwgdXBwZXJTY29wZSwgYmxvY2ssIGlzTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogT25lIG9mICdURFonLCAnbW9kdWxlJywgJ2Jsb2NrJywgJ3N3aXRjaCcsICdmdW5jdGlvbicsICdjYXRjaCcsICd3aXRoJywgJ2Z1bmN0aW9uJywgJ2NsYXNzJywgJ2dsb2JhbCcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gU2NvcGUjdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGVkIHtAbGluayBWYXJpYWJsZX1zIG9mIHRoaXMgc2NvcGUsIGFzIDxjb2RlPnsgVmFyaWFibGUubmFtZVxuICAgICAgICAgKiA6IFZhcmlhYmxlIH08L2NvZGU+LlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IFNjb3BlI3NldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFpbnRlZCB2YXJpYWJsZXMgb2YgdGhpcyBzY29wZSwgYXMgPGNvZGU+eyBWYXJpYWJsZS5uYW1lIDpcbiAgICAgICAgICogYm9vbGVhbiB9PC9jb2RlPi5cbiAgICAgICAgICogQG1lbWJlciB7TWFwfSBTY29wZSN0YWludHMgKi9cbiAgICAgICAgdGhpcy50YWludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmFsbHksIHRocm91Z2ggdGhlIGxleGljYWwgc2NvcGluZyBvZiBKUyB5b3UgY2FuIGFsd2F5cyBrbm93XG4gICAgICAgICAqIHdoaWNoIHZhcmlhYmxlIGFuIGlkZW50aWZpZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHJlZmVycyB0by4gVGhlcmUgYXJlXG4gICAgICAgICAqIGEgZmV3IGV4Y2VwdGlvbnMgdG8gdGhpcyBydWxlLiBXaXRoICdnbG9iYWwnIGFuZCAnd2l0aCcgc2NvcGVzIHlvdVxuICAgICAgICAgKiBjYW4gb25seSBkZWNpZGUgYXQgcnVudGltZSB3aGljaCB2YXJpYWJsZSBhIHJlZmVyZW5jZSByZWZlcnMgdG8uXG4gICAgICAgICAqIE1vcmVvdmVyLCBpZiAnZXZhbCgpJyBpcyB1c2VkIGluIGEgc2NvcGUsIGl0IG1pZ2h0IGludHJvZHVjZSBuZXdcbiAgICAgICAgICogYmluZGluZ3MgaW4gdGhpcyBvciBpdHMgcGFyZW50IHNjb3Blcy5cbiAgICAgICAgICogQWxsIHRob3NlIHNjb3BlcyBhcmUgY29uc2lkZXJlZCAnZHluYW1pYycuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFNjb3BlI2R5bmFtaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHRoaXMudHlwZSA9PT0gJ2dsb2JhbCcgfHwgdGhpcy50eXBlID09PSAnd2l0aCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgc2NvcGUtZGVmaW5pbmcgc3ludGF4IG5vZGUuXG4gICAgICAgICAqIEBtZW1iZXIge2VzcHJpbWEuTm9kZX0gU2NvcGUjYmxvY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUge0BsaW5rIFJlZmVyZW5jZXxyZWZlcmVuY2VzfSB0aGF0IGFyZSBub3QgcmVzb2x2ZWQgd2l0aCB0aGlzIHNjb3BlLlxuICAgICAgICAgKiBAbWVtYmVyIHtSZWZlcmVuY2VbXX0gU2NvcGUjdGhyb3VnaFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aHJvdWdoID0gW107XG4gICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlZCB7QGxpbmsgVmFyaWFibGV9cyBvZiB0aGlzIHNjb3BlLiBJbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgICAqICdmdW5jdGlvbicgc2NvcGUgdGhpcyBpbmNsdWRlcyB0aGUgYXV0b21hdGljIGFyZ3VtZW50IDxlbT5hcmd1bWVudHM8L2VtPiBhc1xuICAgICAgICAgKiBpdHMgZmlyc3QgZWxlbWVudCwgYXMgd2VsbCBhcyBhbGwgZnVydGhlciBmb3JtYWwgYXJndW1lbnRzLlxuICAgICAgICAgKiBAbWVtYmVyIHtWYXJpYWJsZVtdfSBTY29wZSN2YXJpYWJsZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gW107XG4gICAgICAgICAvKipcbiAgICAgICAgICogQW55IHZhcmlhYmxlIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlfSBmb3VuZCBpbiB0aGlzIHNjb3BlLiBUaGlzXG4gICAgICAgICAqIGluY2x1ZGVzIG9jY3VycmVuY2VzIG9mIGxvY2FsIHZhcmlhYmxlcyBhcyB3ZWxsIGFzIHZhcmlhYmxlcyBmcm9tXG4gICAgICAgICAqIHBhcmVudCBzY29wZXMgKGluY2x1ZGluZyB0aGUgZ2xvYmFsIHNjb3BlKS4gRm9yIGxvY2FsIHZhcmlhYmxlc1xuICAgICAgICAgKiB0aGlzIGFsc28gaW5jbHVkZXMgZGVmaW5pbmcgb2NjdXJyZW5jZXMgKGxpa2UgaW4gYSAndmFyJyBzdGF0ZW1lbnQpLlxuICAgICAgICAgKiBJbiBhICdmdW5jdGlvbicgc2NvcGUgdGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBvY2N1cnJlbmNlcyBvZiB0aGVcbiAgICAgICAgICogZm9ybWFsIHBhcmFtZXRlciBpbiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge1JlZmVyZW5jZVtdfSBTY29wZSNyZWZlcmVuY2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciAnZ2xvYmFsJyBhbmQgJ2Z1bmN0aW9uJyBzY29wZXMsIHRoaXMgaXMgYSBzZWxmLXJlZmVyZW5jZS4gRm9yXG4gICAgICAgICAqIG90aGVyIHNjb3BlIHR5cGVzIHRoaXMgaXMgdGhlIDxlbT52YXJpYWJsZVNjb3BlPC9lbT4gdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIHBhcmVudCBzY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGV9IFNjb3BlI3ZhcmlhYmxlU2NvcGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFyaWFibGVTY29wZSA9XG4gICAgICAgICAgICAodGhpcy50eXBlID09PSAnZ2xvYmFsJyB8fCB0aGlzLnR5cGUgPT09ICdmdW5jdGlvbicgfHwgdGhpcy50eXBlID09PSAnbW9kdWxlJykgPyB0aGlzIDogdXBwZXJTY29wZS52YXJpYWJsZVNjb3BlO1xuICAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBzY29wZSBpcyBjcmVhdGVkIGJ5IGEgRnVuY3Rpb25FeHByZXNzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSNmdW5jdGlvbkV4cHJlc3Npb25TY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvbkV4cHJlc3Npb25TY29wZSA9IGZhbHNlO1xuICAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIHNjb3BlIHRoYXQgY29udGFpbnMgYW4gJ2V2YWwoKScgaW52b2NhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gU2NvcGUjZGlyZWN0Q2FsbFRvRXZhbFNjb3BlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdENhbGxUb0V2YWxTY29wZSA9IGZhbHNlO1xuICAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFNjb3BlI3RoaXNGb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGlzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9fbGVmdCA9IFtdO1xuXG4gICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQge0BsaW5rIFNjb3BlfHNjb3BlfS5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGV9IFNjb3BlI3VwcGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwcGVyID0gdXBwZXJTY29wZTtcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyICd1c2Ugc3RyaWN0JyBpcyBpbiBlZmZlY3QgaW4gdGhpcyBzY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gU2NvcGUjaXNTdHJpY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTdHJpY3QgPSBpc1N0cmljdFNjb3BlKHRoaXMsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24sIHNjb3BlTWFuYWdlci5fX3VzZURpcmVjdGl2ZSgpKTtcblxuICAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgbmVzdGVkIHtAbGluayBTY29wZX1zLlxuICAgICAgICAgKiBAbWVtYmVyIHtTY29wZVtdfSBTY29wZSNjaGlsZFNjb3Blc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZFNjb3BlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy51cHBlcikge1xuICAgICAgICAgICAgdGhpcy51cHBlci5jaGlsZFNjb3Blcy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2RlY2xhcmVkVmFyaWFibGVzID0gc2NvcGVNYW5hZ2VyLl9fZGVjbGFyZWRWYXJpYWJsZXM7XG5cbiAgICAgICAgcmVnaXN0ZXJTY29wZShzY29wZU1hbmFnZXIsIHRoaXMpO1xuICAgIH1cblxuICAgIF9fc2hvdWxkU3RhdGljYWxseUNsb3NlKHNjb3BlTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmR5bmFtaWMgfHwgc2NvcGVNYW5hZ2VyLl9faXNPcHRpbWlzdGljKCkpO1xuICAgIH1cblxuICAgIF9fc2hvdWxkU3RhdGljYWxseUNsb3NlRm9yR2xvYmFsKHJlZikge1xuICAgICAgICAvLyBPbiBnbG9iYWwgc2NvcGUsIGxldC9jb25zdC9jbGFzcyBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIHJlc29sdmVkIHN0YXRpY2FsbHkuXG4gICAgICAgIHZhciBuYW1lID0gcmVmLmlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgaWYgKCF0aGlzLnNldC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YXJpYWJsZSA9IHRoaXMuc2V0LmdldChuYW1lKTtcbiAgICAgICAgdmFyIGRlZnMgPSB2YXJpYWJsZS5kZWZzO1xuICAgICAgICByZXR1cm4gZGVmcy5sZW5ndGggPiAwICYmIGRlZnMuZXZlcnkoc2hvdWxkQmVTdGF0aWNhbGx5KTtcbiAgICB9XG5cbiAgICBfX3N0YXRpY0Nsb3NlUmVmKHJlZikge1xuICAgICAgICBpZiAoIXRoaXMuX19yZXNvbHZlKHJlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWxlZ2F0ZVRvVXBwZXJTY29wZShyZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19keW5hbWljQ2xvc2VSZWYocmVmKSB7XG4gICAgICAgIC8vIG5vdGlmeSBhbGwgbmFtZXMgYXJlIHRocm91Z2ggdG8gZ2xvYmFsXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudC50aHJvdWdoLnB1c2gocmVmKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnVwcGVyO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBfX2dsb2JhbENsb3NlUmVmKHJlZikge1xuICAgICAgICAvLyBsZXQvY29uc3QvY2xhc3MgZGVjbGFyYXRpb25zIHNob3VsZCBiZSByZXNvbHZlZCBzdGF0aWNhbGx5LlxuICAgICAgICAvLyBvdGhlcnMgc2hvdWxkIGJlIHJlc29sdmVkIGR5bmFtaWNhbGx5LlxuICAgICAgICBpZiAodGhpcy5fX3Nob3VsZFN0YXRpY2FsbHlDbG9zZUZvckdsb2JhbChyZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9fc3RhdGljQ2xvc2VSZWYocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19keW5hbWljQ2xvc2VSZWYocmVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fY2xvc2Uoc2NvcGVNYW5hZ2VyKSB7XG4gICAgICAgIHZhciBjbG9zZVJlZjtcbiAgICAgICAgaWYgKHRoaXMuX19zaG91bGRTdGF0aWNhbGx5Q2xvc2Uoc2NvcGVNYW5hZ2VyKSkge1xuICAgICAgICAgICAgY2xvc2VSZWYgPSB0aGlzLl9fc3RhdGljQ2xvc2VSZWY7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlICE9PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgY2xvc2VSZWYgPSB0aGlzLl9fZHluYW1pY0Nsb3NlUmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VSZWYgPSB0aGlzLl9fZ2xvYmFsQ2xvc2VSZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgUmVzb2x2aW5nIGFsbCByZWZlcmVuY2VzIGluIHRoaXMgc2NvcGUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpeiA9IHRoaXMuX19sZWZ0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGxldCByZWYgPSB0aGlzLl9fbGVmdFtpXTtcbiAgICAgICAgICAgIGNsb3NlUmVmLmNhbGwodGhpcywgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGVmdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBwZXI7XG4gICAgfVxuXG4gICAgX19yZXNvbHZlKHJlZikge1xuICAgICAgICB2YXIgdmFyaWFibGUsIG5hbWU7XG4gICAgICAgIG5hbWUgPSByZWYuaWRlbnRpZmllci5uYW1lO1xuICAgICAgICBpZiAodGhpcy5zZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMuc2V0LmdldChuYW1lKTtcbiAgICAgICAgICAgIHZhcmlhYmxlLnJlZmVyZW5jZXMucHVzaChyZWYpO1xuICAgICAgICAgICAgdmFyaWFibGUuc3RhY2sgPSB2YXJpYWJsZS5zdGFjayAmJiByZWYuZnJvbS52YXJpYWJsZVNjb3BlID09PSB0aGlzLnZhcmlhYmxlU2NvcGU7XG4gICAgICAgICAgICBpZiAocmVmLnRhaW50ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS50YWludGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaW50cy5zZXQodmFyaWFibGUubmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYucmVzb2x2ZWQgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfX2RlbGVnYXRlVG9VcHBlclNjb3BlKHJlZikge1xuICAgICAgICBpZiAodGhpcy51cHBlcikge1xuICAgICAgICAgICAgdGhpcy51cHBlci5fX2xlZnQucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3VnaC5wdXNoKHJlZik7XG4gICAgfVxuXG4gICAgX19hZGREZWNsYXJlZFZhcmlhYmxlc09mTm9kZSh2YXJpYWJsZSwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFyaWFibGVzID0gdGhpcy5fX2RlY2xhcmVkVmFyaWFibGVzLmdldChub2RlKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcy5zZXQobm9kZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVzLmluZGV4T2YodmFyaWFibGUpID09PSAtMSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19kZWZpbmVHZW5lcmljKG5hbWUsIHNldCwgdmFyaWFibGVzLCBub2RlLCBkZWYpIHtcbiAgICAgICAgdmFyIHZhcmlhYmxlO1xuXG4gICAgICAgIHZhcmlhYmxlID0gc2V0LmdldChuYW1lKTtcbiAgICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICAgICAgdmFyaWFibGUgPSBuZXcgVmFyaWFibGUobmFtZSwgdGhpcyk7XG4gICAgICAgICAgICBzZXQuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgaWYgKGRlZi50eXBlICE9PSBWYXJpYWJsZS5URFopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWRkRGVjbGFyZWRWYXJpYWJsZXNPZk5vZGUodmFyaWFibGUsIGRlZi5ub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWRkRGVjbGFyZWRWYXJpYWJsZXNPZk5vZGUodmFyaWFibGUsIGRlZi5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5pZGVudGlmaWVycy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19kZWZpbmUobm9kZSwgZGVmKSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVHZW5lcmljKFxuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fcmVmZXJlbmNpbmcobm9kZSwgYXNzaWduLCB3cml0ZUV4cHIsIG1heWJlSW1wbGljaXRHbG9iYWwsIHBhcnRpYWwsIGluaXQpIHtcbiAgICAgICAgLy8gYmVjYXVzZSBBcnJheSBlbGVtZW50IG1heSBiZSBudWxsXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsbHkgaGFuZGxlIGxpa2UgYHRoaXNgLlxuICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnc3VwZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVmID0gbmV3IFJlZmVyZW5jZShub2RlLCB0aGlzLCBhc3NpZ24gfHwgUmVmZXJlbmNlLlJFQUQsIHdyaXRlRXhwciwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgISFwYXJ0aWFsLCAhIWluaXQpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucHVzaChyZWYpO1xuICAgICAgICB0aGlzLl9fbGVmdC5wdXNoKHJlZik7XG4gICAgfVxuXG4gICAgX19kZXRlY3RFdmFsKCkge1xuICAgICAgICB2YXIgY3VycmVudDtcbiAgICAgICAgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlyZWN0Q2FsbFRvRXZhbFNjb3BlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnVwcGVyO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBfX2RldGVjdFRoaXMoKSB7XG4gICAgICAgIHRoaXMudGhpc0ZvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX2lzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xlZnQgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyByZXNvbHZlZCB7UmVmZXJlbmNlfVxuICAgICAqIEBtZXRob2QgU2NvcGUjcmVzb2x2ZVxuICAgICAqIEBwYXJhbSB7RXNwcmltYS5JZGVudGlmaWVyfSBpZGVudCAtIGlkZW50aWZpZXIgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICogQHJldHVybiB7UmVmZXJlbmNlfVxuICAgICAqL1xuICAgIHJlc29sdmUoaWRlbnQpIHtcbiAgICAgICAgdmFyIHJlZiwgaSwgaXo7XG4gICAgICAgIGFzc2VydCh0aGlzLl9faXNDbG9zZWQoKSwgJ1Njb3BlIHNob3VsZCBiZSBjbG9zZWQuJyk7XG4gICAgICAgIGFzc2VydChpZGVudC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciwgJ1RhcmdldCBzaG91bGQgYmUgaWRlbnRpZmllci4nKTtcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSB0aGlzLnJlZmVyZW5jZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5yZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJlZi5pZGVudGlmaWVyID09PSBpZGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGlzIHNjb3BlIGlzIHN0YXRpY1xuICAgICAqIEBtZXRob2QgU2NvcGUjaXNTdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU3RhdGljKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZHluYW1pYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoaXMgc2NvcGUgaGFzIG1hdGVyaWFsaXplZCBhcmd1bWVudHNcbiAgICAgKiBAbWV0aG9kIFNjb3BlI2lzQXJndW1lbnRzTWF0ZXJpYWxpemVkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FyZ3VtZW50c01hdGVyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGlzIHNjb3BlIGhhcyBtYXRlcmlhbGl6ZWQgYHRoaXNgIHJlZmVyZW5jZVxuICAgICAqIEBtZXRob2QgU2NvcGUjaXNUaGlzTWF0ZXJpYWxpemVkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RoaXNNYXRlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlzVXNlZE5hbWUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaXogPSB0aGlzLnRocm91Z2gubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGhyb3VnaFtpXS5pZGVudGlmaWVyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2xvYmFsU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdnbG9iYWwnLCBudWxsLCBibG9jaywgZmFsc2UpO1xuICAgICAgICB0aGlzLmltcGxpY2l0ID0ge1xuICAgICAgICAgICAgc2V0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IFtdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIExpc3Qgb2Yge0BsaW5rIFJlZmVyZW5jZX1zIHRoYXQgYXJlIGxlZnQgdG8gYmUgcmVzb2x2ZWQgKGkuZS4gd2hpY2hcbiAgICAgICAgICAgICogbmVlZCB0byBiZSBsaW5rZWQgdG8gdGhlIHZhcmlhYmxlIHRoZXkgcmVmZXIgdG8pLlxuICAgICAgICAgICAgKiBAbWVtYmVyIHtSZWZlcmVuY2VbXX0gU2NvcGUjaW1wbGljaXQjbGVmdFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxlZnQ6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX19jbG9zZShzY29wZU1hbmFnZXIpIHtcbiAgICAgICAgbGV0IGltcGxpY2l0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpeiA9IHRoaXMuX19sZWZ0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGxldCByZWYgPSB0aGlzLl9fbGVmdFtpXTtcbiAgICAgICAgICAgIGlmIChyZWYuX19tYXliZUltcGxpY2l0R2xvYmFsICYmICF0aGlzLnNldC5oYXMocmVmLmlkZW50aWZpZXIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbXBsaWNpdC5wdXNoKHJlZi5fX21heWJlSW1wbGljaXRHbG9iYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGltcGxpY2l0IGdsb2JhbCB2YXJpYWJsZSBmcm9tIGFzc2lnbm1lbnQgZXhwcmVzc2lvblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSBpbXBsaWNpdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IGltcGxpY2l0W2ldO1xuICAgICAgICAgICAgdGhpcy5fX2RlZmluZUltcGxpY2l0KGluZm8ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5JbXBsaWNpdEdsb2JhbFZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltcGxpY2l0LmxlZnQgPSB0aGlzLl9fbGVmdDtcblxuICAgICAgICByZXR1cm4gc3VwZXIuX19jbG9zZShzY29wZU1hbmFnZXIpO1xuICAgIH1cblxuICAgIF9fZGVmaW5lSW1wbGljaXQobm9kZSwgZGVmKSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVHZW5lcmljKFxuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wbGljaXQuc2V0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcGxpY2l0LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1vZHVsZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnbW9kdWxlJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkV4cHJlc3Npb25OYW1lU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdmdW5jdGlvbi1leHByZXNzaW9uLW5hbWUnLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9fZGVmaW5lKGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5GdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uRXhwcmVzc2lvblNjb3BlID0gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDYXRjaFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnY2F0Y2gnLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdpdGhTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ3dpdGgnLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cblxuICAgIF9fY2xvc2Uoc2NvcGVNYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLl9fc2hvdWxkU3RhdGljYWxseUNsb3NlKHNjb3BlTWFuYWdlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5fX2Nsb3NlKHNjb3BlTWFuYWdlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSB0aGlzLl9fbGVmdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy5fX2xlZnRbaV07XG4gICAgICAgICAgICByZWYudGFpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fZGVsZWdhdGVUb1VwcGVyU2NvcGUocmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGVmdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBwZXI7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVERaU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdURFonLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJsb2NrU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdibG9jaycsIHVwcGVyU2NvcGUsIGJsb2NrLCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3dpdGNoU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdzd2l0Y2gnLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaywgaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ2Z1bmN0aW9uJywgdXBwZXJTY29wZSwgYmxvY2ssIGlzTWV0aG9kRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gc2VjdGlvbiA5LjIuMTMsIEZ1bmN0aW9uRGVjbGFyYXRpb25JbnN0YW50aWF0aW9uLlxuICAgICAgICAvLyBOT1RFIEFycm93IGZ1bmN0aW9ucyBuZXZlciBoYXZlIGFuIGFyZ3VtZW50cyBvYmplY3RzLlxuICAgICAgICBpZiAodGhpcy5ibG9jay50eXBlICE9PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVBcmd1bWVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQXJndW1lbnRzTWF0ZXJpYWxpemVkKCkge1xuICAgICAgICAvLyBUT0RPKENvbnN0ZWxsYXRpb24pXG4gICAgICAgIC8vIFdlIGNhbiBtb3JlIGFnZ3Jlc3NpdmUgb24gdGhpcyBjb25kaXRpb24gbGlrZSB0aGlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiB0KCkge1xuICAgICAgICAvLyAgICAgLy8gYXJndW1lbnRzIG9mIHQgaXMgYWx3YXlzIGhpZGRlbi5cbiAgICAgICAgLy8gICAgIGZ1bmN0aW9uIGFyZ3VtZW50cygpIHtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAodGhpcy5ibG9jay50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2YXJpYWJsZSA9IHRoaXMuc2V0LmdldCgnYXJndW1lbnRzJyk7XG4gICAgICAgIGFzc2VydCh2YXJpYWJsZSwgJ0Fsd2F5cyBoYXZlIGFyZ3VtZW50cyB2YXJpYWJsZS4nKTtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlLnRhaW50ZWQgfHwgdmFyaWFibGUucmVmZXJlbmNlcy5sZW5ndGggICE9PSAwO1xuICAgIH1cblxuICAgIGlzVGhpc01hdGVyaWFsaXplZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRoaXNGb3VuZDtcbiAgICB9XG5cbiAgICBfX2RlZmluZUFyZ3VtZW50cygpIHtcbiAgICAgICAgdGhpcy5fX2RlZmluZUdlbmVyaWMoXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQsXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgdGhpcy50YWludHMuc2V0KCdhcmd1bWVudHMnLCB0cnVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGb3JTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ2ZvcicsIHVwcGVyU2NvcGUsIGJsb2NrLCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2xhc3NTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ2NsYXNzJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/scope.js\n ** module id = 105\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/scope.js?");

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        isArray,\n        VisitorOption,\n        VisitorKeys,\n        objectCreate,\n        objectKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function ignoreJSHintError() { }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    ignoreJSHintError(shallowCopy);\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    function lowerBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                i = current + 1;\n                len -= diff + 1;\n            } else {\n                len = diff;\n            }\n        }\n        return i;\n    }\n    ignoreJSHintError(lowerBound);\n\n    objectCreate = Object.create || (function () {\n        function F() { }\n\n        return function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    })();\n\n    objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n            keys.push(key);\n        }\n        return keys;\n    };\n\n    function extend(to, from) {\n        var keys = objectKeys(from), key, i, len;\n        for (i = 0, len = keys.length; i < len; i += 1) {\n            key = keys[i];\n            to[key] = from[key];\n        }\n        return to;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = visitor.fallback === 'iteration';\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = extend(objectCreate(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = objectKeys(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = objectKeys(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = __webpack_require__(107).version;\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/estraverse/estraverse.js\n ** module id = 106\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/estraverse/estraverse.js?");

/***/ },
/* 107 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"estraverse@^4.1.1\",\n\t\t\t\"/home/cs/Projects/rlet/node_modules/escope\"\n\t\t]\n\t],\n\t\"_from\": \"estraverse@>=4.1.1 <5.0.0\",\n\t\"_id\": \"estraverse@4.1.1\",\n\t\"_inCache\": true,\n\t\"_location\": \"/estraverse\",\n\t\"_nodeVersion\": \"4.1.1\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.14.4\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"estraverse\",\n\t\t\"raw\": \"estraverse@^4.1.1\",\n\t\t\"rawSpec\": \"^4.1.1\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=4.1.1 <5.0.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/escope\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz\",\n\t\"_shasum\": \"f6caca728933a850ef90661d0e17982ba47111a2\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"estraverse@^4.1.1\",\n\t\"_where\": \"/home/cs/Projects/rlet/node_modules/escope\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/estraverse/issues\"\n\t},\n\t\"dependencies\": {},\n\t\"description\": \"ECMAScript JS AST traversal functions\",\n\t\"devDependencies\": {\n\t\t\"chai\": \"^2.1.1\",\n\t\t\"coffee-script\": \"^1.8.0\",\n\t\t\"espree\": \"^1.11.0\",\n\t\t\"gulp\": \"^3.8.10\",\n\t\t\"gulp-bump\": \"^0.2.2\",\n\t\t\"gulp-filter\": \"^2.0.0\",\n\t\t\"gulp-git\": \"^1.0.1\",\n\t\t\"gulp-tag-version\": \"^1.2.1\",\n\t\t\"jshint\": \"^2.5.6\",\n\t\t\"mocha\": \"^2.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"f6caca728933a850ef90661d0e17982ba47111a2\",\n\t\t\"tarball\": \"http://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.10.0\"\n\t},\n\t\"gitHead\": \"bbcccbfe98296585e4311c8755e1d00dcd581e3c\",\n\t\"homepage\": \"https://github.com/estools/estraverse\",\n\t\"installable\": true,\n\t\"license\": \"BSD-2-Clause\",\n\t\"main\": \"estraverse.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"michaelficarra\",\n\t\t\t\"email\": \"npm@michael.ficarra.me\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"nzakas\",\n\t\t\t\"email\": \"nicholas@nczconsulting.com\"\n\t\t}\n\t],\n\t\"name\": \"estraverse\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+ssh://git@github.com/estools/estraverse.git\"\n\t},\n\t\"scripts\": {\n\t\t\"lint\": \"jshint estraverse.js\",\n\t\t\"test\": \"npm run-script lint && npm run-script unit-test\",\n\t\t\"unit-test\": \"mocha --compilers coffee:coffee-script/register\"\n\t},\n\t\"version\": \"4.1.1\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/estraverse/package.json\n ** module id = 107\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/estraverse/package.json?");

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(109)() ? Map : __webpack_require__(110);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/index.js\n ** module id = 108\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/index.js?");

/***/ },
/* 109 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\tvar map, iterator, result;\n\tif (typeof Map !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tmap = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(map) !== '[object Map]') return false;\n\tif (map.size !== 3) return false;\n\tif (typeof map.clear !== 'function') return false;\n\tif (typeof map.delete !== 'function') return false;\n\tif (typeof map.entries !== 'function') return false;\n\tif (typeof map.forEach !== 'function') return false;\n\tif (typeof map.get !== 'function') return false;\n\tif (typeof map.has !== 'function') return false;\n\tif (typeof map.keys !== 'function') return false;\n\tif (typeof map.set !== 'function') return false;\n\tif (typeof map.values !== 'function') return false;\n\n\titerator = map.entries();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (!result.value) return false;\n\tif (result.value[0] !== 'raz') return false;\n\tif (result.value[1] !== 'one') return false;\n\n\treturn true;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/is-implemented.js\n ** module id = 109\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/is-implemented.js?");

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar clear          = __webpack_require__(88)\n  , eIndexOf       = __webpack_require__(111)\n  , setPrototypeOf = __webpack_require__(63)\n  , callable       = __webpack_require__(89)\n  , validValue     = __webpack_require__(67)\n  , d              = __webpack_require__(71)\n  , ee             = __webpack_require__(117)\n  , Symbol         = __webpack_require__(95)\n  , iterator       = __webpack_require__(101)\n  , forOf          = __webpack_require__(103)\n  , Iterator       = __webpack_require__(118)\n  , isNative       = __webpack_require__(121)\n\n  , call = Function.prototype.call\n  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf\n  , MapPoly;\n\nmodule.exports = MapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], keys, values, self;\n\tif (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (Map !== MapPoly)) {\n\t\tself = setPrototypeOf(new Map(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) iterator(iterable);\n\tdefineProperties(self, {\n\t\t__mapKeysData__: d('c', keys = []),\n\t\t__mapValuesData__: d('c', values = [])\n\t});\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tvar key = validValue(value)[0];\n\t\tvalue = value[1];\n\t\tif (eIndexOf.call(keys, key) !== -1) return;\n\t\tkeys.push(key);\n\t\tvalues.push(value);\n\t}, self);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(MapPoly, Map);\n\tMapPoly.prototype = Object.create(Map.prototype, {\n\t\tconstructor: d(MapPoly)\n\t});\n}\n\nee(defineProperties(MapPoly.prototype, {\n\tclear: d(function () {\n\t\tif (!this.__mapKeysData__.length) return;\n\t\tclear.call(this.__mapKeysData__);\n\t\tclear.call(this.__mapValuesData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return false;\n\t\tthis.__mapKeysData__.splice(index, 1);\n\t\tthis.__mapValuesData__.splice(index, 1);\n\t\tthis.emit('_delete', index, key);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result;\n\t\tcallable(cb);\n\t\titerator = this.entries();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tcall.call(cb, thisArg, this.__mapValuesData__[result],\n\t\t\t\tthis.__mapKeysData__[result], this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\tget: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return;\n\t\treturn this.__mapValuesData__[index];\n\t}),\n\thas: d(function (key) {\n\t\treturn (eIndexOf.call(this.__mapKeysData__, key) !== -1);\n\t}),\n\tkeys: d(function () { return new Iterator(this, 'key'); }),\n\tset: d(function (key, value) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key), emit;\n\t\tif (index === -1) {\n\t\t\tindex = this.__mapKeysData__.push(key) - 1;\n\t\t\temit = true;\n\t\t}\n\t\tthis.__mapValuesData__[index] = value;\n\t\tif (emit) this.emit('_add', index, key);\n\t\treturn this;\n\t}),\n\tsize: d.gs(function () { return this.__mapKeysData__.length; }),\n\tvalues: d(function () { return new Iterator(this, 'value'); }),\n\ttoString: d(function () { return '[object Map]'; })\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {\n\treturn this.entries();\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/polyfill.js\n ** module id = 110\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/polyfill.js?");

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar toPosInt = __webpack_require__(112)\n  , value    = __webpack_require__(67)\n\n  , indexOf = Array.prototype.indexOf\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , abs = Math.abs, floor = Math.floor;\n\nmodule.exports = function (searchElement/*, fromIndex*/) {\n\tvar i, l, fromIndex, val;\n\tif (searchElement === searchElement) { //jslint: ignore\n\t\treturn indexOf.apply(this, arguments);\n\t}\n\n\tl = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < l; ++i) {\n\t\tif (hasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (val !== val) return i; //jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/array/#/e-index-of.js\n ** module id = 111\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/array/#/e-index-of.js?");

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar toInteger = __webpack_require__(113)\n\n  , max = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/number/to-pos-integer.js\n ** module id = 112\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/number/to-pos-integer.js?");

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar sign = __webpack_require__(114)\n\n  , abs = Math.abs, floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif ((value === 0) || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/number/to-integer.js\n ** module id = 113\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/number/to-integer.js?");

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(115)()\n\t? Math.sign\n\t: __webpack_require__(116);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/math/sign/index.js\n ** module id = 114\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/math/sign/index.js?");

/***/ },
/* 115 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== 'function') return false;\n\treturn ((sign(10) === 1) && (sign(-20) === -1));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/math/sign/is-implemented.js\n ** module id = 115\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/math/sign/is-implemented.js?");

/***/ },
/* 116 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || (value === 0)) return value;\n\treturn (value > 0) ? 1 : -1;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/math/sign/shim.js\n ** module id = 116\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/math/sign/shim.js?");

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar d        = __webpack_require__(71)\n  , callable = __webpack_require__(89)\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/index.js\n ** module id = 117\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/event-emitter/index.js?");

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar setPrototypeOf    = __webpack_require__(63)\n  , d                 = __webpack_require__(71)\n  , Iterator          = __webpack_require__(87)\n  , toStringTagSymbol = __webpack_require__(95).toStringTag\n  , kinds             = __webpack_require__(119)\n\n  , defineProperties = Object.defineProperties\n  , unBind = Iterator.prototype._unBind\n  , MapIterator;\n\nMapIterator = module.exports = function (map, kind) {\n\tif (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n\tIterator.call(this, map.__mapKeysData__, map);\n\tif (!kind || !kinds[kind]) kind = 'key+value';\n\tdefineProperties(this, {\n\t\t__kind__: d('', kind),\n\t\t__values__: d('w', map.__mapValuesData__)\n\t});\n};\nif (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\nMapIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(MapIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__values__[i];\n\t\tif (this.__kind__ === 'key') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__values__[i]];\n\t}),\n\t_unBind: d(function () {\n\t\tthis.__values__ = null;\n\t\tunBind.call(this);\n\t}),\n\ttoString: d(function () { return '[object Map Iterator]'; })\n});\nObject.defineProperty(MapIterator.prototype, toStringTagSymbol,\n\td('c', 'Map Iterator'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/lib/iterator.js\n ** module id = 118\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/lib/iterator.js?");

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(120)('key',\n\t'value', 'key+value');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/lib/iterator-kinds.js\n ** module id = 119\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/lib/iterator-kinds.js?");

/***/ },
/* 120 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nmodule.exports = function (arg/*, …args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) { set[name] = true; });\n\treturn set;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es5-ext/object/primitive-set.js\n ** module id = 120\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es5-ext/object/primitive-set.js?");

/***/ },
/* 121 */
/***/ function(module, exports) {

	eval("// Exports true if environment provides native `Map` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Map === 'undefined') return false;\n\treturn (Object.prototype.toString.call(new Map()) === '[object Map]');\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-map/is-native-implemented.js\n ** module id = 121\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/es6-map/is-native-implemented.js?");

/***/ },
/* 122 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar READ = 1;\nvar WRITE = 2;\nvar RW = READ | WRITE;\n\n/**\n * A Reference represents a single occurrence of an identifier in code.\n * @class Reference\n */\n\nvar Reference = (function () {\n  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {\n    _classCallCheck(this, Reference);\n\n    /**\n     * Identifier syntax node.\n     * @member {esprima#Identifier} Reference#identifier\n     */\n    this.identifier = ident;\n    /**\n     * Reference to the enclosing Scope.\n     * @member {Scope} Reference#from\n     */\n    this.from = scope;\n    /**\n     * Whether the reference comes from a dynamic scope (such as 'eval',\n     * 'with', etc.), and may be trapped by dynamic scopes.\n     * @member {boolean} Reference#tainted\n     */\n    this.tainted = false;\n    /**\n     * The variable this reference is resolved with.\n     * @member {Variable} Reference#resolved\n     */\n    this.resolved = null;\n    /**\n     * The read-write mode of the reference. (Value is one of {@link\n     * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).\n     * @member {number} Reference#flag\n     * @private\n     */\n    this.flag = flag;\n    if (this.isWrite()) {\n      /**\n       * If reference is writeable, this is the tree being written to it.\n       * @member {esprima#Node} Reference#writeExpr\n       */\n      this.writeExpr = writeExpr;\n      /**\n       * Whether the Reference might refer to a partial value of writeExpr.\n       * @member {boolean} Reference#partial\n       */\n      this.partial = partial;\n      /**\n       * Whether the Reference is to write of initialization.\n       * @member {boolean} Reference#init\n       */\n      this.init = init;\n    }\n    this.__maybeImplicitGlobal = maybeImplicitGlobal;\n  }\n\n  _createClass(Reference, {\n    isStatic: {\n\n      /**\n       * Whether the reference is static.\n       * @method Reference#isStatic\n       * @return {boolean}\n       */\n\n      value: function isStatic() {\n        return !this.tainted && this.resolved && this.resolved.scope.isStatic();\n      }\n    },\n    isWrite: {\n\n      /**\n       * Whether the reference is writeable.\n       * @method Reference#isWrite\n       * @return {boolean}\n       */\n\n      value: function isWrite() {\n        return !!(this.flag & Reference.WRITE);\n      }\n    },\n    isRead: {\n\n      /**\n       * Whether the reference is readable.\n       * @method Reference#isRead\n       * @return {boolean}\n       */\n\n      value: function isRead() {\n        return !!(this.flag & Reference.READ);\n      }\n    },\n    isReadOnly: {\n\n      /**\n       * Whether the reference is read-only.\n       * @method Reference#isReadOnly\n       * @return {boolean}\n       */\n\n      value: function isReadOnly() {\n        return this.flag === Reference.READ;\n      }\n    },\n    isWriteOnly: {\n\n      /**\n       * Whether the reference is write-only.\n       * @method Reference#isWriteOnly\n       * @return {boolean}\n       */\n\n      value: function isWriteOnly() {\n        return this.flag === Reference.WRITE;\n      }\n    },\n    isReadWrite: {\n\n      /**\n       * Whether the reference is read-write.\n       * @method Reference#isReadWrite\n       * @return {boolean}\n       */\n\n      value: function isReadWrite() {\n        return this.flag === Reference.RW;\n      }\n    }\n  });\n\n  return Reference;\n})();\n\nmodule.exports = Reference;\n\n/**\n * @constant Reference.READ\n * @private\n */\nReference.READ = READ;\n/**\n * @constant Reference.WRITE\n * @private\n */\nReference.WRITE = WRITE;\n/**\n * @constant Reference.RW\n * @private\n */\nReference.RW = RW;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZmVyZW5jZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsSUFBTSxJQUFJLEdBQUcsQ0FBRyxDQUFDO0FBQ2pCLElBQU0sS0FBSyxHQUFHLENBQUcsQ0FBQztBQUNsQixJQUFNLEVBQUUsR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0lBTUgsU0FBUztBQUNmLFdBRE0sU0FBUyxDQUNkLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFHLFNBQVMsRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFOzBCQUQvRCxTQUFTOzs7Ozs7QUFNdEIsUUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7Ozs7O0FBS3hCLFFBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDOzs7Ozs7QUFNbEIsUUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7Ozs7O0FBS3JCLFFBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDOzs7Ozs7O0FBT3JCLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFOzs7OztBQUtoQixVQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzs7Ozs7QUFLM0IsVUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Ozs7O0FBS3ZCLFVBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ3BCO0FBQ0QsUUFBSSxDQUFDLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDO0dBQ3BEOztlQWhEZ0IsU0FBUztBQXVEMUIsWUFBUTs7Ozs7Ozs7YUFBQSxvQkFBRztBQUNQLGVBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7T0FDM0U7O0FBT0QsV0FBTzs7Ozs7Ozs7YUFBQSxtQkFBRztBQUNOLGVBQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQSxBQUFDLENBQUM7T0FDMUM7O0FBT0QsVUFBTTs7Ozs7Ozs7YUFBQSxrQkFBRztBQUNMLGVBQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQSxBQUFDLENBQUM7T0FDekM7O0FBT0QsY0FBVTs7Ozs7Ozs7YUFBQSxzQkFBRztBQUNULGVBQU8sSUFBSSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDO09BQ3ZDOztBQU9ELGVBQVc7Ozs7Ozs7O2FBQUEsdUJBQUc7QUFDVixlQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLEtBQUssQ0FBQztPQUN4Qzs7QUFPRCxlQUFXOzs7Ozs7OzthQUFBLHVCQUFHO0FBQ1YsZUFBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxFQUFFLENBQUM7T0FDckM7Ozs7U0F0R2dCLFNBQVM7OztpQkFBVCxTQUFTOzs7Ozs7QUE2RzlCLFNBQVMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7OztBQUt0QixTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7Ozs7QUFLeEIsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMiLCJmaWxlIjoicmVmZXJlbmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5jb25zdCBSRUFEID0gMHgxO1xuY29uc3QgV1JJVEUgPSAweDI7XG5jb25zdCBSVyA9IFJFQUQgfCBXUklURTtcblxuLyoqXG4gKiBBIFJlZmVyZW5jZSByZXByZXNlbnRzIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYW4gaWRlbnRpZmllciBpbiBjb2RlLlxuICogQGNsYXNzIFJlZmVyZW5jZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkZW50LCBzY29wZSwgZmxhZywgIHdyaXRlRXhwciwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgcGFydGlhbCwgaW5pdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBzeW50YXggbm9kZS5cbiAgICAgICAgICogQG1lbWJlciB7ZXNwcmltYSNJZGVudGlmaWVyfSBSZWZlcmVuY2UjaWRlbnRpZmllclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGVuY2xvc2luZyBTY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGV9IFJlZmVyZW5jZSNmcm9tXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZyb20gPSBzY29wZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBjb21lcyBmcm9tIGEgZHluYW1pYyBzY29wZSAoc3VjaCBhcyAnZXZhbCcsXG4gICAgICAgICAqICd3aXRoJywgZXRjLiksIGFuZCBtYXkgYmUgdHJhcHBlZCBieSBkeW5hbWljIHNjb3Blcy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI3RhaW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhYmxlIHRoaXMgcmVmZXJlbmNlIGlzIHJlc29sdmVkIHdpdGguXG4gICAgICAgICAqIEBtZW1iZXIge1ZhcmlhYmxlfSBSZWZlcmVuY2UjcmVzb2x2ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYWQtd3JpdGUgbW9kZSBvZiB0aGUgcmVmZXJlbmNlLiAoVmFsdWUgaXMgb25lIG9mIHtAbGlua1xuICAgICAgICAgKiBSZWZlcmVuY2UuUkVBRH0sIHtAbGluayBSZWZlcmVuY2UuUld9LCB7QGxpbmsgUmVmZXJlbmNlLldSSVRFfSkuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gUmVmZXJlbmNlI2ZsYWdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZyA9IGZsYWc7XG4gICAgICAgIGlmICh0aGlzLmlzV3JpdGUoKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiByZWZlcmVuY2UgaXMgd3JpdGVhYmxlLCB0aGlzIGlzIHRoZSB0cmVlIGJlaW5nIHdyaXR0ZW4gdG8gaXQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hI05vZGV9IFJlZmVyZW5jZSN3cml0ZUV4cHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy53cml0ZUV4cHIgPSB3cml0ZUV4cHI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIFJlZmVyZW5jZSBtaWdodCByZWZlciB0byBhIHBhcnRpYWwgdmFsdWUgb2Ygd3JpdGVFeHByLlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI3BhcnRpYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgUmVmZXJlbmNlIGlzIHRvIHdyaXRlIG9mIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI2luaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG1heWJlSW1wbGljaXRHbG9iYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHN0YXRpYy5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1N0YXRpY1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdGF0aWMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy50YWludGVkICYmIHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5yZXNvbHZlZC5zY29wZS5pc1N0YXRpYygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBpcyB3cml0ZWFibGUuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNXcml0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNXcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZyAmIFJlZmVyZW5jZS5XUklURSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHJlYWRhYmxlLlxuICAgICAqIEBtZXRob2QgUmVmZXJlbmNlI2lzUmVhZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWFkKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5mbGFnICYgUmVmZXJlbmNlLlJFQUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBpcyByZWFkLW9ubHkuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNSZWFkT25seVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWFkT25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZyA9PT0gUmVmZXJlbmNlLlJFQUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHdyaXRlLW9ubHkuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNXcml0ZU9ubHlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzV3JpdGVPbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID09PSBSZWZlcmVuY2UuV1JJVEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHJlYWQtd3JpdGUuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNSZWFkV3JpdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVhZFdyaXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID09PSBSZWZlcmVuY2UuUlc7XG4gICAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCBSZWZlcmVuY2UuUkVBRFxuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLlJFQUQgPSBSRUFEO1xuLyoqXG4gKiBAY29uc3RhbnQgUmVmZXJlbmNlLldSSVRFXG4gKiBAcHJpdmF0ZVxuICovXG5SZWZlcmVuY2UuV1JJVEUgPSBXUklURTtcbi8qKlxuICogQGNvbnN0YW50IFJlZmVyZW5jZS5SV1xuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLlJXID0gUlc7XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/reference.js\n ** module id = 122\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/reference.js?");

/***/ },
/* 123 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * A Variable represents a locally scoped identifier. These include arguments to\n * functions.\n * @class Variable\n */\n\nvar Variable = function Variable(name, scope) {\n  _classCallCheck(this, Variable);\n\n  /**\n   * The variable name, as given in the source code.\n   * @member {String} Variable#name\n   */\n  this.name = name;\n  /**\n   * List of defining occurrences of this variable (like in 'var ...'\n   * statements or as parameter), as AST nodes.\n   * @member {esprima.Identifier[]} Variable#identifiers\n   */\n  this.identifiers = [];\n  /**\n   * List of {@link Reference|references} of this variable (excluding parameter entries)\n   * in its defining scope and all nested scopes. For defining\n   * occurrences only see {@link Variable#defs}.\n   * @member {Reference[]} Variable#references\n   */\n  this.references = [];\n\n  /**\n   * List of defining occurrences of this variable (like in 'var ...'\n   * statements or as parameter), as custom objects.\n   * @member {Definition[]} Variable#defs\n   */\n  this.defs = [];\n\n  this.tainted = false;\n  /**\n   * Whether this is a stack variable.\n   * @member {boolean} Variable#stack\n   */\n  this.stack = true;\n  /**\n   * Reference to the enclosing Scope.\n   * @member {Scope} Variable#scope\n   */\n  this.scope = scope;\n};\n\nmodule.exports = Variable;\n\nVariable.CatchClause = \"CatchClause\";\nVariable.Parameter = \"Parameter\";\nVariable.FunctionName = \"FunctionName\";\nVariable.ClassName = \"ClassName\";\nVariable.Variable = \"Variable\";\nVariable.ImportBinding = \"ImportBinding\";\nVariable.TDZ = \"TDZ\";\nVariable.ImplicitGlobalVariable = \"ImplicitGlobalVariable\";\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZhcmlhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE2QnFCLFFBQVEsR0FDZCxTQURNLFFBQVEsQ0FDYixJQUFJLEVBQUUsS0FBSyxFQUFFO3dCQURSLFFBQVE7Ozs7OztBQU1yQixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7Ozs7O0FBTWpCLE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0FBT3RCLE1BQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0FBT3JCLE1BQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDOztBQUVmLE1BQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDOzs7OztBQUtyQixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7Ozs7QUFLbEIsTUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Q0FDdEI7O2lCQXZDZ0IsUUFBUTs7QUEwQzdCLFFBQVEsQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDO0FBQ3JDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDO0FBQ2pDLFFBQVEsQ0FBQyxZQUFZLEdBQUcsY0FBYyxDQUFDO0FBQ3ZDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDO0FBQ2pDLFFBQVEsQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO0FBQy9CLFFBQVEsQ0FBQyxhQUFhLEdBQUcsZUFBZSxDQUFDO0FBQ3pDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLFFBQVEsQ0FBQyxzQkFBc0IsR0FBRyx3QkFBd0IsQ0FBQyIsImZpbGUiOiJ2YXJpYWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLyoqXG4gKiBBIFZhcmlhYmxlIHJlcHJlc2VudHMgYSBsb2NhbGx5IHNjb3BlZCBpZGVudGlmaWVyLiBUaGVzZSBpbmNsdWRlIGFyZ3VtZW50cyB0b1xuICogZnVuY3Rpb25zLlxuICogQGNsYXNzIFZhcmlhYmxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY29wZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhYmxlIG5hbWUsIGFzIGdpdmVuIGluIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBWYXJpYWJsZSNuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBkZWZpbmluZyBvY2N1cnJlbmNlcyBvZiB0aGlzIHZhcmlhYmxlIChsaWtlIGluICd2YXIgLi4uJ1xuICAgICAgICAgKiBzdGF0ZW1lbnRzIG9yIGFzIHBhcmFtZXRlciksIGFzIEFTVCBub2Rlcy5cbiAgICAgICAgICogQG1lbWJlciB7ZXNwcmltYS5JZGVudGlmaWVyW119IFZhcmlhYmxlI2lkZW50aWZpZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkZW50aWZpZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlc30gb2YgdGhpcyB2YXJpYWJsZSAoZXhjbHVkaW5nIHBhcmFtZXRlciBlbnRyaWVzKVxuICAgICAgICAgKiBpbiBpdHMgZGVmaW5pbmcgc2NvcGUgYW5kIGFsbCBuZXN0ZWQgc2NvcGVzLiBGb3IgZGVmaW5pbmdcbiAgICAgICAgICogb2NjdXJyZW5jZXMgb25seSBzZWUge0BsaW5rIFZhcmlhYmxlI2RlZnN9LlxuICAgICAgICAgKiBAbWVtYmVyIHtSZWZlcmVuY2VbXX0gVmFyaWFibGUjcmVmZXJlbmNlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgZGVmaW5pbmcgb2NjdXJyZW5jZXMgb2YgdGhpcyB2YXJpYWJsZSAobGlrZSBpbiAndmFyIC4uLidcbiAgICAgICAgICogc3RhdGVtZW50cyBvciBhcyBwYXJhbWV0ZXIpLCBhcyBjdXN0b20gb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7RGVmaW5pdGlvbltdfSBWYXJpYWJsZSNkZWZzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZnMgPSBbXTtcblxuICAgICAgICB0aGlzLnRhaW50ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIHN0YWNrIHZhcmlhYmxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBWYXJpYWJsZSNzdGFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGVuY2xvc2luZyBTY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGV9IFZhcmlhYmxlI3Njb3BlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxufVxuXG5WYXJpYWJsZS5DYXRjaENsYXVzZSA9ICdDYXRjaENsYXVzZSc7XG5WYXJpYWJsZS5QYXJhbWV0ZXIgPSAnUGFyYW1ldGVyJztcblZhcmlhYmxlLkZ1bmN0aW9uTmFtZSA9ICdGdW5jdGlvbk5hbWUnO1xuVmFyaWFibGUuQ2xhc3NOYW1lID0gJ0NsYXNzTmFtZSc7XG5WYXJpYWJsZS5WYXJpYWJsZSA9ICdWYXJpYWJsZSc7XG5WYXJpYWJsZS5JbXBvcnRCaW5kaW5nID0gJ0ltcG9ydEJpbmRpbmcnO1xuVmFyaWFibGUuVERaID0gJ1REWic7XG5WYXJpYWJsZS5JbXBsaWNpdEdsb2JhbFZhcmlhYmxlID0gJ0ltcGxpY2l0R2xvYmFsVmFyaWFibGUnO1xuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/variable.js\n ** module id = 123\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/variable.js?");

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar Variable = _interopRequire(__webpack_require__(123));\n\n/**\n * @class Definition\n */\n\nvar Definition = function Definition(type, name, node, parent, index, kind) {\n  _classCallCheck(this, Definition);\n\n  /**\n   * @member {String} Definition#type - type of the occurrence (e.g. \"Parameter\", \"Variable\", ...).\n   */\n  this.type = type;\n  /**\n   * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.\n   */\n  this.name = name;\n  /**\n   * @member {esprima.Node} Definition#node - the enclosing node of the identifier.\n   */\n  this.node = node;\n  /**\n   * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.\n   */\n  this.parent = parent;\n  /**\n   * @member {Number?} Definition#index - the index in the declaration statement.\n   */\n  this.index = index;\n  /**\n   * @member {String?} Definition#kind - the kind of the declaration statement.\n   */\n  this.kind = kind;\n};\n\nexports[\"default\"] = Definition;\n\n/**\n * @class ParameterDefinition\n */\n\nvar ParameterDefinition = (function (_Definition) {\n  function ParameterDefinition(name, node, index, rest) {\n    _classCallCheck(this, ParameterDefinition);\n\n    _get(Object.getPrototypeOf(ParameterDefinition.prototype), \"constructor\", this).call(this, Variable.Parameter, name, node, null, index, null);\n    /**\n     * Whether the parameter definition is a part of a rest parameter.\n     * @member {boolean} ParameterDefinition#rest\n     */\n    this.rest = rest;\n  }\n\n  _inherits(ParameterDefinition, _Definition);\n\n  return ParameterDefinition;\n})(Definition);\n\nexports.ParameterDefinition = ParameterDefinition;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\nexports.Definition = Definition;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlZmluaXRpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdCTyxRQUFRLDJCQUFNLFlBQVk7Ozs7OztJQUtaLFVBQVUsR0FDaEIsU0FETSxVQUFVLENBQ2YsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7d0JBRGxDLFVBQVU7Ozs7O0FBS3ZCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7O0FBSWpCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7O0FBSWpCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7O0FBSWpCLE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOzs7O0FBSXJCLE1BQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOzs7O0FBSW5CLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0NBQ3BCOztxQkExQmdCLFVBQVU7Ozs7OztJQWdDekIsbUJBQW1CO0FBQ1YsV0FEVCxtQkFBbUIsQ0FDVCxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7MEJBRG5DLG1CQUFtQjs7QUFFakIsK0JBRkYsbUJBQW1CLDZDQUVYLFFBQVEsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTs7Ozs7QUFLekQsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7R0FDcEI7O1lBUkMsbUJBQW1COztTQUFuQixtQkFBbUI7R0FBUyxVQUFVOztRQVl4QyxtQkFBbUIsR0FBbkIsbUJBQW1COzs7UUFDbkIsVUFBVSxHQUFWLFVBQVUiLCJmaWxlIjoiZGVmaW5pdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IFZhcmlhYmxlIGZyb20gJy4vdmFyaWFibGUnO1xuXG4vKipcbiAqIEBjbGFzcyBEZWZpbml0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hbWUsIG5vZGUsIHBhcmVudCwgaW5kZXgsIGtpbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gRGVmaW5pdGlvbiN0eXBlIC0gdHlwZSBvZiB0aGUgb2NjdXJyZW5jZSAoZS5nLiBcIlBhcmFtZXRlclwiLCBcIlZhcmlhYmxlXCIsIC4uLikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7ZXNwcmltYS5JZGVudGlmaWVyfSBEZWZpbml0aW9uI25hbWUgLSB0aGUgaWRlbnRpZmllciBBU1Qgbm9kZSBvZiB0aGUgb2NjdXJyZW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hLk5vZGV9IERlZmluaXRpb24jbm9kZSAtIHRoZSBlbmNsb3Npbmcgbm9kZSBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hLk5vZGU/fSBEZWZpbml0aW9uI3BhcmVudCAtIHRoZSBlbmNsb3Npbmcgc3RhdGVtZW50IG5vZGUgb2YgdGhlIGlkZW50aWZpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcj99IERlZmluaXRpb24jaW5kZXggLSB0aGUgaW5kZXggaW4gdGhlIGRlY2xhcmF0aW9uIHN0YXRlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZz99IERlZmluaXRpb24ja2luZCAtIHRoZSBraW5kIG9mIHRoZSBkZWNsYXJhdGlvbiBzdGF0ZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgUGFyYW1ldGVyRGVmaW5pdGlvblxuICovXG5jbGFzcyBQYXJhbWV0ZXJEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSwgaW5kZXgsIHJlc3QpIHtcbiAgICAgICAgc3VwZXIoVmFyaWFibGUuUGFyYW1ldGVyLCBuYW1lLCBub2RlLCBudWxsLCBpbmRleCwgbnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBwYXJhbWV0ZXIgZGVmaW5pdGlvbiBpcyBhIHBhcnQgb2YgYSByZXN0IHBhcmFtZXRlci5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUGFyYW1ldGVyRGVmaW5pdGlvbiNyZXN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBQYXJhbWV0ZXJEZWZpbml0aW9uLFxuICAgIERlZmluaXRpb25cbn1cblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/definition.js\n ** module id = 124\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/definition.js?");

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar Syntax = __webpack_require__(106).Syntax;\n\nvar esrecurse = _interopRequire(__webpack_require__(126));\n\nvar Reference = _interopRequire(__webpack_require__(122));\n\nvar Variable = _interopRequire(__webpack_require__(123));\n\nvar PatternVisitor = _interopRequire(__webpack_require__(130));\n\nvar _definition = __webpack_require__(124);\n\nvar ParameterDefinition = _definition.ParameterDefinition;\nvar Definition = _definition.Definition;\n\nvar assert = _interopRequire(__webpack_require__(55));\n\nfunction traverseIdentifierInPattern(rootPattern, referencer, callback) {\n    // Call the callback at left hand identifier nodes, and Collect right hand nodes.\n    var visitor = new PatternVisitor(rootPattern, callback);\n    visitor.visit(rootPattern);\n\n    // Process the right hand nodes recursively.\n    if (referencer != null) {\n        visitor.rightHandNodes.forEach(referencer.visit, referencer);\n    }\n}\n\n// Importing ImportDeclaration.\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation\n// https://github.com/estree/estree/blob/master/es6.md#importdeclaration\n// FIXME: Now, we don't create module environment, because the context is\n// implementation dependent.\n\nvar Importer = (function (_esrecurse$Visitor) {\n    function Importer(declaration, referencer) {\n        _classCallCheck(this, Importer);\n\n        _get(Object.getPrototypeOf(Importer.prototype), \"constructor\", this).call(this);\n        this.declaration = declaration;\n        this.referencer = referencer;\n    }\n\n    _inherits(Importer, _esrecurse$Visitor);\n\n    _createClass(Importer, {\n        visitImport: {\n            value: function visitImport(id, specifier) {\n                var _this = this;\n\n                this.referencer.visitPattern(id, function (pattern) {\n                    _this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, _this.declaration, null, null));\n                });\n            }\n        },\n        ImportNamespaceSpecifier: {\n            value: function ImportNamespaceSpecifier(node) {\n                var local = node.local || node.id;\n                if (local) {\n                    this.visitImport(local, node);\n                }\n            }\n        },\n        ImportDefaultSpecifier: {\n            value: function ImportDefaultSpecifier(node) {\n                var local = node.local || node.id;\n                this.visitImport(local, node);\n            }\n        },\n        ImportSpecifier: {\n            value: function ImportSpecifier(node) {\n                var local = node.local || node.id;\n                if (node.name) {\n                    this.visitImport(node.name, node);\n                } else {\n                    this.visitImport(local, node);\n                }\n            }\n        }\n    });\n\n    return Importer;\n})(esrecurse.Visitor);\n\n// Referencing variables and creating bindings.\n\nvar Referencer = (function (_esrecurse$Visitor2) {\n    function Referencer(scopeManager) {\n        _classCallCheck(this, Referencer);\n\n        _get(Object.getPrototypeOf(Referencer.prototype), \"constructor\", this).call(this);\n        this.scopeManager = scopeManager;\n        this.parent = null;\n        this.isInnerMethodDefinition = false;\n    }\n\n    _inherits(Referencer, _esrecurse$Visitor2);\n\n    _createClass(Referencer, {\n        currentScope: {\n            value: function currentScope() {\n                return this.scopeManager.__currentScope;\n            }\n        },\n        close: {\n            value: function close(node) {\n                while (this.currentScope() && node === this.currentScope().block) {\n                    this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);\n                }\n            }\n        },\n        pushInnerMethodDefinition: {\n            value: function pushInnerMethodDefinition(isInnerMethodDefinition) {\n                var previous = this.isInnerMethodDefinition;\n                this.isInnerMethodDefinition = isInnerMethodDefinition;\n                return previous;\n            }\n        },\n        popInnerMethodDefinition: {\n            value: function popInnerMethodDefinition(isInnerMethodDefinition) {\n                this.isInnerMethodDefinition = isInnerMethodDefinition;\n            }\n        },\n        materializeTDZScope: {\n            value: function materializeTDZScope(node, iterationNode) {\n                // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation\n                // TDZ scope hides the declaration's names.\n                this.scopeManager.__nestTDZScope(node, iterationNode);\n                this.visitVariableDeclaration(this.currentScope(), Variable.TDZ, iterationNode.left, 0, true);\n            }\n        },\n        materializeIterationScope: {\n            value: function materializeIterationScope(node) {\n                var _this = this;\n\n                // Generate iteration scope for upper ForIn/ForOf Statements.\n                var letOrConstDecl;\n                this.scopeManager.__nestForScope(node);\n                letOrConstDecl = node.left;\n                this.visitVariableDeclaration(this.currentScope(), Variable.Variable, letOrConstDecl, 0);\n                this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {\n                    _this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);\n                });\n            }\n        },\n        referencingDefaultValue: {\n            value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n                var scope = this.currentScope();\n                assignments.forEach(function (assignment) {\n                    scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);\n                });\n            }\n        },\n        visitPattern: {\n            value: function visitPattern(node, options, callback) {\n                if (typeof options === \"function\") {\n                    callback = options;\n                    options = { processRightHandNodes: false };\n                }\n                traverseIdentifierInPattern(node, options.processRightHandNodes ? this : null, callback);\n            }\n        },\n        visitFunction: {\n            value: function visitFunction(node) {\n                var _this = this;\n\n                var i, iz;\n                // FunctionDeclaration name is defined in upper scope\n                // NOTE: Not referring variableScope. It is intended.\n                // Since\n                //  in ES5, FunctionDeclaration should be in FunctionBody.\n                //  in ES6, FunctionDeclaration should be block scoped.\n                if (node.type === Syntax.FunctionDeclaration) {\n                    // id is defined in upper scope\n                    this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));\n                }\n\n                // FunctionExpression with name creates its special scope;\n                // FunctionExpressionNameScope.\n                if (node.type === Syntax.FunctionExpression && node.id) {\n                    this.scopeManager.__nestFunctionExpressionNameScope(node);\n                }\n\n                // Consider this function is in the MethodDefinition.\n                this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);\n\n                // Process parameter declarations.\n                for (i = 0, iz = node.params.length; i < iz; ++i) {\n                    this.visitPattern(node.params[i], { processRightHandNodes: true }, function (pattern, info) {\n                        _this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));\n\n                        _this.referencingDefaultValue(pattern, info.assignments, null, true);\n                    });\n                }\n\n                // if there's a rest argument, add that\n                if (node.rest) {\n                    this.visitPattern({\n                        type: \"RestElement\",\n                        argument: node.rest\n                    }, function (pattern) {\n                        _this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));\n                    });\n                }\n\n                // Skip BlockStatement to prevent creating BlockStatement scope.\n                if (node.body.type === Syntax.BlockStatement) {\n                    this.visitChildren(node.body);\n                } else {\n                    this.visit(node.body);\n                }\n\n                this.close(node);\n            }\n        },\n        visitClass: {\n            value: function visitClass(node) {\n                if (node.type === Syntax.ClassDeclaration) {\n                    this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));\n                }\n\n                // FIXME: Maybe consider TDZ.\n                this.visit(node.superClass);\n\n                this.scopeManager.__nestClassScope(node);\n\n                if (node.id) {\n                    this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));\n                }\n                this.visit(node.body);\n\n                this.close(node);\n            }\n        },\n        visitProperty: {\n            value: function visitProperty(node) {\n                var previous, isMethodDefinition;\n                if (node.computed) {\n                    this.visit(node.key);\n                }\n\n                isMethodDefinition = node.type === Syntax.MethodDefinition;\n                if (isMethodDefinition) {\n                    previous = this.pushInnerMethodDefinition(true);\n                }\n                this.visit(node.value);\n                if (isMethodDefinition) {\n                    this.popInnerMethodDefinition(previous);\n                }\n            }\n        },\n        visitForIn: {\n            value: function visitForIn(node) {\n                var _this = this;\n\n                if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== \"var\") {\n                    this.materializeTDZScope(node.right, node);\n                    this.visit(node.right);\n                    this.close(node.right);\n\n                    this.materializeIterationScope(node);\n                    this.visit(node.body);\n                    this.close(node);\n                } else {\n                    if (node.left.type === Syntax.VariableDeclaration) {\n                        this.visit(node.left);\n                        this.visitPattern(node.left.declarations[0].id, function (pattern) {\n                            _this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);\n                        });\n                    } else {\n                        this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {\n                            var maybeImplicitGlobal = null;\n                            if (!_this.currentScope().isStrict) {\n                                maybeImplicitGlobal = {\n                                    pattern: pattern,\n                                    node: node\n                                };\n                            }\n                            _this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                            _this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);\n                        });\n                    }\n                    this.visit(node.right);\n                    this.visit(node.body);\n                }\n            }\n        },\n        visitVariableDeclaration: {\n            value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {\n                var _this = this;\n\n                // If this was called to initialize a TDZ scope, this needs to make definitions, but doesn't make references.\n                var decl, init;\n\n                decl = node.declarations[index];\n                init = decl.init;\n                this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {\n                    variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));\n\n                    if (!fromTDZ) {\n                        _this.referencingDefaultValue(pattern, info.assignments, null, true);\n                    }\n                    if (init) {\n                        _this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);\n                    }\n                });\n            }\n        },\n        AssignmentExpression: {\n            value: function AssignmentExpression(node) {\n                var _this = this;\n\n                if (PatternVisitor.isPattern(node.left)) {\n                    if (node.operator === \"=\") {\n                        this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {\n                            var maybeImplicitGlobal = null;\n                            if (!_this.currentScope().isStrict) {\n                                maybeImplicitGlobal = {\n                                    pattern: pattern,\n                                    node: node\n                                };\n                            }\n                            _this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                            _this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);\n                        });\n                    } else {\n                        this.currentScope().__referencing(node.left, Reference.RW, node.right);\n                    }\n                } else {\n                    this.visit(node.left);\n                }\n                this.visit(node.right);\n            }\n        },\n        CatchClause: {\n            value: function CatchClause(node) {\n                var _this = this;\n\n                this.scopeManager.__nestCatchScope(node);\n\n                this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {\n                    _this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));\n                    _this.referencingDefaultValue(pattern, info.assignments, null, true);\n                });\n                this.visit(node.body);\n\n                this.close(node);\n            }\n        },\n        Program: {\n            value: function Program(node) {\n                this.scopeManager.__nestGlobalScope(node);\n\n                if (this.scopeManager.__isNodejsScope()) {\n                    // Force strictness of GlobalScope to false when using node.js scope.\n                    this.currentScope().isStrict = false;\n                    this.scopeManager.__nestFunctionScope(node, false);\n                }\n\n                if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {\n                    this.scopeManager.__nestModuleScope(node);\n                }\n\n                this.visitChildren(node);\n                this.close(node);\n            }\n        },\n        Identifier: {\n            value: function Identifier(node) {\n                this.currentScope().__referencing(node);\n            }\n        },\n        UpdateExpression: {\n            value: function UpdateExpression(node) {\n                if (PatternVisitor.isPattern(node.argument)) {\n                    this.currentScope().__referencing(node.argument, Reference.RW, null);\n                } else {\n                    this.visitChildren(node);\n                }\n            }\n        },\n        MemberExpression: {\n            value: function MemberExpression(node) {\n                this.visit(node.object);\n                if (node.computed) {\n                    this.visit(node.property);\n                }\n            }\n        },\n        Property: {\n            value: function Property(node) {\n                this.visitProperty(node);\n            }\n        },\n        MethodDefinition: {\n            value: function MethodDefinition(node) {\n                this.visitProperty(node);\n            }\n        },\n        BreakStatement: {\n            value: function BreakStatement() {}\n        },\n        ContinueStatement: {\n            value: function ContinueStatement() {}\n        },\n        LabeledStatement: {\n            value: function LabeledStatement(node) {\n                this.visit(node.body);\n            }\n        },\n        ForStatement: {\n            value: function ForStatement(node) {\n                // Create ForStatement declaration.\n                // NOTE: In ES6, ForStatement dynamically generates\n                // per iteration environment. However, escope is\n                // a static analyzer, we only generate one scope for ForStatement.\n                if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== \"var\") {\n                    this.scopeManager.__nestForScope(node);\n                }\n\n                this.visitChildren(node);\n\n                this.close(node);\n            }\n        },\n        ClassExpression: {\n            value: function ClassExpression(node) {\n                this.visitClass(node);\n            }\n        },\n        ClassDeclaration: {\n            value: function ClassDeclaration(node) {\n                this.visitClass(node);\n            }\n        },\n        CallExpression: {\n            value: function CallExpression(node) {\n                // Check this is direct call to eval\n                if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === \"eval\") {\n                    // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and\n                    // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.\n                    this.currentScope().variableScope.__detectEval();\n                }\n                this.visitChildren(node);\n            }\n        },\n        BlockStatement: {\n            value: function BlockStatement(node) {\n                if (this.scopeManager.__isES6()) {\n                    this.scopeManager.__nestBlockScope(node);\n                }\n\n                this.visitChildren(node);\n\n                this.close(node);\n            }\n        },\n        ThisExpression: {\n            value: function ThisExpression() {\n                this.currentScope().variableScope.__detectThis();\n            }\n        },\n        WithStatement: {\n            value: function WithStatement(node) {\n                this.visit(node.object);\n                // Then nest scope for WithStatement.\n                this.scopeManager.__nestWithScope(node);\n\n                this.visit(node.body);\n\n                this.close(node);\n            }\n        },\n        VariableDeclaration: {\n            value: function VariableDeclaration(node) {\n                var variableTargetScope, i, iz, decl;\n                variableTargetScope = node.kind === \"var\" ? this.currentScope().variableScope : this.currentScope();\n                for (i = 0, iz = node.declarations.length; i < iz; ++i) {\n                    decl = node.declarations[i];\n                    this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);\n                    if (decl.init) {\n                        this.visit(decl.init);\n                    }\n                }\n            }\n        },\n        SwitchStatement: {\n\n            // sec 13.11.8\n\n            value: function SwitchStatement(node) {\n                var i, iz;\n\n                this.visit(node.discriminant);\n\n                if (this.scopeManager.__isES6()) {\n                    this.scopeManager.__nestSwitchScope(node);\n                }\n\n                for (i = 0, iz = node.cases.length; i < iz; ++i) {\n                    this.visit(node.cases[i]);\n                }\n\n                this.close(node);\n            }\n        },\n        FunctionDeclaration: {\n            value: function FunctionDeclaration(node) {\n                this.visitFunction(node);\n            }\n        },\n        FunctionExpression: {\n            value: function FunctionExpression(node) {\n                this.visitFunction(node);\n            }\n        },\n        ForOfStatement: {\n            value: function ForOfStatement(node) {\n                this.visitForIn(node);\n            }\n        },\n        ForInStatement: {\n            value: function ForInStatement(node) {\n                this.visitForIn(node);\n            }\n        },\n        ArrowFunctionExpression: {\n            value: function ArrowFunctionExpression(node) {\n                this.visitFunction(node);\n            }\n        },\n        ImportDeclaration: {\n            value: function ImportDeclaration(node) {\n                var importer;\n\n                assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), \"ImportDeclaration should appear when the mode is ES6 and in the module context.\");\n\n                importer = new Importer(node, this);\n                importer.visit(node);\n            }\n        },\n        visitExportDeclaration: {\n            value: function visitExportDeclaration(node) {\n                if (node.source) {\n                    return;\n                }\n                if (node.declaration) {\n                    this.visit(node.declaration);\n                    return;\n                }\n\n                this.visitChildren(node);\n            }\n        },\n        ExportDeclaration: {\n            value: function ExportDeclaration(node) {\n                this.visitExportDeclaration(node);\n            }\n        },\n        ExportNamedDeclaration: {\n            value: function ExportNamedDeclaration(node) {\n                this.visitExportDeclaration(node);\n            }\n        },\n        ExportSpecifier: {\n            value: function ExportSpecifier(node) {\n                var local = node.id || node.local;\n                this.visit(local);\n            }\n        }\n    });\n\n    return Referencer;\n})(esrecurse.Visitor);\n\nmodule.exports = Referencer;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZmVyZW5jZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdUJTLE1BQU0sV0FBUSxZQUFZLEVBQTFCLE1BQU07O0lBQ1IsU0FBUywyQkFBTSxXQUFXOztJQUMxQixTQUFTLDJCQUFNLGFBQWE7O0lBQzVCLFFBQVEsMkJBQU0sWUFBWTs7SUFDMUIsY0FBYywyQkFBTSxtQkFBbUI7OzBCQUNFLGNBQWM7O0lBQXJELG1CQUFtQixlQUFuQixtQkFBbUI7SUFBRSxVQUFVLGVBQVYsVUFBVTs7SUFDakMsTUFBTSwyQkFBTSxRQUFROztBQUUzQixTQUFTLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFOztBQUVwRSxRQUFJLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDeEQsV0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQzs7O0FBRzNCLFFBQUksVUFBVSxJQUFJLElBQUksRUFBRTtBQUNwQixlQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0tBQ2hFO0NBQ0o7Ozs7Ozs7O0lBUUssUUFBUTtBQUNDLGFBRFQsUUFBUSxDQUNFLFdBQVcsRUFBRSxVQUFVLEVBQUU7OEJBRG5DLFFBQVE7O0FBRU4sbUNBRkYsUUFBUSw2Q0FFRTtBQUNSLFlBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQy9CLFlBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0tBQ2hDOztjQUxDLFFBQVE7O2lCQUFSLFFBQVE7QUFPVixtQkFBVzttQkFBQSxxQkFBQyxFQUFFLEVBQUUsU0FBUyxFQUFFOzs7QUFDdkIsb0JBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxVQUFDLE9BQU8sRUFBSztBQUMxQywwQkFBSyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDM0MsSUFBSSxVQUFVLENBQ1YsUUFBUSxDQUFDLGFBQWEsRUFDdEIsT0FBTyxFQUNQLFNBQVMsRUFDVCxNQUFLLFdBQVcsRUFDaEIsSUFBSSxFQUNKLElBQUksQ0FDSCxDQUFDLENBQUM7aUJBQ2QsQ0FBQyxDQUFDO2FBQ047O0FBRUQsZ0NBQXdCO21CQUFBLGtDQUFDLElBQUksRUFBRTtBQUMzQixvQkFBSSxLQUFLLEdBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsRUFBRSxBQUFDLENBQUM7QUFDcEMsb0JBQUksS0FBSyxFQUFFO0FBQ1Asd0JBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNqQzthQUNKOztBQUVELDhCQUFzQjttQkFBQSxnQ0FBQyxJQUFJLEVBQUU7QUFDekIsb0JBQUksS0FBSyxHQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEVBQUUsQUFBQyxDQUFDO0FBQ3BDLG9CQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNqQzs7QUFFRCx1QkFBZTttQkFBQSx5QkFBQyxJQUFJLEVBQUU7QUFDbEIsb0JBQUksS0FBSyxHQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEVBQUUsQUFBQyxDQUFDO0FBQ3BDLG9CQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7QUFDWCx3QkFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNyQyxNQUFNO0FBQ0gsd0JBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNqQzthQUNKOzs7O1dBeENDLFFBQVE7R0FBUyxTQUFTLENBQUMsT0FBTzs7OztJQTRDbkIsVUFBVTtBQUNoQixhQURNLFVBQVUsQ0FDZixZQUFZLEVBQUU7OEJBRFQsVUFBVTs7QUFFdkIsbUNBRmEsVUFBVSw2Q0FFZjtBQUNSLFlBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0FBQ2pDLFlBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ25CLFlBQUksQ0FBQyx1QkFBdUIsR0FBRyxLQUFLLENBQUM7S0FDeEM7O2NBTmdCLFVBQVU7O2lCQUFWLFVBQVU7QUFRM0Isb0JBQVk7bUJBQUEsd0JBQUc7QUFDWCx1QkFBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQzthQUMzQzs7QUFFRCxhQUFLO21CQUFBLGVBQUMsSUFBSSxFQUFFO0FBQ1IsdUJBQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsS0FBSyxFQUFFO0FBQzlELHdCQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztpQkFDckY7YUFDSjs7QUFFRCxpQ0FBeUI7bUJBQUEsbUNBQUMsdUJBQXVCLEVBQUU7QUFDL0Msb0JBQUksUUFBUSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQztBQUM1QyxvQkFBSSxDQUFDLHVCQUF1QixHQUFHLHVCQUF1QixDQUFDO0FBQ3ZELHVCQUFPLFFBQVEsQ0FBQzthQUNuQjs7QUFFRCxnQ0FBd0I7bUJBQUEsa0NBQUMsdUJBQXVCLEVBQUU7QUFDOUMsb0JBQUksQ0FBQyx1QkFBdUIsR0FBRyx1QkFBdUIsQ0FBQzthQUMxRDs7QUFFRCwyQkFBbUI7bUJBQUEsNkJBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRTs7O0FBR3JDLG9CQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDdEQsb0JBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNqRzs7QUFFRCxpQ0FBeUI7bUJBQUEsbUNBQUMsSUFBSSxFQUFFOzs7O0FBRTVCLG9CQUFJLGNBQWMsQ0FBQztBQUNuQixvQkFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkMsOEJBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQzNCLG9CQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3pGLG9CQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLFVBQUMsT0FBTyxFQUFLO0FBQzlELDBCQUFLLFlBQVksRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQzdGLENBQUMsQ0FBQzthQUNOOztBQUVELCtCQUF1QjttQkFBQSxpQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBRTtBQUNyRSxvQkFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ2xDLDJCQUFXLENBQUMsT0FBTyxDQUFDLFVBQUEsVUFBVSxFQUFJO0FBQzlCLHlCQUFLLENBQUMsYUFBYSxDQUNmLE9BQU8sRUFDUCxTQUFTLENBQUMsS0FBSyxFQUNmLFVBQVUsQ0FBQyxLQUFLLEVBQ2hCLG1CQUFtQixFQUNuQixPQUFPLEtBQUssVUFBVSxDQUFDLElBQUksRUFDM0IsSUFBSSxDQUFDLENBQUM7aUJBQ2IsQ0FBQyxDQUFDO2FBQ047O0FBRUQsb0JBQVk7bUJBQUEsc0JBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUU7QUFDbEMsb0JBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO0FBQy9CLDRCQUFRLEdBQUcsT0FBTyxDQUFDO0FBQ25CLDJCQUFPLEdBQUcsRUFBQyxxQkFBcUIsRUFBRSxLQUFLLEVBQUMsQ0FBQTtpQkFDM0M7QUFDRCwyQ0FBMkIsQ0FDdkIsSUFBSSxFQUNKLE9BQU8sQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUMzQyxRQUFRLENBQUMsQ0FBQzthQUNqQjs7QUFFRCxxQkFBYTttQkFBQSx1QkFBQyxJQUFJLEVBQUU7OztBQUNoQixvQkFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDOzs7Ozs7QUFNVixvQkFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTs7QUFFMUMsd0JBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFDNUIsSUFBSSxVQUFVLENBQ1YsUUFBUSxDQUFDLFlBQVksRUFDckIsSUFBSSxDQUFDLEVBQUUsRUFDUCxJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLENBQ1AsQ0FBQyxDQUFDO2lCQUNkOzs7O0FBSUQsb0JBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRTtBQUNwRCx3QkFBSSxDQUFDLFlBQVksQ0FBQyxpQ0FBaUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDN0Q7OztBQUdELG9CQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQzs7O0FBRzFFLHFCQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDOUMsd0JBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDLHFCQUFxQixFQUFFLElBQUksRUFBQyxFQUFFLFVBQUMsT0FBTyxFQUFFLElBQUksRUFBSztBQUNoRiw4QkFBSyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUNoQyxJQUFJLG1CQUFtQixDQUNuQixPQUFPLEVBQ1AsSUFBSSxFQUNKLENBQUMsRUFDRCxJQUFJLENBQUMsSUFBSSxDQUNaLENBQUMsQ0FBQzs7QUFFUCw4QkFBSyx1QkFBdUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQ3ZFLENBQUMsQ0FBQztpQkFDTjs7O0FBR0Qsb0JBQUksSUFBSSxDQUFDLElBQUksRUFBRTtBQUNYLHdCQUFJLENBQUMsWUFBWSxDQUFDO0FBQ2QsNEJBQUksRUFBRSxhQUFhO0FBQ25CLGdDQUFRLEVBQUUsSUFBSSxDQUFDLElBQUk7cUJBQ3RCLEVBQUUsVUFBQyxPQUFPLEVBQUs7QUFDWiw4QkFBSyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUNoQyxJQUFJLG1CQUFtQixDQUNuQixPQUFPLEVBQ1AsSUFBSSxFQUNKLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUNsQixJQUFJLENBQ1AsQ0FBQyxDQUFDO3FCQUNWLENBQUMsQ0FBQztpQkFDTjs7O0FBR0Qsb0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLGNBQWMsRUFBRTtBQUMxQyx3QkFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2pDLE1BQU07QUFDSCx3QkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3pCOztBQUVELG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCOztBQUVELGtCQUFVO21CQUFBLG9CQUFDLElBQUksRUFBRTtBQUNiLG9CQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQ3ZDLHdCQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQzVCLElBQUksVUFBVSxDQUNWLFFBQVEsQ0FBQyxTQUFTLEVBQ2xCLElBQUksQ0FBQyxFQUFFLEVBQ1AsSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxDQUNQLENBQUMsQ0FBQztpQkFDZDs7O0FBR0Qsb0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDOztBQUU1QixvQkFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFekMsb0JBQUksSUFBSSxDQUFDLEVBQUUsRUFBRTtBQUNULHdCQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQzVCLElBQUksVUFBVSxDQUNWLFFBQVEsQ0FBQyxTQUFTLEVBQ2xCLElBQUksQ0FBQyxFQUFFLEVBQ1AsSUFBSSxDQUNQLENBQUMsQ0FBQztpQkFDZDtBQUNELG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFdEIsb0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDcEI7O0FBRUQscUJBQWE7bUJBQUEsdUJBQUMsSUFBSSxFQUFFO0FBQ2hCLG9CQUFJLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQztBQUNqQyxvQkFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2Ysd0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUN4Qjs7QUFFRCxrQ0FBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztBQUMzRCxvQkFBSSxrQkFBa0IsRUFBRTtBQUNwQiw0QkFBUSxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbkQ7QUFDRCxvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkIsb0JBQUksa0JBQWtCLEVBQUU7QUFDcEIsd0JBQUksQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDM0M7YUFDSjs7QUFFRCxrQkFBVTttQkFBQSxvQkFBQyxJQUFJLEVBQUU7OztBQUNiLG9CQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLEVBQUU7QUFDM0Usd0JBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzNDLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2Qix3QkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRXZCLHdCQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsd0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RCLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNwQixNQUFNO0FBQ0gsd0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLG1CQUFtQixFQUFFO0FBQy9DLDRCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0Qiw0QkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsVUFBQyxPQUFPLEVBQUs7QUFDekQsa0NBQUssWUFBWSxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzt5QkFDN0YsQ0FBQyxDQUFDO3FCQUNOLE1BQU07QUFDSCw0QkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUMscUJBQXFCLEVBQUUsSUFBSSxFQUFDLEVBQUUsVUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFLO0FBQzNFLGdDQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQztBQUMvQixnQ0FBSSxDQUFDLE1BQUssWUFBWSxFQUFFLENBQUMsUUFBUSxFQUFFO0FBQy9CLG1EQUFtQixHQUFHO0FBQ2xCLDJDQUFPLEVBQUUsT0FBTztBQUNoQix3Q0FBSSxFQUFFLElBQUk7aUNBQ2IsQ0FBQzs2QkFDTDtBQUNELGtDQUFLLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLG1CQUFtQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3BGLGtDQUFLLFlBQVksRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQzt5QkFDN0csQ0FBQyxDQUFDO3FCQUNOO0FBQ0Qsd0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDekI7YUFDSjs7QUFFRCxnQ0FBd0I7bUJBQUEsa0NBQUMsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFOzs7O0FBRXRFLG9CQUFJLElBQUksRUFBRSxJQUFJLENBQUM7O0FBRWYsb0JBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLG9CQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNqQixvQkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUMscUJBQXFCLEVBQUUsQ0FBQyxPQUFPLEVBQUMsRUFBRSxVQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUs7QUFDN0UsdUNBQW1CLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDaEMsSUFBSSxVQUFVLENBQ1YsSUFBSSxFQUNKLE9BQU8sRUFDUCxJQUFJLEVBQ0osSUFBSSxFQUNKLEtBQUssRUFDTCxJQUFJLENBQUMsSUFBSSxDQUNaLENBQUMsQ0FBQzs7QUFFUCx3QkFBSSxDQUFDLE9BQU8sRUFBRTtBQUNWLDhCQUFLLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDdkU7QUFDRCx3QkFBSSxJQUFJLEVBQUU7QUFDTiw4QkFBSyxZQUFZLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQ2pHO2lCQUNKLENBQUMsQ0FBQzthQUNOOztBQUVELDRCQUFvQjttQkFBQSw4QkFBQyxJQUFJLEVBQUU7OztBQUN2QixvQkFBSSxjQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNyQyx3QkFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEdBQUcsRUFBRTtBQUN2Qiw0QkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUMscUJBQXFCLEVBQUUsSUFBSSxFQUFDLEVBQUUsVUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFLO0FBQzNFLGdDQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQztBQUMvQixnQ0FBSSxDQUFDLE1BQUssWUFBWSxFQUFFLENBQUMsUUFBUSxFQUFFO0FBQy9CLG1EQUFtQixHQUFHO0FBQ2xCLDJDQUFPLEVBQUUsT0FBTztBQUNoQix3Q0FBSSxFQUFFLElBQUk7aUNBQ2IsQ0FBQzs2QkFDTDtBQUNELGtDQUFLLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLG1CQUFtQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3BGLGtDQUFLLFlBQVksRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLG1CQUFtQixFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQzt5QkFDdkgsQ0FBQyxDQUFDO3FCQUNOLE1BQU07QUFDSCw0QkFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO3FCQUMxRTtpQkFDSixNQUFNO0FBQ0gsd0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN6QjtBQUNELG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMxQjs7QUFFRCxtQkFBVzttQkFBQSxxQkFBQyxJQUFJLEVBQUU7OztBQUNkLG9CQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV6QyxvQkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMscUJBQXFCLEVBQUUsSUFBSSxFQUFDLEVBQUUsVUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFLO0FBQzVFLDBCQUFLLFlBQVksRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQ2hDLElBQUksVUFBVSxDQUNWLFFBQVEsQ0FBQyxXQUFXLEVBQ3BCLElBQUksQ0FBQyxLQUFLLEVBQ1YsSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxDQUNQLENBQUMsQ0FBQztBQUNQLDBCQUFLLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDdkUsQ0FBQyxDQUFDO0FBQ0gsb0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV0QixvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNwQjs7QUFFRCxlQUFPO21CQUFBLGlCQUFDLElBQUksRUFBRTtBQUNWLG9CQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDOztBQUUxQyxvQkFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSxFQUFFOztBQUVyQyx3QkFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFDckMsd0JBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUN0RDs7QUFFRCxvQkFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUU7QUFDN0Qsd0JBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzdDOztBQUVELG9CQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pCLG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCOztBQUVELGtCQUFVO21CQUFBLG9CQUFDLElBQUksRUFBRTtBQUNiLG9CQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzNDOztBQUVELHdCQUFnQjttQkFBQSwwQkFBQyxJQUFJLEVBQUU7QUFDbkIsb0JBQUksY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDekMsd0JBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUN4RSxNQUFNO0FBQ0gsd0JBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzVCO2FBQ0o7O0FBRUQsd0JBQWdCO21CQUFBLDBCQUFDLElBQUksRUFBRTtBQUNuQixvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEIsb0JBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNmLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDN0I7YUFDSjs7QUFFRCxnQkFBUTttQkFBQSxrQkFBQyxJQUFJLEVBQUU7QUFDWCxvQkFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1Qjs7QUFFRCx3QkFBZ0I7bUJBQUEsMEJBQUMsSUFBSSxFQUFFO0FBQ25CLG9CQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzVCOztBQUVELHNCQUFjO21CQUFBLDBCQUFHLEVBQUU7O0FBRW5CLHlCQUFpQjttQkFBQSw2QkFBRyxFQUFFOztBQUV0Qix3QkFBZ0I7bUJBQUEsMEJBQUMsSUFBSSxFQUFFO0FBQ25CLG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6Qjs7QUFFRCxvQkFBWTttQkFBQSxzQkFBQyxJQUFJLEVBQUU7Ozs7O0FBS2Ysb0JBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsbUJBQW1CLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssS0FBSyxFQUFFO0FBQ3hGLHdCQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDMUM7O0FBRUQsb0JBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXpCLG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCOztBQUVELHVCQUFlO21CQUFBLHlCQUFDLElBQUksRUFBRTtBQUNsQixvQkFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6Qjs7QUFFRCx3QkFBZ0I7bUJBQUEsMEJBQUMsSUFBSSxFQUFFO0FBQ25CLG9CQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pCOztBQUVELHNCQUFjO21CQUFBLHdCQUFDLElBQUksRUFBRTs7QUFFakIsb0JBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFOzs7QUFHNUcsd0JBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLENBQUM7aUJBQ3BEO0FBQ0Qsb0JBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDNUI7O0FBRUQsc0JBQWM7bUJBQUEsd0JBQUMsSUFBSSxFQUFFO0FBQ2pCLG9CQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLEVBQUU7QUFDN0Isd0JBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzVDOztBQUVELG9CQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV6QixvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNwQjs7QUFFRCxzQkFBYzttQkFBQSwwQkFBRztBQUNiLG9CQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3BEOztBQUVELHFCQUFhO21CQUFBLHVCQUFDLElBQUksRUFBRTtBQUNoQixvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXhCLG9CQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFeEMsb0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV0QixvQkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNwQjs7QUFFRCwyQkFBbUI7bUJBQUEsNkJBQUMsSUFBSSxFQUFFO0FBQ3RCLG9CQUFJLG1CQUFtQixFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDO0FBQ3JDLG1DQUFtQixHQUFHLEFBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLEdBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDdEcscUJBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUNwRCx3QkFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsd0JBQUksQ0FBQyx3QkFBd0IsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMvRSx3QkFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ1gsNEJBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUN6QjtpQkFDSjthQUNKOztBQUdELHVCQUFlOzs7O21CQUFBLHlCQUFDLElBQUksRUFBRTtBQUNsQixvQkFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDOztBQUVWLG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzs7QUFFOUIsb0JBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsRUFBRTtBQUM3Qix3QkFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDN0M7O0FBRUQscUJBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUM3Qyx3QkFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQzdCOztBQUVELG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCOztBQUVELDJCQUFtQjttQkFBQSw2QkFBQyxJQUFJLEVBQUU7QUFDdEIsb0JBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDNUI7O0FBRUQsMEJBQWtCO21CQUFBLDRCQUFDLElBQUksRUFBRTtBQUNyQixvQkFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1Qjs7QUFFRCxzQkFBYzttQkFBQSx3QkFBQyxJQUFJLEVBQUU7QUFDakIsb0JBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekI7O0FBRUQsc0JBQWM7bUJBQUEsd0JBQUMsSUFBSSxFQUFFO0FBQ2pCLG9CQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pCOztBQUVELCtCQUF1QjttQkFBQSxpQ0FBQyxJQUFJLEVBQUU7QUFDMUIsb0JBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDNUI7O0FBRUQseUJBQWlCO21CQUFBLDJCQUFDLElBQUksRUFBRTtBQUNwQixvQkFBSSxRQUFRLENBQUM7O0FBRWIsc0JBQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsaUZBQWlGLENBQUMsQ0FBQzs7QUFFdkosd0JBQVEsR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEMsd0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDeEI7O0FBRUQsOEJBQXNCO21CQUFBLGdDQUFDLElBQUksRUFBRTtBQUN6QixvQkFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2IsMkJBQU87aUJBQ1Y7QUFDRCxvQkFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO0FBQ2xCLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM3QiwyQkFBTztpQkFDVjs7QUFFRCxvQkFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1Qjs7QUFFRCx5QkFBaUI7bUJBQUEsMkJBQUMsSUFBSSxFQUFFO0FBQ3BCLG9CQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDckM7O0FBRUQsOEJBQXNCO21CQUFBLGdDQUFDLElBQUksRUFBRTtBQUN6QixvQkFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3JDOztBQUVELHVCQUFlO21CQUFBLHlCQUFDLElBQUksRUFBRTtBQUNsQixvQkFBSSxLQUFLLEdBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxBQUFDLENBQUM7QUFDcEMsb0JBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDckI7Ozs7V0E5ZGdCLFVBQVU7R0FBUyxTQUFTLENBQUMsT0FBTzs7aUJBQXBDLFVBQVUiLCJmaWxlIjoicmVmZXJlbmNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbmltcG9ydCB7IFN5bnRheCB9IGZyb20gJ2VzdHJhdmVyc2UnO1xuaW1wb3J0IGVzcmVjdXJzZSBmcm9tICdlc3JlY3Vyc2UnO1xuaW1wb3J0IFJlZmVyZW5jZSBmcm9tICcuL3JlZmVyZW5jZSc7XG5pbXBvcnQgVmFyaWFibGUgZnJvbSAnLi92YXJpYWJsZSc7XG5pbXBvcnQgUGF0dGVyblZpc2l0b3IgZnJvbSAnLi9wYXR0ZXJuLXZpc2l0b3InO1xuaW1wb3J0IHsgUGFyYW1ldGVyRGVmaW5pdGlvbiwgRGVmaW5pdGlvbiB9IGZyb20gJy4vZGVmaW5pdGlvbic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmZ1bmN0aW9uIHRyYXZlcnNlSWRlbnRpZmllckluUGF0dGVybihyb290UGF0dGVybiwgcmVmZXJlbmNlciwgY2FsbGJhY2spIHtcbiAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayBhdCBsZWZ0IGhhbmQgaWRlbnRpZmllciBub2RlcywgYW5kIENvbGxlY3QgcmlnaHQgaGFuZCBub2Rlcy5cbiAgICB2YXIgdmlzaXRvciA9IG5ldyBQYXR0ZXJuVmlzaXRvcihyb290UGF0dGVybiwgY2FsbGJhY2spO1xuICAgIHZpc2l0b3IudmlzaXQocm9vdFBhdHRlcm4pO1xuXG4gICAgLy8gUHJvY2VzcyB0aGUgcmlnaHQgaGFuZCBub2RlcyByZWN1cnNpdmVseS5cbiAgICBpZiAocmVmZXJlbmNlciAhPSBudWxsKSB7XG4gICAgICAgIHZpc2l0b3IucmlnaHRIYW5kTm9kZXMuZm9yRWFjaChyZWZlcmVuY2VyLnZpc2l0LCByZWZlcmVuY2VyKTtcbiAgICB9XG59XG5cbi8vIEltcG9ydGluZyBJbXBvcnREZWNsYXJhdGlvbi5cbi8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW1vZHVsZWRlY2xhcmF0aW9uaW5zdGFudGlhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9tYXN0ZXIvZXM2Lm1kI2ltcG9ydGRlY2xhcmF0aW9uXG4vLyBGSVhNRTogTm93LCB3ZSBkb24ndCBjcmVhdGUgbW9kdWxlIGVudmlyb25tZW50LCBiZWNhdXNlIHRoZSBjb250ZXh0IGlzXG4vLyBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQuXG5cbmNsYXNzIEltcG9ydGVyIGV4dGVuZHMgZXNyZWN1cnNlLlZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGRlY2xhcmF0aW9uLCByZWZlcmVuY2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VyID0gcmVmZXJlbmNlcjtcbiAgICB9XG5cbiAgICB2aXNpdEltcG9ydChpZCwgc3BlY2lmaWVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlci52aXNpdFBhdHRlcm4oaWQsIChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZXIuY3VycmVudFNjb3BlKCkuX19kZWZpbmUocGF0dGVybixcbiAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuSW1wb3J0QmluZGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICAgICAgICBsZXQgbG9jYWwgPSAobm9kZS5sb2NhbCB8fCBub2RlLmlkKTtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0SW1wb3J0KGxvY2FsLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSkge1xuICAgICAgICBsZXQgbG9jYWwgPSAobm9kZS5sb2NhbCB8fCBub2RlLmlkKTtcbiAgICAgICAgdGhpcy52aXNpdEltcG9ydChsb2NhbCwgbm9kZSk7XG4gICAgfVxuXG4gICAgSW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsID0gKG5vZGUubG9jYWwgfHwgbm9kZS5pZCk7XG4gICAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRJbXBvcnQobm9kZS5uYW1lLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRJbXBvcnQobG9jYWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBSZWZlcmVuY2luZyB2YXJpYWJsZXMgYW5kIGNyZWF0aW5nIGJpbmRpbmdzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmZXJlbmNlciBleHRlbmRzIGVzcmVjdXJzZS5WaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIgPSBzY29wZU1hbmFnZXI7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGN1cnJlbnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVNYW5hZ2VyLl9fY3VycmVudFNjb3BlO1xuICAgIH1cblxuICAgIGNsb3NlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudFNjb3BlKCkgJiYgbm9kZSA9PT0gdGhpcy5jdXJyZW50U2NvcGUoKS5ibG9jaykge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19jdXJyZW50U2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpLl9fY2xvc2UodGhpcy5zY29wZU1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaElubmVyTWV0aG9kRGVmaW5pdGlvbihpc0lubmVyTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmlzSW5uZXJNZXRob2REZWZpbml0aW9uO1xuICAgICAgICB0aGlzLmlzSW5uZXJNZXRob2REZWZpbml0aW9uID0gaXNJbm5lck1ldGhvZERlZmluaXRpb247XG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG5cbiAgICBwb3BJbm5lck1ldGhvZERlZmluaXRpb24oaXNJbm5lck1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbiA9IGlzSW5uZXJNZXRob2REZWZpbml0aW9uO1xuICAgIH1cblxuICAgIG1hdGVyaWFsaXplVERaU2NvcGUobm9kZSwgaXRlcmF0aW9uTm9kZSkge1xuICAgICAgICAvLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1ydW50aW1lLXNlbWFudGljcy1mb3Jpbi1kaXYtb2ZleHByZXNzaW9uZXZhbHVhdGlvbi1hYnN0cmFjdC1vcGVyYXRpb25cbiAgICAgICAgLy8gVERaIHNjb3BlIGhpZGVzIHRoZSBkZWNsYXJhdGlvbidzIG5hbWVzLlxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RURFpTY29wZShub2RlLCBpdGVyYXRpb25Ob2RlKTtcbiAgICAgICAgdGhpcy52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24odGhpcy5jdXJyZW50U2NvcGUoKSwgVmFyaWFibGUuVERaLCBpdGVyYXRpb25Ob2RlLmxlZnQsIDAsIHRydWUpO1xuICAgIH1cblxuICAgIG1hdGVyaWFsaXplSXRlcmF0aW9uU2NvcGUobm9kZSkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBpdGVyYXRpb24gc2NvcGUgZm9yIHVwcGVyIEZvckluL0Zvck9mIFN0YXRlbWVudHMuXG4gICAgICAgIHZhciBsZXRPckNvbnN0RGVjbDtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Rm9yU2NvcGUobm9kZSk7XG4gICAgICAgIGxldE9yQ29uc3REZWNsID0gbm9kZS5sZWZ0O1xuICAgICAgICB0aGlzLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbih0aGlzLmN1cnJlbnRTY29wZSgpLCBWYXJpYWJsZS5WYXJpYWJsZSwgbGV0T3JDb25zdERlY2wsIDApO1xuICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihsZXRPckNvbnN0RGVjbC5kZWNsYXJhdGlvbnNbMF0uaWQsIChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fcmVmZXJlbmNpbmcocGF0dGVybiwgUmVmZXJlbmNlLldSSVRFLCBub2RlLnJpZ2h0LCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVmZXJlbmNpbmdEZWZhdWx0VmFsdWUocGF0dGVybiwgYXNzaWdubWVudHMsIG1heWJlSW1wbGljaXRHbG9iYWwsIGluaXQpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgICBhc3NpZ25tZW50cy5mb3JFYWNoKGFzc2lnbm1lbnQgPT4ge1xuICAgICAgICAgICAgc2NvcGUuX19yZWZlcmVuY2luZyhcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIFJlZmVyZW5jZS5XUklURSxcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50LnJpZ2h0LFxuICAgICAgICAgICAgICAgIG1heWJlSW1wbGljaXRHbG9iYWwsXG4gICAgICAgICAgICAgICAgcGF0dGVybiAhPT0gYXNzaWdubWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgIGluaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2aXNpdFBhdHRlcm4obm9kZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge3Byb2Nlc3NSaWdodEhhbmROb2RlczogZmFsc2V9XG4gICAgICAgIH1cbiAgICAgICAgdHJhdmVyc2VJZGVudGlmaWVySW5QYXR0ZXJuKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG9wdGlvbnMucHJvY2Vzc1JpZ2h0SGFuZE5vZGVzID8gdGhpcyA6IG51bGwsXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmlzaXRGdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgLy8gRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lIGlzIGRlZmluZWQgaW4gdXBwZXIgc2NvcGVcbiAgICAgICAgLy8gTk9URTogTm90IHJlZmVycmluZyB2YXJpYWJsZVNjb3BlLiBJdCBpcyBpbnRlbmRlZC5cbiAgICAgICAgLy8gU2luY2VcbiAgICAgICAgLy8gIGluIEVTNSwgRnVuY3Rpb25EZWNsYXJhdGlvbiBzaG91bGQgYmUgaW4gRnVuY3Rpb25Cb2R5LlxuICAgICAgICAvLyAgaW4gRVM2LCBGdW5jdGlvbkRlY2xhcmF0aW9uIHNob3VsZCBiZSBibG9jayBzY29wZWQuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZCBpcyBkZWZpbmVkIGluIHVwcGVyIHNjb3BlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuRnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGdW5jdGlvbkV4cHJlc3Npb24gd2l0aCBuYW1lIGNyZWF0ZXMgaXRzIHNwZWNpYWwgc2NvcGU7XG4gICAgICAgIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZS5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbiAmJiBub2RlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RGdW5jdGlvbkV4cHJlc3Npb25OYW1lU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zaWRlciB0aGlzIGZ1bmN0aW9uIGlzIGluIHRoZSBNZXRob2REZWZpbml0aW9uLlxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RGdW5jdGlvblNjb3BlKG5vZGUsIHRoaXMuaXNJbm5lck1ldGhvZERlZmluaXRpb24pO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFyYW1ldGVyIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLnBhcmFtcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLnBhcmFtc1tpXSwge3Byb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZX0sIChwYXR0ZXJuLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUGFyYW1ldGVyRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucmVzdFxuICAgICAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNpbmdEZWZhdWx0VmFsdWUocGF0dGVybiwgaW5mby5hc3NpZ25tZW50cywgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYSByZXN0IGFyZ3VtZW50LCBhZGQgdGhhdFxuICAgICAgICBpZiAobm9kZS5yZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogbm9kZS5yZXN0XG4gICAgICAgICAgICB9LCAocGF0dGVybikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19kZWZpbmUocGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBhcmFtZXRlckRlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgQmxvY2tTdGF0ZW1lbnQgdG8gcHJldmVudCBjcmVhdGluZyBCbG9ja1N0YXRlbWVudCBzY29wZS5cbiAgICAgICAgaWYgKG5vZGUuYm9keS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihub2RlLmJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICB2aXNpdENsYXNzKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19kZWZpbmUobm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5DbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FOiBNYXliZSBjb25zaWRlciBURFouXG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5zdXBlckNsYXNzKTtcblxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RDbGFzc1Njb3BlKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgdmlzaXRQcm9wZXJ0eShub2RlKSB7XG4gICAgICAgIHZhciBwcmV2aW91cywgaXNNZXRob2REZWZpbml0aW9uO1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpc01ldGhvZERlZmluaXRpb24gPSBub2RlLnR5cGUgPT09IFN5bnRheC5NZXRob2REZWZpbml0aW9uO1xuICAgICAgICBpZiAoaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMucHVzaElubmVyTWV0aG9kRGVmaW5pdGlvbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0KG5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvcElubmVyTWV0aG9kRGVmaW5pdGlvbihwcmV2aW91cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdEZvckluKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiAmJiBub2RlLmxlZnQua2luZCAhPT0gJ3ZhcicpIHtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxpemVURFpTY29wZShub2RlLnJpZ2h0LCBub2RlKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5yaWdodCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKG5vZGUucmlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLm1hdGVyaWFsaXplSXRlcmF0aW9uU2NvcGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLmxlZnQuZGVjbGFyYXRpb25zWzBdLmlkLCAocGF0dGVybikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fcmVmZXJlbmNpbmcocGF0dGVybiwgUmVmZXJlbmNlLldSSVRFLCBub2RlLnJpZ2h0LCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZS5sZWZ0LCB7cHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiB0cnVlfSwgKHBhdHRlcm4sIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heWJlSW1wbGljaXRHbG9iYWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudFNjb3BlKCkuaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlSW1wbGljaXRHbG9iYWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNpbmdEZWZhdWx0VmFsdWUocGF0dGVybiwgaW5mby5hc3NpZ25tZW50cywgbWF5YmVJbXBsaWNpdEdsb2JhbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fcmVmZXJlbmNpbmcocGF0dGVybiwgUmVmZXJlbmNlLldSSVRFLCBub2RlLnJpZ2h0LCBtYXliZUltcGxpY2l0R2xvYmFsLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKHZhcmlhYmxlVGFyZ2V0U2NvcGUsIHR5cGUsIG5vZGUsIGluZGV4LCBmcm9tVERaKSB7XG4gICAgICAgIC8vIElmIHRoaXMgd2FzIGNhbGxlZCB0byBpbml0aWFsaXplIGEgVERaIHNjb3BlLCB0aGlzIG5lZWRzIHRvIG1ha2UgZGVmaW5pdGlvbnMsIGJ1dCBkb2Vzbid0IG1ha2UgcmVmZXJlbmNlcy5cbiAgICAgICAgdmFyIGRlY2wsIGluaXQ7XG5cbiAgICAgICAgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2luZGV4XTtcbiAgICAgICAgaW5pdCA9IGRlY2wuaW5pdDtcbiAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4oZGVjbC5pZCwge3Byb2Nlc3NSaWdodEhhbmROb2RlczogIWZyb21URFp9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdmFyaWFibGVUYXJnZXRTY29wZS5fX2RlZmluZShwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBkZWNsLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5raW5kXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGlmICghZnJvbVREWikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNpbmdEZWZhdWx0VmFsdWUocGF0dGVybiwgaW5mby5hc3NpZ25tZW50cywgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhwYXR0ZXJuLCBSZWZlcmVuY2UuV1JJVEUsIGluaXQsIG51bGwsICFpbmZvLnRvcExldmVsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICBpZiAoUGF0dGVyblZpc2l0b3IuaXNQYXR0ZXJuKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLmxlZnQsIHtwcm9jZXNzUmlnaHRIYW5kTm9kZXM6IHRydWV9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50U2NvcGUoKS5pc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVJbXBsaWNpdEdsb2JhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBtYXliZUltcGxpY2l0R2xvYmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhwYXR0ZXJuLCBSZWZlcmVuY2UuV1JJVEUsIG5vZGUucmlnaHQsIG1heWJlSW1wbGljaXRHbG9iYWwsICFpbmZvLnRvcExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhub2RlLmxlZnQsIFJlZmVyZW5jZS5SVywgbm9kZS5yaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdChub2RlLnJpZ2h0KTtcbiAgICB9XG5cbiAgICBDYXRjaENsYXVzZShub2RlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdENhdGNoU2NvcGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZS5wYXJhbSwge3Byb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZX0sIChwYXR0ZXJuLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIFZhcmlhYmxlLkNhdGNoQ2xhdXNlLFxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmFtLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jaW5nRGVmYXVsdFZhbHVlKHBhdHRlcm4sIGluZm8uYXNzaWdubWVudHMsIG51bGwsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgUHJvZ3JhbShub2RlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEdsb2JhbFNjb3BlKG5vZGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzTm9kZWpzU2NvcGUoKSkge1xuICAgICAgICAgICAgLy8gRm9yY2Ugc3RyaWN0bmVzcyBvZiBHbG9iYWxTY29wZSB0byBmYWxzZSB3aGVuIHVzaW5nIG5vZGUuanMgc2NvcGUuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLmlzU3RyaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RGdW5jdGlvblNjb3BlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkgJiYgdGhpcy5zY29wZU1hbmFnZXIuaXNNb2R1bGUoKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0TW9kdWxlU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgSWRlbnRpZmllcihub2RlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhub2RlKTtcbiAgICB9XG5cbiAgICBVcGRhdGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKFBhdHRlcm5WaXNpdG9yLmlzUGF0dGVybihub2RlLmFyZ3VtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKG5vZGUuYXJndW1lbnQsIFJlZmVyZW5jZS5SVywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLm9iamVjdCk7XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUHJvcGVydHkobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0UHJvcGVydHkobm9kZSk7XG4gICAgfVxuXG4gICAgTWV0aG9kRGVmaW5pdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRQcm9wZXJ0eShub2RlKTtcbiAgICB9XG5cbiAgICBCcmVha1N0YXRlbWVudCgpIHt9XG5cbiAgICBDb250aW51ZVN0YXRlbWVudCgpIHt9XG5cbiAgICBMYWJlbGVkU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuICAgIH1cblxuICAgIEZvclN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIC8vIENyZWF0ZSBGb3JTdGF0ZW1lbnQgZGVjbGFyYXRpb24uXG4gICAgICAgIC8vIE5PVEU6IEluIEVTNiwgRm9yU3RhdGVtZW50IGR5bmFtaWNhbGx5IGdlbmVyYXRlc1xuICAgICAgICAvLyBwZXIgaXRlcmF0aW9uIGVudmlyb25tZW50LiBIb3dldmVyLCBlc2NvcGUgaXNcbiAgICAgICAgLy8gYSBzdGF0aWMgYW5hbHl6ZXIsIHdlIG9ubHkgZ2VuZXJhdGUgb25lIHNjb3BlIGZvciBGb3JTdGF0ZW1lbnQuXG4gICAgICAgIGlmIChub2RlLmluaXQgJiYgbm9kZS5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uICYmIG5vZGUuaW5pdC5raW5kICE9PSAndmFyJykge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Rm9yU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICBDbGFzc0V4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3Mobm9kZSk7XG4gICAgfVxuXG4gICAgQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRDbGFzcyhub2RlKTtcbiAgICB9XG5cbiAgICBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIC8vIENoZWNrIHRoaXMgaXMgZGlyZWN0IGNhbGwgdG8gZXZhbFxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVNYW5hZ2VyLl9faWdub3JlRXZhbCgpICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUuY2FsbGVlLm5hbWUgPT09ICdldmFsJykge1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBzaG91bGQgYmUgYHZhcmlhYmxlU2NvcGVgLiBTaW5jZSBkaXJlY3QgZXZhbCBjYWxsIGFsd2F5cyBjcmVhdGVzIExleGljYWwgZW52aXJvbm1lbnQgYW5kXG4gICAgICAgICAgICAvLyBsZXQgLyBjb25zdCBzaG91bGQgYmUgZW5jbG9zZWQgaW50byBpdC4gT25seSBWYXJpYWJsZURlY2xhcmF0aW9uIGFmZmVjdHMgb24gdGhlIGNhbGxlcidzIGVudmlyb25tZW50LlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS52YXJpYWJsZVNjb3BlLl9fZGV0ZWN0RXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihub2RlKTtcbiAgICB9XG5cbiAgICBCbG9ja1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEJsb2NrU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICBUaGlzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS52YXJpYWJsZVNjb3BlLl9fZGV0ZWN0VGhpcygpO1xuICAgIH1cblxuICAgIFdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUub2JqZWN0KTtcbiAgICAgICAgLy8gVGhlbiBuZXN0IHNjb3BlIGZvciBXaXRoU3RhdGVtZW50LlxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RXaXRoU2NvcGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZVRhcmdldFNjb3BlLCBpLCBpeiwgZGVjbDtcbiAgICAgICAgdmFyaWFibGVUYXJnZXRTY29wZSA9IChub2RlLmtpbmQgPT09ICd2YXInKSA/IHRoaXMuY3VycmVudFNjb3BlKCkudmFyaWFibGVTY29wZSA6IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgdGhpcy52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyaWFibGVUYXJnZXRTY29wZSwgVmFyaWFibGUuVmFyaWFibGUsIG5vZGUsIGkpO1xuICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoZGVjbC5pbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlYyAxMy4xMS44XG4gICAgU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6O1xuXG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5kaXNjcmltaW5hbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdFN3aXRjaFNjb3BlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLmNhc2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5jYXNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb24obm9kZSk7XG4gICAgfVxuXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEZvck9mU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZvckluKG5vZGUpO1xuICAgIH1cblxuICAgIEZvckluU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZvckluKG5vZGUpO1xuICAgIH1cblxuICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGltcG9ydGVyO1xuXG4gICAgICAgIGFzc2VydCh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkgJiYgdGhpcy5zY29wZU1hbmFnZXIuaXNNb2R1bGUoKSwgJ0ltcG9ydERlY2xhcmF0aW9uIHNob3VsZCBhcHBlYXIgd2hlbiB0aGUgbW9kZSBpcyBFUzYgYW5kIGluIHRoZSBtb2R1bGUgY29udGV4dC4nKTtcblxuICAgICAgICBpbXBvcnRlciA9IG5ldyBJbXBvcnRlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaW1wb3J0ZXIudmlzaXQobm9kZSk7XG4gICAgfVxuXG4gICAgdmlzaXRFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgRXhwb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsID0gKG5vZGUuaWQgfHwgbm9kZS5sb2NhbCk7XG4gICAgICAgIHRoaXMudmlzaXQobG9jYWwpO1xuICAgIH1cbn1cblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/referencer.js\n ** module id = 125\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/referencer.js?");

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n(function () {\n    'use strict';\n\n    var estraverse,\n        isArray,\n        objectKeys;\n\n    estraverse = __webpack_require__(127);\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n            keys.push(key);\n        }\n        return keys;\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';\n    }\n\n    function Visitor(visitor) {\n        this.__visitor = visitor ||  this;\n    }\n\n    /* Default method for visiting children.\n     * When you need to call default visiting operation inside custom visiting\n     * operation, you can use it with `this.visitChildren(node)`.\n     */\n    Visitor.prototype.visitChildren = function (node) {\n        var type, children, i, iz, j, jz, child;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n\n        children = estraverse.VisitorKeys[type];\n        if (!children) {\n            children = objectKeys(node);\n        }\n\n        for (i = 0, iz = children.length; i < iz; ++i) {\n            child = node[children[i]];\n            if (child) {\n                if (Array.isArray(child)) {\n                    for (j = 0, jz = child.length; j < jz; ++j) {\n                        if (child[j]) {\n                            if (isNode(child[j]) || isProperty(type, children[i])) {\n                                this.visit(child[j]);\n                            }\n                        }\n                    }\n                } else if (isNode(child)) {\n                    this.visit(child);\n                }\n            }\n        }\n    };\n\n    /* Dispatching node. */\n    Visitor.prototype.visit = function (node) {\n        var type;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n        if (this.__visitor[type]) {\n            this.__visitor[type].call(this, node);\n            return;\n        }\n        this.visitChildren(node);\n    };\n\n    exports.version = __webpack_require__(129).version;\n    exports.Visitor = Visitor;\n    exports.visit = function (node, visitor) {\n        var v = new Visitor(visitor);\n        v.visit(node);\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/esrecurse/esrecurse.js\n ** module id = 126\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/esrecurse/esrecurse.js?");

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        isArray,\n        VisitorOption,\n        VisitorKeys,\n        objectCreate,\n        objectKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function ignoreJSHintError() { }\n\n    isArray = Array.isArray;\n    if (!isArray) {\n        isArray = function isArray(array) {\n            return Object.prototype.toString.call(array) === '[object Array]';\n        };\n    }\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    ignoreJSHintError(shallowCopy);\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    function lowerBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                i = current + 1;\n                len -= diff + 1;\n            } else {\n                len = diff;\n            }\n        }\n        return i;\n    }\n    ignoreJSHintError(lowerBound);\n\n    objectCreate = Object.create || (function () {\n        function F() { }\n\n        return function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    })();\n\n    objectKeys = Object.keys || function (o) {\n        var keys = [], key;\n        for (key in o) {\n            keys.push(key);\n        }\n        return keys;\n    };\n\n    function extend(to, from) {\n        var keys = objectKeys(from), key, i, len;\n        for (i = 0, len = keys.length; i < len; i += 1) {\n            key = keys[i];\n            to[key] = from[key];\n        }\n        return to;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SuperExpression: 'SuperExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        SuperExpression: ['super'],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = visitor.fallback === 'iteration';\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = extend(objectCreate(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = element.wrap || node.type;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = objectKeys(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = element.wrap || node.type;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = objectKeys(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = __webpack_require__(128).version;\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/esrecurse/~/estraverse/estraverse.js\n ** module id = 127\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/esrecurse/~/estraverse/estraverse.js?");

/***/ },
/* 128 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"estraverse@~3.1.0\",\n\t\t\t\"/home/cs/Projects/rlet/node_modules/esrecurse\"\n\t\t]\n\t],\n\t\"_from\": \"estraverse@>=3.1.0 <3.2.0\",\n\t\"_id\": \"estraverse@3.1.0\",\n\t\"_inCache\": true,\n\t\"_location\": \"/esrecurse/estraverse\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.0.0-alpha-5\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"estraverse\",\n\t\t\"raw\": \"estraverse@~3.1.0\",\n\t\t\"rawSpec\": \"~3.1.0\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=3.1.0 <3.2.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/esrecurse\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-3.1.0.tgz\",\n\t\"_shasum\": \"15e28a446b8b82bc700ccc8b96c78af4da0d6cba\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"estraverse@~3.1.0\",\n\t\"_where\": \"/home/cs/Projects/rlet/node_modules/esrecurse\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/estraverse/issues\"\n\t},\n\t\"dependencies\": {},\n\t\"description\": \"ECMAScript JS AST traversal functions\",\n\t\"devDependencies\": {\n\t\t\"chai\": \"^2.1.1\",\n\t\t\"coffee-script\": \"^1.8.0\",\n\t\t\"espree\": \"^1.11.0\",\n\t\t\"gulp\": \"^3.8.10\",\n\t\t\"gulp-bump\": \"^0.2.2\",\n\t\t\"gulp-filter\": \"^2.0.0\",\n\t\t\"gulp-git\": \"^1.0.1\",\n\t\t\"gulp-tag-version\": \"^1.2.1\",\n\t\t\"jshint\": \"^2.5.6\",\n\t\t\"mocha\": \"^2.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"15e28a446b8b82bc700ccc8b96c78af4da0d6cba\",\n\t\t\"tarball\": \"http://registry.npmjs.org/estraverse/-/estraverse-3.1.0.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.10.0\"\n\t},\n\t\"gitHead\": \"166ebbe0a8d45ceb2391b6f5ef5d1bab6bfb267a\",\n\t\"homepage\": \"https://github.com/estools/estraverse\",\n\t\"installable\": true,\n\t\"licenses\": [\n\t\t{\n\t\t\t\"type\": \"BSD\",\n\t\t\t\"url\": \"http://github.com/estools/estraverse/raw/master/LICENSE.BSD\"\n\t\t}\n\t],\n\t\"main\": \"estraverse.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"michaelficarra\",\n\t\t\t\"email\": \"npm@michael.ficarra.me\"\n\t\t}\n\t],\n\t\"name\": \"estraverse\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"http://github.com/estools/estraverse.git\"\n\t},\n\t\"scripts\": {\n\t\t\"lint\": \"jshint estraverse.js\",\n\t\t\"test\": \"npm run-script lint && npm run-script unit-test\",\n\t\t\"unit-test\": \"mocha --compilers coffee:coffee-script/register\"\n\t},\n\t\"version\": \"3.1.0\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/esrecurse/~/estraverse/package.json\n ** module id = 128\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/esrecurse/~/estraverse/package.json?");

/***/ },
/* 129 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"esrecurse@^3.1.1\",\n\t\t\t\"/home/cs/Projects/rlet/node_modules/escope\"\n\t\t]\n\t],\n\t\"_from\": \"esrecurse@>=3.1.1 <4.0.0\",\n\t\"_id\": \"esrecurse@3.1.1\",\n\t\"_inCache\": true,\n\t\"_location\": \"/esrecurse\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.0.0-alpha-5\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"esrecurse\",\n\t\t\"raw\": \"esrecurse@^3.1.1\",\n\t\t\"rawSpec\": \"^3.1.1\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=3.1.1 <4.0.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/escope\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/esrecurse/-/esrecurse-3.1.1.tgz\",\n\t\"_shasum\": \"8feb963699d4d1b2d65a576cd4b1296672a0f0e9\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"esrecurse@^3.1.1\",\n\t\"_where\": \"/home/cs/Projects/rlet/node_modules/escope\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/esrecurse/issues\"\n\t},\n\t\"dependencies\": {\n\t\t\"estraverse\": \"~3.1.0\"\n\t},\n\t\"description\": \"ECMAScript scope analyzer\",\n\t\"devDependencies\": {\n\t\t\"chai\": \"^2.1.1\",\n\t\t\"coffee-script\": \"^1.9.1\",\n\t\t\"esprima\": \"^2.1.0\",\n\t\t\"gulp\": \"~3.8.10\",\n\t\t\"gulp-bump\": \"^0.2.2\",\n\t\t\"gulp-eslint\": \"^0.6.0\",\n\t\t\"gulp-filter\": \"^2.0.2\",\n\t\t\"gulp-git\": \"^1.1.0\",\n\t\t\"gulp-mocha\": \"~2.0.0\",\n\t\t\"gulp-tag-version\": \"^1.2.1\",\n\t\t\"jsdoc\": \"~3.3.0-alpha10\",\n\t\t\"minimist\": \"^1.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"8feb963699d4d1b2d65a576cd4b1296672a0f0e9\",\n\t\t\"tarball\": \"http://registry.npmjs.org/esrecurse/-/esrecurse-3.1.1.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.10.0\"\n\t},\n\t\"gitHead\": \"600a8aac5e7b313875a873134fd110b47a76fc77\",\n\t\"homepage\": \"http://github.com/estools/esrecurse\",\n\t\"installable\": true,\n\t\"licenses\": [\n\t\t{\n\t\t\t\"type\": \"BSD\",\n\t\t\t\"url\": \"http://github.com/estools/esrecurse/raw/master/LICENSE.BSD\"\n\t\t}\n\t],\n\t\"main\": \"esrecurse.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"michaelficarra\",\n\t\t\t\"email\": \"npm@michael.ficarra.me\"\n\t\t}\n\t],\n\t\"name\": \"esrecurse\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"http://github.com/estools/esrecurse.git\"\n\t},\n\t\"scripts\": {\n\t\t\"lint\": \"gulp lint\",\n\t\t\"test\": \"gulp travis\",\n\t\t\"unit-test\": \"gulp test\"\n\t},\n\t\"version\": \"3.1.1\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/esrecurse/package.json\n ** module id = 129\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/esrecurse/package.json?");

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nvar Syntax = __webpack_require__(106).Syntax;\n\nvar esrecurse = _interopRequire(__webpack_require__(126));\n\nfunction getLast(xs) {\n    return xs[xs.length - 1] || null;\n}\n\nvar PatternVisitor = (function (_esrecurse$Visitor) {\n    function PatternVisitor(rootPattern, callback) {\n        _classCallCheck(this, PatternVisitor);\n\n        _get(Object.getPrototypeOf(PatternVisitor.prototype), \"constructor\", this).call(this);\n        this.rootPattern = rootPattern;\n        this.callback = callback;\n        this.assignments = [];\n        this.rightHandNodes = [];\n        this.restElements = [];\n    }\n\n    _inherits(PatternVisitor, _esrecurse$Visitor);\n\n    _createClass(PatternVisitor, {\n        Identifier: {\n            value: function Identifier(pattern) {\n                var lastRestElement = getLast(this.restElements);\n                this.callback(pattern, {\n                    topLevel: pattern === this.rootPattern,\n                    rest: lastRestElement != null && lastRestElement.argument === pattern,\n                    assignments: this.assignments\n                });\n            }\n        },\n        Property: {\n            value: function Property(property) {\n                // Computed property's key is a right hand node.\n                if (property.computed) {\n                    this.rightHandNodes.push(property.key);\n                }\n\n                // If it's shorthand, its key is same as its value.\n                // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).\n                // If it's not shorthand, the name of new variable is its value's.\n                this.visit(property.value);\n            }\n        },\n        ArrayPattern: {\n            value: function ArrayPattern(pattern) {\n                var i, iz, element;\n                for (i = 0, iz = pattern.elements.length; i < iz; ++i) {\n                    element = pattern.elements[i];\n                    this.visit(element);\n                }\n            }\n        },\n        AssignmentPattern: {\n            value: function AssignmentPattern(pattern) {\n                this.assignments.push(pattern);\n                this.visit(pattern.left);\n                this.rightHandNodes.push(pattern.right);\n                this.assignments.pop();\n            }\n        },\n        RestElement: {\n            value: function RestElement(pattern) {\n                this.restElements.push(pattern);\n                this.visit(pattern.argument);\n                this.restElements.pop();\n            }\n        },\n        MemberExpression: {\n            value: function MemberExpression(node) {\n                // Computed property's key is a right hand node.\n                if (node.computed) {\n                    this.rightHandNodes.push(node.property);\n                }\n                // the object is only read, write to its property.\n                this.rightHandNodes.push(node.object);\n            }\n        },\n        SpreadElement: {\n\n            //\n            // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.\n            // By spec, LeftHandSideExpression is Pattern or MemberExpression.\n            //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)\n            // But espree 2.0 and esprima 2.0 parse to ArrayExpression, ObjectExpression, etc...\n            //\n\n            value: function SpreadElement(node) {\n                this.visit(node.argument);\n            }\n        },\n        ArrayExpression: {\n            value: function ArrayExpression(node) {\n                node.elements.forEach(this.visit, this);\n            }\n        },\n        AssignmentExpression: {\n            value: function AssignmentExpression(node) {\n                this.assignments.push(node);\n                this.visit(node.left);\n                this.rightHandNodes.push(node.right);\n                this.assignments.pop();\n            }\n        },\n        CallExpression: {\n            value: function CallExpression(node) {\n                var _this = this;\n\n                // arguments are right hand nodes.\n                node.arguments.forEach(function (a) {\n                    _this.rightHandNodes.push(a);\n                });\n                this.visit(node.callee);\n            }\n        }\n    }, {\n        isPattern: {\n            value: function isPattern(node) {\n                var nodeType = node.type;\n                return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;\n            }\n        }\n    });\n\n    return PatternVisitor;\n})(esrecurse.Visitor);\n\nmodule.exports = PatternVisitor;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhdHRlcm4tdmlzaXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3QlMsTUFBTSxXQUFRLFlBQVksRUFBMUIsTUFBTTs7SUFDUixTQUFTLDJCQUFNLFdBQVc7O0FBRWpDLFNBQVMsT0FBTyxDQUFDLEVBQUUsRUFBRTtBQUNqQixXQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQztDQUNwQzs7SUFFb0IsY0FBYztBQWFwQixhQWJNLGNBQWMsQ0FhbkIsV0FBVyxFQUFFLFFBQVEsRUFBRTs4QkFibEIsY0FBYzs7QUFjM0IsbUNBZGEsY0FBYyw2Q0FjbkI7QUFDUixZQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztBQUMvQixZQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUN6QixZQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN0QixZQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN6QixZQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztLQUMxQjs7Y0FwQmdCLGNBQWM7O2lCQUFkLGNBQWM7QUFzQi9CLGtCQUFVO21CQUFBLG9CQUFDLE9BQU8sRUFBRTtBQUNoQixvQkFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNuRCxvQkFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUU7QUFDbkIsNEJBQVEsRUFBRSxPQUFPLEtBQUssSUFBSSxDQUFDLFdBQVc7QUFDdEMsd0JBQUksRUFBRSxlQUFlLElBQUksSUFBSSxJQUFJLGVBQWUsQ0FBQyxRQUFRLEtBQUssT0FBTztBQUNyRSwrQkFBVyxFQUFFLElBQUksQ0FBQyxXQUFXO2lCQUNoQyxDQUFDLENBQUM7YUFDTjs7QUFFRCxnQkFBUTttQkFBQSxrQkFBQyxRQUFRLEVBQUU7O0FBRWYsb0JBQUksUUFBUSxDQUFDLFFBQVEsRUFBRTtBQUNuQix3QkFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUMxQzs7Ozs7QUFLRCxvQkFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDOUI7O0FBRUQsb0JBQVk7bUJBQUEsc0JBQUMsT0FBTyxFQUFFO0FBQ2xCLG9CQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDO0FBQ25CLHFCQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDbkQsMkJBQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlCLHdCQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUN2QjthQUNKOztBQUVELHlCQUFpQjttQkFBQSwyQkFBQyxPQUFPLEVBQUU7QUFDdkIsb0JBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLG9CQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QixvQkFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hDLG9CQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQzFCOztBQUVELG1CQUFXO21CQUFBLHFCQUFDLE9BQU8sRUFBRTtBQUNqQixvQkFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsb0JBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLG9CQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQzNCOztBQUVELHdCQUFnQjttQkFBQSwwQkFBQyxJQUFJLEVBQUU7O0FBRW5CLG9CQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDZix3QkFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUMzQzs7QUFFRCxvQkFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3pDOztBQVNELHFCQUFhOzs7Ozs7Ozs7bUJBQUEsdUJBQUMsSUFBSSxFQUFFO0FBQ2hCLG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3Qjs7QUFFRCx1QkFBZTttQkFBQSx5QkFBQyxJQUFJLEVBQUU7QUFDbEIsb0JBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDM0M7O0FBRUQsNEJBQW9CO21CQUFBLDhCQUFDLElBQUksRUFBRTtBQUN2QixvQkFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsb0JBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RCLG9CQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsb0JBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDMUI7O0FBRUQsc0JBQWM7bUJBQUEsd0JBQUMsSUFBSSxFQUFFOzs7O0FBRWpCLG9CQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsRUFBSTtBQUFFLDBCQUFLLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQUUsQ0FBQyxDQUFDO0FBQzlELG9CQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMzQjs7O0FBbEdNLGlCQUFTO21CQUFBLG1CQUFDLElBQUksRUFBRTtBQUNuQixvQkFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUN6Qix1QkFDSSxRQUFRLEtBQUssTUFBTSxDQUFDLFVBQVUsSUFDOUIsUUFBUSxLQUFLLE1BQU0sQ0FBQyxhQUFhLElBQ2pDLFFBQVEsS0FBSyxNQUFNLENBQUMsWUFBWSxJQUNoQyxRQUFRLEtBQUssTUFBTSxDQUFDLGFBQWEsSUFDakMsUUFBUSxLQUFLLE1BQU0sQ0FBQyxXQUFXLElBQy9CLFFBQVEsS0FBSyxNQUFNLENBQUMsaUJBQWlCLENBQ3ZDO2FBQ0w7Ozs7V0FYZ0IsY0FBYztHQUFTLFNBQVMsQ0FBQyxPQUFPOztpQkFBeEMsY0FBYyIsImZpbGUiOiJwYXR0ZXJuLXZpc2l0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFN5bnRheCB9IGZyb20gJ2VzdHJhdmVyc2UnO1xuaW1wb3J0IGVzcmVjdXJzZSBmcm9tICdlc3JlY3Vyc2UnO1xuXG5mdW5jdGlvbiBnZXRMYXN0KHhzKSB7XG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdHRlcm5WaXNpdG9yIGV4dGVuZHMgZXNyZWN1cnNlLlZpc2l0b3Ige1xuICAgIHN0YXRpYyBpc1BhdHRlcm4obm9kZSkge1xuICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybiB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5BcnJheVBhdHRlcm4gfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTeW50YXguU3ByZWFkRWxlbWVudCB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5SZXN0RWxlbWVudCB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVyblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHJvb3RQYXR0ZXJuLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3RQYXR0ZXJuID0gcm9vdFBhdHRlcm47XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzID0gW107XG4gICAgICAgIHRoaXMucmVzdEVsZW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgSWRlbnRpZmllcihwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXN0RWxlbWVudCA9IGdldExhc3QodGhpcy5yZXN0RWxlbWVudHMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHBhdHRlcm4sIHtcbiAgICAgICAgICAgIHRvcExldmVsOiBwYXR0ZXJuID09PSB0aGlzLnJvb3RQYXR0ZXJuLFxuICAgICAgICAgICAgcmVzdDogbGFzdFJlc3RFbGVtZW50ICE9IG51bGwgJiYgbGFzdFJlc3RFbGVtZW50LmFyZ3VtZW50ID09PSBwYXR0ZXJuLFxuICAgICAgICAgICAgYXNzaWdubWVudHM6IHRoaXMuYXNzaWdubWVudHNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29tcHV0ZWQgcHJvcGVydHkncyBrZXkgaXMgYSByaWdodCBoYW5kIG5vZGUuXG4gICAgICAgIGlmIChwcm9wZXJ0eS5jb21wdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5yaWdodEhhbmROb2Rlcy5wdXNoKHByb3BlcnR5LmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIHNob3J0aGFuZCwgaXRzIGtleSBpcyBzYW1lIGFzIGl0cyB2YWx1ZS5cbiAgICAgICAgLy8gSWYgaXQncyBzaG9ydGhhbmQgYW5kIGhhcyBpdHMgZGVmYXVsdCB2YWx1ZSwgaXRzIGtleSBpcyBzYW1lIGFzIGl0cyB2YWx1ZS5sZWZ0ICh0aGUgdmFsdWUgaXMgQXNzaWdubWVudFBhdHRlcm4pLlxuICAgICAgICAvLyBJZiBpdCdzIG5vdCBzaG9ydGhhbmQsIHRoZSBuYW1lIG9mIG5ldyB2YXJpYWJsZSBpcyBpdHMgdmFsdWUncy5cbiAgICAgICAgdGhpcy52aXNpdChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgfVxuXG4gICAgQXJyYXlQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIGksIGl6LCBlbGVtZW50O1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHBhdHRlcm4uZWxlbWVudHMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHBhdHRlcm4uZWxlbWVudHNbaV07XG4gICAgICAgICAgICB0aGlzLnZpc2l0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybikge1xuICAgICAgICB0aGlzLmFzc2lnbm1lbnRzLnB1c2gocGF0dGVybik7XG4gICAgICAgIHRoaXMudmlzaXQocGF0dGVybi5sZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodEhhbmROb2Rlcy5wdXNoKHBhdHRlcm4ucmlnaHQpO1xuICAgICAgICB0aGlzLmFzc2lnbm1lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIFJlc3RFbGVtZW50KHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5yZXN0RWxlbWVudHMucHVzaChwYXR0ZXJuKTtcbiAgICAgICAgdGhpcy52aXNpdChwYXR0ZXJuLmFyZ3VtZW50KTtcbiAgICAgICAgdGhpcy5yZXN0RWxlbWVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIC8vIENvbXB1dGVkIHByb3BlcnR5J3Mga2V5IGlzIGEgcmlnaHQgaGFuZCBub2RlLlxuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5yaWdodEhhbmROb2Rlcy5wdXNoKG5vZGUucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBvYmplY3QgaXMgb25seSByZWFkLCB3cml0ZSB0byBpdHMgcHJvcGVydHkuXG4gICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChub2RlLm9iamVjdCk7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBGb3JJblN0YXRlbWVudC5sZWZ0IGFuZCBBc3NpZ25tZW50RXhwcmVzc2lvbi5sZWZ0IGFyZSBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uLlxuICAgIC8vIEJ5IHNwZWMsIExlZnRIYW5kU2lkZUV4cHJlc3Npb24gaXMgUGF0dGVybiBvciBNZW1iZXJFeHByZXNzaW9uLlxuICAgIC8vICAgKHNlZSBhbHNvOiBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9wdWxsLzIwI2lzc3VlY29tbWVudC03NDU4NDc1OClcbiAgICAvLyBCdXQgZXNwcmVlIDIuMCBhbmQgZXNwcmltYSAyLjAgcGFyc2UgdG8gQXJyYXlFeHByZXNzaW9uLCBPYmplY3RFeHByZXNzaW9uLCBldGMuLi5cbiAgICAvL1xuXG4gICAgU3ByZWFkRWxlbWVudChub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5hcmd1bWVudCk7XG4gICAgfVxuXG4gICAgQXJyYXlFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS5lbGVtZW50cy5mb3JFYWNoKHRoaXMudmlzaXQsIHRoaXMpO1xuICAgIH1cblxuICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUubGVmdCk7XG4gICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChub2RlLnJpZ2h0KTtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cy5wb3AoKTtcbiAgICB9XG5cbiAgICBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgcmlnaHQgaGFuZCBub2Rlcy5cbiAgICAgICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChhID0+IHsgdGhpcy5yaWdodEhhbmROb2Rlcy5wdXNoKGEpOyB9KTtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmNhbGxlZSk7XG4gICAgfVxufVxuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/lib/pattern-visitor.js\n ** module id = 130\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/lib/pattern-visitor.js?");

/***/ },
/* 131 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"escope@^3.3.0\",\n\t\t\t\"/home/cs/Projects/rlet\"\n\t\t]\n\t],\n\t\"_from\": \"escope@>=3.3.0 <4.0.0\",\n\t\"_id\": \"escope@3.3.0\",\n\t\"_inCache\": true,\n\t\"_location\": \"/escope\",\n\t\"_nodeVersion\": \"4.1.1\",\n\t\"_npmUser\": {\n\t\t\"email\": \"utatane.tea@gmail.com\",\n\t\t\"name\": \"constellation\"\n\t},\n\t\"_npmVersion\": \"2.14.4\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"escope\",\n\t\t\"raw\": \"escope@^3.3.0\",\n\t\t\"rawSpec\": \"^3.3.0\",\n\t\t\"scope\": null,\n\t\t\"spec\": \">=3.3.0 <4.0.0\",\n\t\t\"type\": \"range\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/escope/-/escope-3.3.0.tgz\",\n\t\"_shasum\": \"6201c97285c2c13643afe4453b58de64481aa1a4\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"escope@^3.3.0\",\n\t\"_where\": \"/home/cs/Projects/rlet\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/estools/escope/issues\"\n\t},\n\t\"dependencies\": {\n\t\t\"es6-map\": \"^0.1.2\",\n\t\t\"es6-weak-map\": \"^2.0.1\",\n\t\t\"esrecurse\": \"^3.1.1\",\n\t\t\"estraverse\": \"^4.1.1\"\n\t},\n\t\"description\": \"ECMAScript scope analyzer\",\n\t\"devDependencies\": {\n\t\t\"acorn\": \"^2.5.2\",\n\t\t\"babel\": \"^4.7.12\",\n\t\t\"browserify\": \"^12.0.1\",\n\t\t\"chai\": \"^3.4.0\",\n\t\t\"coffee-script\": \"^1.10.0\",\n\t\t\"espree\": \"^2.2.5\",\n\t\t\"esprima\": \"^2.7.0\",\n\t\t\"gulp\": \"^3.9.0\",\n\t\t\"gulp-babel\": \"^4.0.0\",\n\t\t\"gulp-bump\": \"^1.0.0\",\n\t\t\"gulp-coffee\": \"^2.3.1\",\n\t\t\"gulp-eslint\": \"^1.0.0\",\n\t\t\"gulp-espower\": \"^1.0.1\",\n\t\t\"gulp-filter\": \"^3.0.1\",\n\t\t\"gulp-git\": \"^1.6.0\",\n\t\t\"gulp-mocha\": \"^2.1.3\",\n\t\t\"gulp-plumber\": \"^1.0.1\",\n\t\t\"gulp-sourcemaps\": \"^1.6.0\",\n\t\t\"gulp-tag-version\": \"^1.3.0\",\n\t\t\"jsdoc\": \"^3.3.3\",\n\t\t\"lazypipe\": \"^1.0.1\",\n\t\t\"minimist\": \"^1.2.0\",\n\t\t\"vinyl-source-stream\": \"^1.1.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"6201c97285c2c13643afe4453b58de64481aa1a4\",\n\t\t\"tarball\": \"http://registry.npmjs.org/escope/-/escope-3.3.0.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.4.0\"\n\t},\n\t\"gitHead\": \"a3402c3e5c04f4e3dc15c88fd2d7ce8608d26ba7\",\n\t\"homepage\": \"http://github.com/estools/escope\",\n\t\"installable\": true,\n\t\"license\": \"BSD-2-Clause\",\n\t\"main\": \"lib/index.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"constellation\",\n\t\t\t\"email\": \"utatane.tea@gmail.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"michaelficarra\",\n\t\t\t\"email\": \"npm@michael.ficarra.me\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"nzakas\",\n\t\t\t\"email\": \"nicholas@nczconsulting.com\"\n\t\t}\n\t],\n\t\"name\": \"escope\",\n\t\"optionalDependencies\": {},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/estools/escope.git\"\n\t},\n\t\"scripts\": {\n\t\t\"jsdoc\": \"jsdoc src/*.js README.md\",\n\t\t\"lint\": \"gulp lint\",\n\t\t\"test\": \"gulp travis\",\n\t\t\"unit-test\": \"gulp test\"\n\t},\n\t\"version\": \"3.3.0\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escope/package.json\n ** module id = 131\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/escope/package.json?");

/***/ },
/* 132 */
/***/ function(module, exports) {

	eval("module.exports = \"let quoteSyntax = macro {\\n    function(stx) {\\n        var name_stx = stx[0];\\n\\n        if (!(stx[1] && stx[1].token && stx[1].token.inner)) {\\n            throwSyntaxError(\\\"macro\\\", \\\"Macro `quoteSyntax` could not be matched\\\" , stx[1]);\\n        }\\n\\n        var res = [\\n            makeIdent(\\\"#quoteSyntax\\\", null),\\n            stx[1].expose()\\n        ];\\n\\n        return {\\n            result: res,\\n            rest: stx.slice(2)\\n        };\\n    }\\n}\\nexport quoteSyntax\\n\\nlet syntax = macro {\\n    function(stx) {\\n        var name_stx = stx[0];\\n        var here = quoteSyntax{here};\\n        var takeLineContext = patternModule.takeLineContext;\\n        var takeLine = patternModule.takeLine;\\n        var mod = makeIdent(\\\"patternModule\\\", here);\\n\\n        if (!(stx[1] && stx[1].token && stx[1].token.inner)) {\\n            throwSyntaxError(\\\"macro\\\", \\\"Macro `syntax` could not be matched\\\", stx[1]);\\n        }\\n\\n        var res = [mod,\\n                   makePunc(\\\".\\\", here),\\n                   makeIdent(\\\"transcribe\\\", here),\\n                   makeDelim(\\\"()\\\", [\\n                       makeIdent(\\\"#quoteSyntax\\\", here),\\n                       stx[1].expose(),\\n                       makePunc(\\\",\\\", here),\\n                       // breaking hygiene to capture `name_stx`, `match`, and\\n                       // `patternEnv` inside the syntaxCase macro\\n                       makeIdent(\\\"name_stx\\\", name_stx),\\n                       makePunc(\\\",\\\", here),\\n                       makeIdent(\\\"match\\\", name_stx),\\n                       makePunc(\\\".\\\", here),\\n                       makeIdent(\\\"patternEnv\\\", name_stx)\\n                   ], here)];\\n\\n\\n        return {\\n            result: res,\\n            rest: stx.slice(2)\\n        };\\n    }\\n}\\nexport syntax\\n\\nmacro # {\\n    function (stx) {\\n        return {\\n            // breaking hygiene to capture inside syntaxCase\\n            result: [makeIdent(\\\"syntax\\\", stx[0]),\\n                     stx[1]],\\n            rest: stx.slice(2)\\n        }\\n    }\\n}\\nexport #\\n\\n\\nlet syntaxCase = macro {\\n    function(stx, context) {\\n        var name_stx = stx[0];\\n        var here = quoteSyntax{here};\\n\\n        if (!(stx[1] && stx[1].token && stx[1].token.inner) ||\\n            !(stx[2] && stx[2].token && stx[2].token.inner)) {\\n            throwSyntaxError(\\\"macro\\\", \\\"Macro `syntaxCase` could not be matched\\\" , stx[1]);\\n        }\\n\\n        var arg_stx = stx[1].expose().token.inner;\\n        var cases_stx = stx[2].expose().token.inner;\\n\\n        var Token = parser.Token;\\n        var assert = parser.assert;\\n        var loadPattern = patternModule.loadPattern;\\n        var takeLine = patternModule.takeLine;\\n        var matchPatterns = matchPatterns;\\n\\n        function makeFunc(params, body) {\\n            return [\\n                makeKeyword(\\\"function\\\", here),\\n                makeDelim(\\\"()\\\", params, here),\\n                makeDelim(\\\"{}\\\", body, here)\\n            ];\\n        }\\n\\n        function makeVarDef(id, expr) {\\n            return [\\n                makeKeyword(\\\"var\\\", here),\\n                makeIdent(id, name_stx),\\n                makePunc(\\\"=\\\", here)\\n            ].concat(expr, makePunc(\\\";\\\", here));\\n        }\\n\\n        function makeAssign(id, expr) {\\n          return [\\n            makeIdent(id, name_stx),\\n            makePunc(\\\"=\\\", here)\\n          ].concat(expr, makePunc(\\\";\\\", here));\\n        }\\n\\n        function cloneSyntax(stx) {\\n            var clone = _.extend({}, stx, { token: _.clone(stx.token) });\\n            if (clone.token.inner) {\\n                clone.token.inner = clone.token.inner.map(cloneSyntax);\\n            }\\n            return clone;\\n        }\\n\\n        if (cases_stx.length == 0) {\\n            throw new Error(\\\"Must have at least one case\\\")\\n        }\\n\\n        var cases = [];\\n\\n        for (var i = 0; i < cases_stx.length; i += 4) {\\n            var caseKwd = cases_stx[i];\\n            var isInfix = cases_stx[i + 1].token.value === \\\"infix\\\";\\n            if (isInfix) {\\n                i += 1;\\n            }\\n            var casePattern = cases_stx[i + 1];\\n            var caseArrow = cases_stx[i + 2];\\n            var caseBody = cases_stx[i + 3];\\n\\n            if (!(caseKwd && caseKwd.token && caseKwd.token.value === \\\"case\\\")) {\\n                throw new Error(\\\"expecting case keyword in syntax case\\\");\\n            }\\n            if (!(casePattern && casePattern.token && casePattern.token.value === \\\"{}\\\")) {\\n                throw new Error(\\\"expecting a pattern surrounded by {} in syntax case\\\");\\n            }\\n            if (!(caseArrow && caseArrow.token && caseArrow.token.value === \\\"=>\\\")) {\\n                throw new Error(\\\"expecting an arrow separating pattern from body in syntax case\\\");\\n            }\\n            if (!(caseBody && caseBody.token && caseBody.token.value === \\\"{}\\\")) {\\n                throw new Error(\\\"expecting a body surrounded by {} in syntax case\\\");\\n            }\\n\\n            // If infix, loop through the pattern separating the lhs and rhs.\\n            if (isInfix) {\\n                var pattern = cloneSyntax(casePattern).expose().token.inner;\\n                var lhs = [];\\n                var rhs = [];\\n                var separator = null;\\n                for (var j = 0; j < pattern.length; j++) {\\n                    if (separator) {\\n                        rhs.push(pattern[j]);\\n                    } else {\\n                        if (pattern[j].token.type === parser.Token.Punctuator &&\\n                            pattern[j].token.value === '|') {\\n                            separator = pattern[j];\\n                        } else {\\n                            lhs.push(pattern[j]);\\n                        }\\n                    }\\n                }\\n                if (!separator) {\\n                    throwSyntaxError(\\\"syntaxCase\\\", \\\"Infix macros require a `|` separator\\\", casePattern);\\n                }\\n                cases.push({\\n                    lookbehind: loadPattern(lhs, true),\\n                    pattern: loadPattern(rhs),\\n                    body: caseBody.expose().token.inner\\n                });\\n            } else {\\n                cases.push({\\n                    lookbehind: [],\\n                    pattern: loadPattern(cloneSyntax(casePattern).expose().token.inner),\\n                    body: caseBody.expose().token.inner\\n                });\\n            }\\n        }\\n\\n        function patternsToObject(pats) {\\n            if (!pats.length) {\\n                return makeDelim(\\\"[]\\\", [], here);\\n            }\\n\\n            var freshId = __fresh();\\n            context.patternMap.set(freshId, pats);\\n\\n            return [\\n                makeIdent(\\\"getPattern\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeValue(freshId, here)\\n                ], here)\\n            ];\\n        }\\n\\n        function makeMatch(caseObj) {\\n            var lhs = makeAssign(\\\"lhs\\\", patternsToObject(caseObj.lookbehind));\\n            var rhs = makeAssign(\\\"rhs\\\", patternsToObject(caseObj.pattern));\\n\\n            var lhsMatch = makeAssign(\\\"lhsMatch\\\", [\\n                makeIdent(\\\"patternModule\\\", here),\\n                makePunc(\\\".\\\", here),\\n                makeIdent(\\\"matchLookbehind\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeIdent(\\\"lhs\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"prevStx\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"prevTerms\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"context\\\", name_stx)\\n                ], here)\\n            ]);\\n\\n            var rhsMatch = makeAssign(\\\"rhsMatch\\\", [\\n                makeIdent(\\\"patternModule\\\", here),\\n                makePunc(\\\".\\\", here),\\n                makeIdent(\\\"matchPatterns\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeIdent(\\\"rhs\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"arg\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"context\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeValue(true, here)\\n                ], here)\\n            ]);\\n\\n            var mergeMatch = makeAssign(\\\"match\\\", [\\n                makeIdent(\\\"mergeMatches\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeIdent(\\\"rhsMatch\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                ].concat(\\n                    makeIdent(\\\"mergeMatches\\\", here),\\n                    makeDelim(\\\"()\\\", [\\n                        makeIdent(\\\"lhsMatch\\\", name_stx),\\n                        makePunc(\\\",\\\", here),\\n                        makeIdent(\\\"parentMatch\\\", name_stx)\\n                    ], here)\\n                ), here)\\n            ]);\\n\\n            return lhs.concat(lhsMatch, [\\n                makeKeyword(\\\"if\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeIdent(\\\"lhsMatch\\\", name_stx),\\n                    makePunc(\\\".\\\", here),\\n                    makeIdent(\\\"success\\\", here)\\n                ], here),\\n                makeDelim(\\\"{}\\\", rhs.concat(rhsMatch, [\\n                    makeKeyword(\\\"if\\\", here),\\n                    makeDelim(\\\"()\\\", [\\n                        makeIdent(\\\"rhsMatch\\\", name_stx),\\n                        makePunc(\\\".\\\", here),\\n                        makeIdent(\\\"success\\\", here)\\n                    ], here),\\n                    makeDelim(\\\"{}\\\", mergeMatch.concat(makeTranscribe(caseObj)), here)\\n                ]), here)\\n            ]);\\n        }\\n\\n        function makeTranscribe(caseObj) {\\n            // applyMarkToPatternEnv (context.mark, match.patternEnv);\\n            var applyPreMark = [\\n                makeIdent(\\\"applyMarkToPatternEnv\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makeIdent(\\\"context\\\", name_stx),\\n                    makePunc(\\\".\\\", here),\\n                    makeIdent(\\\"mark\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"match\\\", name_stx),\\n                    makePunc(\\\".\\\", here),\\n                    makeIdent(\\\"patternEnv\\\", name_stx)\\n                ], here),\\n                makePunc(\\\";\\\", here)\\n            ];\\n            // var res = (function() { <caseObj.body> })();\\n            var runBody = makeVarDef(\\\"res\\\", [\\n                makeDelim(\\\"()\\\", makeFunc([], caseObj.body), here),\\n                makeDelim(\\\"()\\\", [], here)\\n            ]);\\n            // if (!Array.isArray(res)) { throwSyntaxError(\\\"macro\\\", \\\"Macro must return a syntax array\\\", stx); }\\n            var errHandling = [\\n                makeKeyword(\\\"if\\\", here),\\n                makeDelim(\\\"()\\\", [\\n                    makePunc(\\\"!\\\", here),\\n                    makeIdent(\\\"Array\\\", here),\\n                    makePunc(\\\".\\\", here),\\n                    makeIdent(\\\"isArray\\\", here),\\n                    makeDelim(\\\"()\\\", [\\n                        makeIdent(\\\"res\\\", name_stx)\\n                    ], here)\\n                ], here),\\n                makeDelim(\\\"{}\\\", [\\n                    makeIdent(\\\"throwSyntaxError\\\", here),\\n                    makeDelim(\\\"()\\\", [\\n                        makeValue(\\\"macro\\\", here),\\n                        makePunc(\\\",\\\", here),\\n                        makeValue(\\\"Macro must return a syntax array\\\", here),\\n                        makePunc(\\\",\\\", here),\\n                        makeIdent(\\\"stx\\\", name_stx)\\n                    ], here)\\n                ], here)\\n            ];\\n            // res = res.map(function(stx) { return stx.mark(context.mark); })\\n            var applyPostMark = [\\n                makeIdent(\\\"res\\\", name_stx),\\n                makePunc(\\\"=\\\", here),\\n                makeIdent(\\\"res\\\", name_stx),\\n                makePunc(\\\".\\\", here),\\n                makeIdent(\\\"map\\\", here),\\n                makeDelim(\\\"()\\\", makeFunc([makeIdent(\\\"stx\\\", here)], [\\n                        makeKeyword(\\\"return\\\", here),\\n                        makeIdent(\\\"stx\\\", here),\\n                        makePunc(\\\".\\\", here),\\n                        makeIdent(\\\"mark\\\", here),\\n                        makeDelim(\\\"()\\\", [\\n                            makeIdent(\\\"context\\\", name_stx),\\n                            makePunc(\\\".\\\", here),\\n                            makeIdent(\\\"mark\\\", here)\\n                        ], here)\\n                ]), here),\\n                makePunc(\\\";\\\", here)\\n            ];\\n            // return { result: res, rest: match.rest };\\n            var retResult = [\\n                makeKeyword(\\\"return\\\", here),\\n                makeDelim(\\\"{}\\\", [\\n                    makeIdent(\\\"result\\\", here), makePunc(\\\":\\\", here),\\n                    makeIdent(\\\"res\\\", name_stx),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"rest\\\", here), makePunc(\\\":\\\", here),\\n                    makeIdent(\\\"match\\\", name_stx), makePunc(\\\".\\\", here), makeIdent(\\\"rest\\\", here),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"prevStx\\\", here), makePunc(\\\":\\\", here),\\n                    makeIdent(\\\"lhsMatch\\\", name_stx), makePunc(\\\".\\\", here), makeIdent(\\\"prevStx\\\", here),\\n                    makePunc(\\\",\\\", here),\\n                    makeIdent(\\\"prevTerms\\\", here), makePunc(\\\":\\\", here),\\n                    makeIdent(\\\"lhsMatch\\\", name_stx), makePunc(\\\".\\\", here), makeIdent(\\\"prevTerms\\\", here)\\n                ], here)\\n            ];\\n            return applyPreMark.concat(runBody, errHandling, applyPostMark, retResult);\\n        }\\n\\n        var arg_def = makeVarDef(\\\"arg\\\", [makeIdent(\\\"stx\\\", name_stx)]);\\n        var name_def = makeVarDef(\\\"name_stx\\\", [\\n            makeIdent(\\\"arg\\\", name_stx),\\n            makeDelim(\\\"[]\\\", [makeValue(0, here)], here)\\n        ]);\\n        var match_defs = [\\n            makeKeyword('var', here),\\n            makeIdent('lhs', name_stx), makePunc(',', here),\\n            makeIdent('lhsMatch', name_stx), makePunc(',', here),\\n            makeIdent('rhs', name_stx), makePunc(',', here),\\n            makeIdent('rhsMatch', name_stx), makePunc(',', here),\\n            makeIdent('match', name_stx), makePunc(',', here),\\n            makeIdent('res', name_stx), makePunc(';', here),\\n        ];\\n\\n        var body = arg_def.concat(name_def, match_defs);\\n\\n        for (var i = 0; i < cases.length; i++) {\\n            body = body.concat(makeMatch(cases[i]));\\n        }\\n\\n        body = body.concat(quoteSyntax {\\n            throwSyntaxCaseError(\\\"Could not match any cases\\\");\\n        });\\n\\n        var res = makeFunc([\\n            makeIdent(\\\"stx\\\", name_stx),\\n            makePunc(\\\",\\\", here),\\n            makeIdent(\\\"context\\\", name_stx),\\n            makePunc(\\\",\\\", here),\\n            makeIdent(\\\"prevStx\\\", name_stx),\\n            makePunc(\\\",\\\", here),\\n            makeIdent(\\\"prevTerms\\\", name_stx),\\n            makePunc(\\\",\\\", here),\\n            makeIdent(\\\"parentMatch\\\", name_stx)\\n        ], body).concat([\\n            makeDelim(\\\"()\\\", arg_stx.concat([\\n                makePunc(\\\",\\\", here),\\n                makeKeyword(\\\"typeof\\\", here),\\n                makeIdent(\\\"match\\\", name_stx),\\n                makePunc(\\\"!==\\\", here),\\n                makeValue(\\\"undefined\\\", here),\\n                makePunc(\\\"?\\\", here),\\n                makeIdent(\\\"match\\\", name_stx),\\n                makePunc(\\\":\\\", here),\\n                makeDelim(\\\"{}\\\", [], here)\\n            ]), here)\\n        ]);\\n\\n        return {\\n            result: res,\\n            rest: stx.slice(3)\\n        }\\n    }\\n}\\nexport syntaxCase\\n\\n\\nlet macro = macro {\\n    function(stx) {\\n        var name_stx = stx[0];\\n        var here = quoteSyntax{here};\\n        var mac_name_stx;\\n        var body_inner_stx;\\n        var body_stx;\\n        var takeLine = patternModule.takeLine;\\n        var makeIdentityRule = patternModule.makeIdentityRule;\\n        var rest;\\n\\n        if (stx[1] && stx[1].token.type === parser.Token.Delimiter &&\\n            stx[1].token.value === \\\"{}\\\") {\\n            mac_name_stx = null;\\n            body_stx = stx[1];\\n            body_inner_stx = stx[1].expose().token.inner;\\n            rest = stx.slice(2);\\n        } else {\\n            mac_name_stx = [];\\n            mac_name_stx.push(stx[1]);\\n            body_stx = stx[2];\\n            body_inner_stx = stx[2].expose().token.inner;\\n            rest = stx.slice(3);\\n        }\\n\\n        function makeFunc(params, body) {\\n            return [\\n                makeKeyword(\\\"function\\\", here),\\n                makeDelim(\\\"()\\\", params, here),\\n                makeDelim(\\\"{}\\\", body, here)\\n            ];\\n        }\\n\\n        function translateRule(pattern, def, isInfix) {\\n            var translatedPatt;\\n            // When infix, we need to loop through the body and make sure there\\n            // is a separator to distinguish the lhs and rhs.\\n            if (isInfix) {\\n                translatedPatt = [];\\n                for (var i = 0, len = pattern.length; i < len; i++) {\\n                    translatedPatt.push(pattern[i]);\\n                    if (pattern[i].token.type === parser.Token.Punctuator &&\\n                        pattern[i].token.value === '|') {\\n                        translatedPatt.push(makeIdent(\\\"_\\\", here));\\n                        translatedPatt = translatedPatt.concat([makeIdent(\\\"$\\\", here),\\n                                                                makeDelim(\\\"()\\\", pattern.slice(i + 1), here)]);\\n                        break;\\n                    }\\n                }\\n            } else {\\n                translatedPatt = [makeIdent(\\\"_\\\", here),\\n                                  // wrapping the patterns in a group to disambiguate\\n                                  // `_ (foo) ...`\\n                                  // since the `(foo)` would be interpreted as a separator\\n                                  makeIdent(\\\"$\\\", here),\\n                                  makeDelim(\\\"()\\\", pattern, here)];\\n            }\\n\\n            var translatedDef = [\\n                makeKeyword(\\\"return\\\", here),\\n                takeLine(here[0], makeIdent(\\\"syntax\\\", name_stx)),\\n                makeDelim(\\\"{}\\\", def, here)\\n            ];\\n\\n            return [makeIdent(\\\"case\\\", here)].concat(\\n                isInfix ? makeIdent(\\\"infix\\\", here) : [],\\n                makeDelim(\\\"{}\\\", translatedPatt, here),\\n                makePunc(\\\"=>\\\", here),\\n                makeDelim(\\\"{}\\\", translatedDef, here)\\n            );\\n        }\\n\\n        if (body_inner_stx[0] && body_inner_stx[0].token.value === \\\"function\\\") {\\n\\n            if (mac_name_stx) {\\n                var res = [makeIdent(\\\"macro\\\", here)].concat(mac_name_stx).concat(body_stx)\\n                return {\\n                    result: res,\\n                    rest: rest\\n                };\\n            } else {\\n                var res = [\\n                    makeIdent(\\\"macro\\\", here),\\n                    body_stx\\n                ];\\n                return {\\n                    result: res,\\n                    rest: rest\\n                };\\n            }\\n\\n        }\\n        \\n        var rules = [];\\n        var decl = body_inner_stx[0];\\n        \\n        if(decl) {\\n            \\n            var stxIdx = -4;\\n            var stxLen = body_inner_stx.length;\\n            var rulesLen = 0;\\n            \\n            while((stxIdx += 4) < stxLen) {\\n                \\n                decl = body_inner_stx[stxIdx];\\n                \\n                var def_stx, idRule;\\n                \\n                var infix = body_inner_stx[stxIdx + 1];\\n                var isInfix = !!(infix && infix.token && infix.token.value === \\\"infix\\\");\\n                var infixOffset = Number(isInfix);\\n                stxIdx += infixOffset;\\n                \\n                var def_pattern = body_inner_stx[stxIdx + 1];\\n                var def_arrow = body_inner_stx[stxIdx + 2];\\n                var def_body = body_inner_stx[stxIdx + 3];\\n                \\n                if(decl.token.value === \\\"rule\\\") {\\n                    \\n                    if(def_pattern && def_arrow && def_arrow.token.value === \\\"=>\\\" && def_body) {\\n                        def_stx = translateRule(def_pattern.expose().token.inner,\\n                                                def_body.expose().token.inner,\\n                                                isInfix);\\n                    } else if(def_pattern) {\\n                        idRule = makeIdentityRule(def_pattern.token.inner, isInfix, def_pattern);\\n                        def_stx = translateRule(idRule.pattern, idRule.body, isInfix);\\n                        stxIdx -= 2;\\n                    } else if(!def_stx) {\\n                        throwSyntaxError(\\\"macro\\\", \\\"Macro `macro` could not be matched\\\" , def_arrow);\\n                    }\\n                    \\n                    decl = def_stx[0];\\n                    infix = def_stx[1];\\n                    def_pattern = def_stx[1 + infixOffset];\\n                    def_arrow = def_stx[2 + infixOffset];\\n                    def_body = def_stx[3 + infixOffset];\\n                    \\n                    def_stx = null;\\n                } else if(decl.token.value !== \\\"case\\\") {\\n                    throwSyntaxError(\\\"macro\\\", \\\"Macro `macro` could not be matched\\\" , def_arrow);\\n                }\\n                \\n                rules[rulesLen++] = decl;\\n                if(isInfix) {\\n                    rules[rulesLen++] = infix;\\n                    rules[rulesLen++] = def_pattern;\\n                    rules[rulesLen++] = def_arrow;\\n                    rules[rulesLen++] = def_body;\\n                } else {\\n                    rules[rulesLen++] = def_pattern;\\n                    rules[rulesLen++] = def_arrow;\\n                    rules[rulesLen++] = def_body;\\n                }\\n            }\\n            \\n            rules = makeDelim(\\\"{}\\\", rules, here);\\n        } else {\\n            rules = body_stx;\\n        }\\n\\n        var stxSyntaxCase = takeLine(here[0], makeIdent(\\\"syntaxCase\\\", name_stx));\\n        var res = mac_name_stx\\n            ? [makeIdent(\\\"macro\\\", here)].concat(mac_name_stx)\\n            : [makeIdent(\\\"macro\\\", here)];\\n        res = res.concat(makeDelim(\\\"{}\\\", makeFunc([makeIdent(\\\"stx\\\", name_stx),\\n                                                   makePunc(\\\",\\\", here),\\n                                                   makeIdent(\\\"context\\\", name_stx),\\n                                                   makePunc(\\\",\\\", here),\\n                                                   makeIdent(\\\"prevStx\\\", name_stx),\\n                                                   makePunc(\\\",\\\", here),\\n                                                   makeIdent(\\\"prevTerms\\\", name_stx)],\\n                                                   [makeKeyword(\\\"return\\\", here),\\n                                                    stxSyntaxCase,\\n                                                    makeDelim(\\\"()\\\", [makeIdent(\\\"stx\\\", name_stx),\\n                                                                     makePunc(\\\",\\\", here),\\n                                                                     makeIdent(\\\"context\\\", name_stx),\\n                                                                     makePunc(\\\",\\\", here),\\n                                                                     makeIdent(\\\"prevStx\\\", name_stx),\\n                                                                     makePunc(\\\",\\\", here),\\n                                                                     makeIdent(\\\"prevTerms\\\", name_stx)], here),\\n                                                    rules]),\\n                                    here));\\n\\n\\n        return {\\n            result: res,\\n            rest: rest\\n        }\\n    }\\n}\\nexport macro;\\n\\nmacro withSyntax_done {\\n    case { _ $ctx ($vars ...) {$rest ...} } => {\\n        var ctx = #{ $ctx };\\n        var here = #{ here };\\n        var vars = #{ $vars ... };\\n        var rest = #{ $rest ... };\\n\\n        var res = [];\\n\\n        for (var i = 0; i < vars.length; i += 3) {\\n            var name = vars[i];\\n            var repeat = !!vars[i + 1].token.inner.length;\\n            var rhs = vars[i + 2];\\n\\n            if (repeat) {\\n                res.push(\\n                    makeIdent('match', ctx),\\n                    makePunc('.', here),\\n                    makeIdent('patternEnv', here),\\n                    makeDelim('[]', [makeValue(name.token.value, here)], here),\\n                    makePunc('=', here),\\n                    makeDelim('{}', [\\n                        makeIdent('level', here), makePunc(':', here), makeValue(1, here), makePunc(',', here),\\n                        makeIdent('match', here), makePunc(':', here), makeDelim('()', #{\\n                            (function(exp) {\\n                                return exp.length\\n                                    ? exp.map(function(t) { return { level: 0, match: [t] } })\\n                                    : [{ level: 0, match: [] }];\\n                            })\\n                        }, here), makeDelim('()', [rhs], here)\\n                    ], here),\\n                    makePunc(';', here)\\n                );\\n            } else {\\n                res.push(\\n                    makeIdent('match', ctx),\\n                    makePunc('.', here),\\n                    makeIdent('patternEnv', here),\\n                    makeDelim('[]', [makeValue(name.token.value, here)], here),\\n                    makePunc('=', here),\\n                    makeDelim('{}', [\\n                        makeIdent('level', here), makePunc(':', here), makeValue(0, here), makePunc(',', here),\\n                        makeIdent('match', here), makePunc(':', here), rhs\\n                    ], here),\\n                    makePunc(';', here)\\n                );\\n            }\\n        }\\n\\n        res = res.concat(rest);\\n        res = [\\n            makeDelim(\\\"()\\\", [\\n                makeKeyword(\\\"function\\\", here),\\n                makeDelim(\\\"()\\\", [makeIdent(\\\"match\\\", ctx)], here),\\n                makeDelim(\\\"{}\\\", res, here)\\n            ], here),\\n            makeDelim(\\\"()\\\", [\\n                makeIdent(\\\"patternModule\\\", here),\\n                makePunc(\\\".\\\", here),\\n                makeIdent(\\\"cloneMatch\\\", here),\\n                makeDelim(\\\"()\\\", [makeIdent(\\\"match\\\", ctx)], here)\\n            ], here)\\n        ];\\n\\n        return res;\\n    }\\n}\\n\\nmacro withSyntax_bind {\\n    rule { $name:ident $[...] = $rhs:expr } => {\\n        $name (true) $rhs\\n    }\\n    rule { $name:ident = $rhs:expr } => {\\n        $name () $rhs\\n    }\\n}\\n\\nlet withSyntax = macro {\\n    case { $name ($binders:withSyntax_bind (,) ...) { $body ... } } => {\\n        return #{\\n            withSyntax_done $name ($binders ...) { $body ... }\\n        }\\n    }\\n    case { $name ($binders:withSyntax_bind (,) ...) $quote:[#] { $body ... } } => {\\n        return #{\\n            withSyntax_done $name ($binders ...) {\\n                return $quote { $body ... }\\n            }\\n        }\\n    }\\n}\\nexport withSyntax;\\n\\nmacro letstx_bind {\\n    rule { $name:ident = $rhs:expr , $more:letstx_bind } => {\\n        $name () $rhs $more\\n    }\\n    rule { $name:ident = $rhs:expr ;... letstx $more:letstx_bind } => {\\n        $name () $rhs $more\\n    }\\n    rule { $name:ident = $rhs:expr ;... } => {\\n        $name () $rhs\\n    }\\n    rule { $name:ident $[...] = $rhs:expr , $more:letstx_bind } => {\\n        $name (true) $rhs $more\\n    }\\n    rule { $name:ident $[...] = $rhs:expr ;... letstx $more:letstx_bind } => {\\n        $name (true) $rhs $more\\n    }\\n    rule { $name:ident $[...] = $rhs:expr ;... } => {\\n        $name (true) $rhs\\n    }\\n}\\n\\nlet letstx = macro {\\n    case { $name $binders:letstx_bind $rest ... } => {\\n        return #{\\n            return withSyntax_done $name ($binders) { $rest ... }\\n        }\\n    }\\n}\\nexport letstx;\\n\\n\\nmacro macroclass {\\n    rule { $name:ident { $decls:macroclass_decl ... } } => {\\n        macro $name {\\n            function (stx, context, prevStx, prevTerms) {\\n                var name_stx = stx[0];\\n                var match;\\n                macroclass_create $name stx context match ($decls ...)\\n            }\\n        }\\n    }\\n}\\n\\nmacro macroclass_decl {\\n    rule { $kw:[name] = $name:lit ;... } => {\\n        ($kw $name)\\n    }\\n    rule { $kw:[pattern] { $mods:macroclass_modifier ... } ;... } => {\\n        ($kw $mods ...)\\n    }\\n    rule { rule { $rule ... } ;... } => {\\n        (pattern (rule ($rule ...)))\\n    }\\n}\\n\\nmacro macroclass_modifier {\\n    rule { $kw:[name] = $name:lit ;... } => {\\n        ($kw $name)\\n    }\\n    rule { $kw:[rule] { $rule ... } ;... } => {\\n        ($kw ($rule ...))\\n    }\\n    rule { $kw:[with] $($lhs:macroclass_with_lhs = $rhs:macroclass_with_rhs) (,) ... } => {\\n        $(($kw ($lhs) ($rhs))) ...\\n    }\\n    rule { ; ;... } => { }\\n}\\n\\nmacro macroclass_with_lhs {\\n    rule { $name:ident $[...] }\\n    rule { $name:ident }\\n}\\n\\nmacro macroclass_with_rhs {\\n    rule { #{ $stx ... } }\\n    rule { $code:expr }\\n}\\n\\nmacro macroclass_create {\\n    function(stx, context, prevStx, prevTerms) {\\n        var here = quoteSyntax { here };\\n        var macName = stx[0];\\n        var nameStx = stx[1];\\n        var stxName = stx[2];\\n        var ctxName = stx[3];\\n        var matchName = stx[4];\\n        var decls = stx[5].expose().token.inner;\\n        var mclass = decls.reduce(function(m, decl) {\\n            var tag = unwrapSyntax(decl.token.inner[0]);\\n            if (tag === 'name') {\\n                if (m.name) {\\n                    throwSyntaxError('macroclass',\\n                                     'Duplicate name declaration',\\n                                     decl.token.inner[0])\\n                }\\n                m.name = unwrapSyntax(decl.token.inner[1]);\\n            } else if (tag === 'pattern') {\\n                var patternStx = decl.expose().token.inner.slice(1);\\n                var pattern = patternStx.reduce(function(p, mod) {\\n                    var tag = unwrapSyntax(mod.token.inner[0]);\\n                    if (tag === 'name') {\\n                        if (p.name) {\\n                            throwSyntaxError('macroclass',\\n                                             'Duplicate name declaration',\\n                                             mod.token.inner[0])\\n                        }\\n                        p.name = unwrapSyntax(mod.token.inner[1]);\\n                    } else if (tag === 'rule') {\\n                        if (p.rule) {\\n                            throwSyntaxError('macroclass',\\n                                             'Duplicate rule declaration',\\n                                             mod.token.inner[0])\\n                        }\\n                        p.rule = mod.expose().token.inner[1].expose().token.inner;\\n                    } else if (tag === 'with') {\\n                        mod.expose();\\n                        p.withs.push({\\n                            lhs: mod.token.inner[1].expose().token.inner,\\n                            rhs: mod.token.inner[2].expose().token.inner.map(function mapper(s) {\\n                                // We need to transplant syntax quotes so that it looks\\n                                // like they are within the macro body code and not\\n                                // the original code, otherwise it won't expand.\\n                                if (unwrapSyntax(s) === '#') {\\n                                    s.context = macName.context;\\n                                } else if (s.token.type === parser.Token.Delimiter) {\\n                                    s.expose();\\n                                    s.token.inner = s.token.inner.map(mapper);\\n                                }\\n                                return s;\\n                            })\\n                        });\\n                    }\\n                    return p;\\n                }, { withs: [] });\\n                m.patterns.push(pattern);\\n            }\\n            return m;\\n        }, { patterns: [] });\\n\\n        var body = mclass.patterns.reduce(function(stx, pattern) {\\n            var ruleStx = [makeIdent('_', here)].concat(pattern.rule);\\n            var ruleId = __fresh();\\n            var rule = patternModule.loadPattern(ruleStx);\\n\\n            context.patternMap.set(ruleId, rule);\\n\\n            var withBindings = pattern.withs.reduce(function(acc, w) {\\n                return acc.concat(w.lhs.concat(makePunc('=', here), w.rhs, makePunc(',', here)));\\n            }, []);\\n\\n            var ret = [\\n                makeKeyword('return', here), makeDelim('{}', [\\n                    makeIdent('result', here), makePunc(':', here), makeDelim('[]', [], here),\\n                    makePunc(',', here),\\n                    makeIdent('rest', here), makePunc(':', here),\\n                    matchName, makePunc('.', here), makeIdent('rest', here),\\n                    makePunc(',', here),\\n                    makeIdent('patterns', here), makePunc(':', here),\\n                    matchName, makePunc('.', here), makeIdent('patternEnv', here),\\n                ], here)\\n            ];\\n\\n            var inner = ret;\\n            if (withBindings.length) {\\n                inner = [\\n                    makeKeyword('return', macName), makeIdent('withSyntax', macName),\\n                    makeDelim('()', withBindings, here),\\n                    makeDelim('{}', ret, here)\\n                ];\\n            }\\n\\n            var res = [\\n                matchName, makePunc('=', here),\\n                makeIdent('patternModule', here), makePunc('.', here),\\n                makeIdent('matchPatterns', here), makeDelim('()', [\\n                    makeIdent('getPattern', here), makeDelim('()', [\\n                        makeValue(ruleId, here)\\n                    ], here),\\n                    makePunc(',', here), stxName,\\n                    makePunc(',', here), ctxName,\\n                    makePunc(',', here), makeValue(true, here)\\n                ], here),\\n                makePunc(';', here),\\n                makeKeyword('if', here), makeDelim('()', [\\n                    matchName, makePunc('.', here), makeIdent('success', here)\\n                ], here), makeDelim('{}', inner, here)\\n            ];\\n          \\n            return stx.concat(res);\\n\\n        }, []);\\n\\n        var res = body.concat(\\n            makeIdent('throwSyntaxCaseError', here),\\n            makeDelim('()', [\\n                makeValue(mclass.name || unwrapSyntax(nameStx), here), makePunc(',', here),\\n                makeValue('No match', here)\\n            ], here)\\n        );\\n\\n        return {\\n            result: res,\\n            rest: stx.slice(6)\\n        };\\n    }\\n}\\n\\nexport macroclass;\\n\\nmacro safemacro {\\n    rule { $name:ident { rule $body ... } } => {\\n        let $name = macro {\\n            rule { : } => { $name : }\\n            rule infix { . | } => { . $name }\\n            rule $body ...\\n        }\\n    }\\n    rule { $name:ident { case $body ... } } => {\\n        let $name = macro {\\n            case { _ : } => { return #{ $name : } }\\n            case infix { . | _ } => { return #{ . $name } }\\n            case $body ...\\n        }\\n    }\\n}\\n\\nmacro op_assoc {\\n    rule { left }\\n    rule { right }\\n}\\n\\nmacro op_name {\\n    rule { ($name ...) }\\n    rule { $name } => { ($name) }\\n}\\n\\nsafemacro operator {\\n    rule {\\n        $name:op_name $prec:lit $assoc:op_assoc\\n        { $left:ident, $right:ident } => #{ $body ... }\\n    } => {\\n        binaryop $name $prec $assoc {\\n            macro {\\n                rule { ($left:expr) ($right:expr) } => { $body ... }\\n            }\\n        }\\n    }\\n    rule {\\n        $name:op_name $prec:lit { $op:ident } => #{ $body ... }\\n    } => {\\n        unaryop $name $prec {\\n            macro {\\n                rule { $op:expr } => { $body ... }\\n            }\\n        }\\n    }\\n}\\nexport operator;\\n\\n// macro __log {\\n//     case { _ defctx $stx } => {\\n//         var context = #{ $stx }[0].context;\\n//         console.log(\\\"defctx context for \\\" + unwrapSyntax(#{$stx}) + \\\"]\\\");\\n//         while (context) {\\n//             if (context.defctx) {\\n//                 console.log(context.defctx.map(function(d) {\\n//                     return d.id.token.value\\n//                 }));\\n//             }\\n//             context = context.context;\\n//         }\\n//         return [];\\n//     }\\n//     case {_ rename $stx } => {\\n//         var context = #{ $stx }[0].context;\\n//         console.log(\\\"rename context for \\\" + unwrapSyntax(#{$stx}) + \\\":\\\");\\n//         while (context) {\\n//             if (context.name) {\\n//                 console.log(\\\"[name: \\\" + context.name + \\\", id: \\\" + context.id.token.value + \\\"]\\\");\\n//             }\\n//             context = context.context;\\n//         }\\n//         return [];\\n//     }\\n//     case {_ all $stx } => {\\n//         var context = #{ $stx }[0].context;\\n//         console.log(\\\"context for \\\" + unwrapSyntax(#{$stx}) + \\\":\\\");\\n//         while (context) {\\n//             if (context.name) {\\n//                 console.log(\\\"rename@[name: \\\" + context.name + \\\", id: \\\" + context.id.token.value + \\\"]\\\");\\n//             }\\n//             if (context.mark) {\\n//                 console.log(\\\"mark@[mark: \\\" + context.mark + \\\"]\\\");\\n//             }\\n//             if (context.defctx) {\\n//                 console.log(\\\"defctx@[\\\" + context.defctx.map(function(d) {\\n//                     return d.id.token.value\\n//                 }) + \\\"]\\\");\\n//             }\\n//             context = context.context;\\n//         }\\n//         return [];\\n//     }\\n// }\\n// export __log;\\n\"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./~/sweet.js/macros/stxcase.js\n ** module id = 132\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/sweet.js/macros/stxcase.js?./~/raw-loader");

/***/ },
/* 133 */
/***/ function(module, exports) {

	eval("module.exports = \"macro rlet {\\n  case {\\n    _ $varname:ident = subscribe($deps:ident (,) ... ) initially ($init:expr) $expr:expr\\n  } => {\\n    var randLetter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\\n    var self = '__S' + randLetter + Date.now() % 10000;\\n    letstx $s = [makeIdent(self, #{$varname})];\\n    letstx $depv... = window.globalVars(self, localExpand(#{$expr}))\\n      .map(function(idep) { return makeIdent(idep, #{$varname}); });\\n    return #{\\n      let $varname = macro {\\n        rule { = $next:expr } => {\\n          $s.push($next)\\n        }\\n        rule { subscribe $update:ident ; } => {\\n          $s.onUpdate($update);\\n        }\\n        rule { } => { $s.read() }\\n      }\\n      var $s = new Signal(function() { return $expr; }, $init);\\n      $( $deps subscribe $s ; ) ...\\n      $( $depv.onUpdate($s) ; ) ...\\n    }\\n  }\\n\\n  case {\\n    _ $varname:ident = subscribe($sub:ident (,) ... , $sube:expr $rest ... ) initially($init:expr) $expr:expr\\n  } => {\\n    var randLetter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\\n    letstx $tmp = [makeIdent('__' + randLetter + Date.now() % 10000, #{$varname})];\\n    return #{\\n      rlet $tmp;\\n      ($sube)(function(w) { $tmp = w; })\\n      rlet $varname = subscribe($sub (,) ... , $tmp $rest ...) initially($init) $expr\\n    };\\n  }\\n\\n  case {\\n    _ $varname:ident = subscribe($sube:expr $rest ... ) initially($init:expr) $expr:expr\\n  } => {\\n    var randLetter = String.fromCharCode(65 + Math.floor(Math.random() * 26));\\n    letstx $tmp = [makeIdent('__' + randLetter + Date.now() % 10000, #{$varname})];\\n    return #{\\n      rlet $tmp;\\n      ($sube)(function(w) { $tmp = w; })\\n      rlet $varname = subscribe($tmp $rest ...) initially($init) $expr\\n    };\\n  }\\n\\n  rule {\\n    $varname:ident = initially($init ...) $expr:expr\\n  } => {\\n    rlet $varname = subscribe() initially($init ...) $expr\\n  }\\n\\n  rule {\\n    $varname:ident = subscribe($sub ...) $expr:expr\\n  } => {\\n    rlet $varname = subscribe($sub ...) initially(null) $expr\\n  }\\n\\n  rule {\\n    $varname:ident = $expr:expr\\n  } => {\\n    rlet $varname = initially(null) $expr\\n  }\\n\\n  rule {\\n    $varname:ident\\n  } => {\\n    rlet $varname = null\\n  }\\n}\\n\\nmacro subscribe {\\n  rule {\\n    ( $deps ... ) { $stmt ... }\\n  } => {\\n    rlet x = subscribe ( $deps ... ) (function() { $stmt ... })()\\n  }\\n}\\n\"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./src/macros.sjs\n ** module id = 133\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/macros.sjs?./~/raw-loader");

/***/ },
/* 134 */
/***/ function(module, exports) {

	eval("module.exports = \"\\\"use strict\\\";\\n\\nfunction Signal(expr, initial) {\\n  this.subscribers = [];\\n  this.expr = expr;\\n  this.last = initial;\\n}\\n\\nSignal.prototype.push = function push(val) {\\n  this.last = val;\\n  var toUpdate = [].concat(this.subscribers);\\n  while (toUpdate.length > 0) {\\n    var next = toUpdate.shift();\\n    toUpdate = toUpdate.concat(next.update());\\n    // keep only *last* occurance of dependency\\n    toUpdate = toUpdate.filter(function (sig, idx) {\\n      return idx === toUpdate.lastIndexOf(sig);\\n    });\\n  }\\n};\\n\\nSignal.prototype.read = function read() {\\n  return this.last;\\n};\\n\\nSignal.prototype.onUpdate = function onUpdate(subscriber) {\\n  this.subscribers.push(subscriber);\\n};\\n\\nSignal.prototype.update = function update() {\\n  this.last = this.expr();\\n  return this.subscribers;\\n};\\n\\nfunction interval(n) {\\n  return function (cb) {\\n    setInterval(cb, n);\\n  };\\n}\"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./src/signal.js\n ** module id = 134\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/signal.js?./~/raw-loader");

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(136);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/index.js\n ** module id = 135\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/index.js?");

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = []\n  , exports = module.exports = {};\n\n/*!\n * Chai version\n */\n\nexports.version = '3.4.1';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = __webpack_require__(137);\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = __webpack_require__(138);\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = __webpack_require__(151);\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = __webpack_require__(170);\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = __webpack_require__(171);\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = __webpack_require__(172);\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = __webpack_require__(173);\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = __webpack_require__(174);\nexports.use(assert);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai.js\n ** module id = 136\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai.js?");

/***/ },
/* 137 */
/***/ function(module, exports) {

	eval("/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/assertion-error/index.js\n ** module id = 137\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/assertion-error/index.js?");

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Main exports\n */\n\nvar exports = module.exports = {};\n\n/*!\n * test utility\n */\n\nexports.test = __webpack_require__(139);\n\n/*!\n * type utility\n */\n\nexports.type = __webpack_require__(141);\n\n/*!\n * expectTypes utility\n */\nexports.expectTypes = __webpack_require__(143);\n\n/*!\n * message utility\n */\n\nexports.getMessage = __webpack_require__(144);\n\n/*!\n * actual utility\n */\n\nexports.getActual = __webpack_require__(145);\n\n/*!\n * Inspect util\n */\n\nexports.inspect = __webpack_require__(146);\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = __webpack_require__(150);\n\n/*!\n * Flag utility\n */\n\nexports.flag = __webpack_require__(140);\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = __webpack_require__(152);\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = __webpack_require__(153);\n\n/*!\n * Deep path value\n */\n\nexports.getPathValue = __webpack_require__(161);\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = __webpack_require__(162);\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = __webpack_require__(163);\n\n/*!\n * Function name\n */\n\nexports.getName = __webpack_require__(147);\n\n/*!\n * add Property\n */\n\nexports.addProperty = __webpack_require__(164);\n\n/*!\n * add Method\n */\n\nexports.addMethod = __webpack_require__(165);\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = __webpack_require__(166);\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = __webpack_require__(167);\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = __webpack_require__(168);\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = __webpack_require__(169);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/index.js\n ** module id = 138\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/index.js?");

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = __webpack_require__(140);\n\n/**\n * # test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/test.js\n ** module id = 139\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/test.js?");

/***/ },
/* 140 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @name flag\n * @api private\n */\n\nmodule.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/flag.js\n ** module id = 140\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/flag.js?");

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(142);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/type-detect/index.js\n ** module id = 141\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/type-detect/index.js?");

/***/ },
/* 142 */
/***/ function(module, exports) {

	eval("/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\nvar objectTypeRegexp = /^\\[object (.*)\\]$/;\n\nfunction getType(obj) {\n  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();\n  // Let \"new String('')\" return 'object'\n  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';\n  // PhantomJS has type \"DOMWindow\" for null\n  if (obj === null) return 'null';\n  // PhantomJS has type \"DOMWindow\" for undefined\n  if (obj === undefined) return 'undefined';\n  return type;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library() {\n  if (!(this instanceof Library)) return new Library();\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function(type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function(obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/type-detect/lib/type.js\n ** module id = 142\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/type-detect/lib/type.js?");

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - expectTypes utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### expectTypes(obj, types)\n *\n * Ensures that the object being tested against is of a valid type.\n *\n *     utils.expectTypes(this, ['array', 'object', 'string']);\n *\n * @param {Mixed} obj constructed Assertion\n * @param {Array} type A list of allowed types for this assertion\n * @name expectTypes\n * @api public\n */\n\nvar AssertionError = __webpack_require__(137);\nvar flag = __webpack_require__(140);\nvar type = __webpack_require__(141);\n\nmodule.exports = function (obj, types) {\n  var obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  if (!types.some(function (expected) { return type(obj) === expected; })) {\n    throw new AssertionError(\n      'object tested must be ' + str + ', but ' + type(obj) + ' given'\n    );\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/expectTypes.js\n ** module id = 143\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/expectTypes.js?");

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = __webpack_require__(140)\n  , getActual = __webpack_require__(145)\n  , inspect = __webpack_require__(146)\n  , objDisplay = __webpack_require__(150);\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#{this}/g, objDisplay(val))\n    .replace(/#{act}/g, objDisplay(actual))\n    .replace(/#{exp}/g, objDisplay(expected));\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getMessage.js\n ** module id = 144\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getMessage.js?");

/***/ },
/* 145 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getActual.js\n ** module id = 145\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getActual.js?");

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	eval("// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = __webpack_require__(147);\nvar getProperties = __webpack_require__(148);\nvar getEnumerableProperties = __webpack_require__(149);\n\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/inspect.js\n ** module id = 146\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/inspect.js?");

/***/ },
/* 147 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - getName utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getName(func)\n *\n * Gets the name of a function, in a cross-browser way.\n *\n * @param {Function} a function (usually a constructor)\n */\n\nmodule.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getName.js\n ** module id = 147\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getName.js?");

/***/ },
/* 148 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getProperties.js\n ** module id = 148\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getProperties.js?");

/***/ },
/* 149 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getEnumerableProperties.js\n ** module id = 149\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getEnumerableProperties.js?");

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar inspect = __webpack_require__(146);\nvar config = __webpack_require__(151);\n\n/**\n * ### .objDisplay (object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @api public\n */\n\nmodule.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/objDisplay.js\n ** module id = 150\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/objDisplay.js?");

/***/ },
/* 151 */
/***/ function(module, exports) {

	eval("module.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n   includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded, for\n   * example for large data structures, the value is replaced with something\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   * This is especially userful when doing assertions on arrays: having this\n   * set to a reasonable large value makes the failure messages readily\n   * inspectable.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/config.js\n ** module id = 151\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/config.js?");

/***/ },
/* 152 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, and `message`)\n * will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAsseriton = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/transferFlags.js\n ** module id = 152\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/transferFlags.js?");

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(154);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/index.js\n ** module id = 153\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deep-eql/index.js?");

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar type = __webpack_require__(155);\n\n/*!\n * Buffer.isBuffer browser shim\n */\n\nvar Buffer;\ntry { Buffer = __webpack_require__(157).Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\n\n/**\n * Assert super-strict (egal) equality between\n * two objects of any type.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @param {Array} memoised (optional)\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}\n\n/*!\n * Strict (egal) equality test. Ensures that NaN always\n * equals NaN and `-0` does not equal `+0`.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} equal match\n */\n\nfunction sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}\n\n/*!\n * Compare the types of two given objects and\n * return if they are equal. Note that an Array\n * has a type of `array` (not `object`) and arguments\n * have a type of `arguments` (not `array`/`object`).\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction typeEqual(a, b) {\n  return type(a) === type(b);\n}\n\n/*!\n * Compare two Date objects by asserting that\n * the time values are equal using `saveValue`.\n *\n * @param {Date} a\n * @param {Date} b\n * @return {Boolean} result\n */\n\nfunction dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}\n\n/*!\n * Compare two regular expressions by converting them\n * to string and checking for `sameValue`.\n *\n * @param {RegExp} a\n * @param {RegExp} b\n * @return {Boolean} result\n */\n\nfunction regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}\n\n/*!\n * Assert deep equality of two `arguments` objects.\n * Unfortunately, these must be sliced to arrays\n * prior to test to ensure no bad behavior.\n *\n * @param {Arguments} a\n * @param {Arguments} b\n * @param {Array} memoize (optional)\n * @return {Boolean} result\n */\n\nfunction argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}\n\n/*!\n * Get enumerable properties of a given object.\n *\n * @param {Object} a\n * @return {Array} property names\n */\n\nfunction enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}\n\n/*!\n * Simple equality for flat iterable objects\n * such as Arrays or Node.js buffers.\n *\n * @param {Iterable} a\n * @param {Iterable} b\n * @return {Boolean} result\n */\n\nfunction iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}\n\n/*!\n * Extension to `iterableEqual` specifically\n * for Node.js Buffers.\n *\n * @param {Buffer} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}\n\n/*!\n * Block for `objectEqual` ensuring non-existing\n * values don't get in.\n *\n * @param {Mixed} object\n * @return {Boolean} result\n */\n\nfunction isValue(a) {\n  return a !== null && a !== undefined;\n}\n\n/*!\n * Recursively check the equality of two objects.\n * Once basic sameness has been established it will\n * defer to `deepEqual` for each enumerable key\n * in the object.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/lib/eql.js\n ** module id = 154\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deep-eql/lib/eql.js?");

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(156);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/~/type-detect/index.js\n ** module id = 155\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deep-eql/~/type-detect/index.js?");

/***/ },
/* 156 */
/***/ function(module, exports) {

	eval("/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\n\nfunction getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library () {\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/~/type-detect/lib/type.js\n ** module id = 156\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deep-eql/~/type-detect/lib/type.js?");

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = __webpack_require__(158)\nvar ieee754 = __webpack_require__(159)\nvar isArray = __webpack_require__(160)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(157).Buffer, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 157\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/buffer/index.js?");

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	eval("var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}( false ? (this.base64js = {}) : exports))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-js/lib/b64.js\n ** module id = 158\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/base64-js/lib/b64.js?");

/***/ },
/* 159 */
/***/ function(module, exports) {

	eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 159\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/ieee754/index.js?");

/***/ },
/* 160 */
/***/ function(module, exports) {

	eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/isarray/index.js\n ** module id = 160\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/buffer/~/isarray/index.js?");

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - getPathValue utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\nvar getPathInfo = __webpack_require__(162);\n\n/**\n * ### .getPathValue(path, object)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue('prop1.str', obj); // Hello\n *     getPathValue('prop1.att[2]', obj); // b\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} value or `undefined`\n * @name getPathValue\n * @api public\n */\nmodule.exports = function(path, obj) {\n  var info = getPathInfo(path, obj);\n  return info.value;\n}; \n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getPathValue.js\n ** module id = 161\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getPathValue.js?");

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - getPathInfo utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar hasProperty = __webpack_require__(163);\n\n/**\n * ### .getPathInfo(path, object)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} info\n * @name getPathInfo\n * @api public\n */\n\nmodule.exports = function getPathInfo(path, obj) {\n  var parsed = parsePath(path),\n      last = parsed[parsed.length - 1];\n\n  var info = {\n    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: _getPathValue(parsed, obj)\n  };\n  info.exists = hasProperty(info.name, info.parent);\n\n  return info;\n};\n\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `_getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath (path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /^\\[(\\d+)\\]$/\n      , mArr = re.exec(value);\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n  });\n}\n\n\n/*!\n * ## _getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @param {Number} object to search against\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction _getPathValue (parsed, obj, index) {\n  var tmp = obj\n    , res;\n\n  index = (index === undefined ? parsed.length : index);\n\n  for (var i = 0, l = index; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getPathInfo.js\n ** module id = 162\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/getPathInfo.js?");

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - hasProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = __webpack_require__(141);\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has\n * named property or numeric array index.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with natives\n * and null/undefined values.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty('str', obj);  // true\n *     hasProperty('constructor', obj);  // true\n *     hasProperty('bar', obj);  // false\n *     \n *     hasProperty('length', obj.str); // true\n *     hasProperty(1, obj.str);  // true\n *     hasProperty(5, obj.str);  // false\n *\n *     hasProperty('length', obj.arr);  // true\n *     hasProperty(2, obj.arr);  // true\n *     hasProperty(3, obj.arr);  // false\n *\n * @param {Objuect} object\n * @param {String|Number} name\n * @returns {Boolean} whether it exists\n * @name getPathInfo\n * @api public\n */\n\nvar literals = {\n    'number': Number\n  , 'string': String\n};\n\nmodule.exports = function hasProperty(name, obj) {\n  var ot = type(obj);\n\n  // Bad Object, obviously no props at all\n  if(ot === 'null' || ot === 'undefined')\n    return false;\n\n  // The `in` operator does not work with certain literals\n  // box these before the check\n  if(literals[ot] && typeof obj !== 'object')\n    obj = new literals[ot](obj);\n\n  return name in obj;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/hasProperty.js\n ** module id = 163\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/hasProperty.js?");

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(151);\nvar flag = __webpack_require__(140);\n\n/**\n * ### addProperty (ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function addProperty() {\n        var old_ssfi = flag(this, 'ssfi');\n        if (old_ssfi && config.includeStack === false)\n          flag(this, 'ssfi', addProperty);\n\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addProperty.js\n ** module id = 164\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/addProperty.js?");

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(151);\n\n/**\n * ### .addMethod (ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @name addMethod\n * @api public\n */\nvar flag = __webpack_require__(140);\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var old_ssfi = flag(this, 'ssfi');\n    if (old_ssfi && config.includeStack === false)\n      flag(this, 'ssfi', ctx[name]);\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addMethod.js\n ** module id = 165\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/addMethod.js?");

/***/ },
/* 166 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteProperty (ctx, name, fn)\n *\n * Overwites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteProperty.js\n ** module id = 166\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/overwriteProperty.js?");

/***/ },
/* 167 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteMethod (ctx, name, fn)\n *\n * Overwites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteMethod.js\n ** module id = 167\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/overwriteMethod.js?");

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar transferFlags = __webpack_require__(152);\nvar flag = __webpack_require__(140);\nvar config = __webpack_require__(151);\n\n/*!\n * Module variables\n */\n\n// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function assert() {\n          var old_ssfi = flag(this, 'ssfi');\n          if (old_ssfi && config.includeStack === false)\n            flag(this, 'ssfi', assert);\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addChainableMethod.js\n ** module id = 168\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/addChainableMethod.js?");

/***/ },
/* 169 */
/***/ function(module, exports) {

	eval("/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Overwites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.length(3);\n *     expect(myFoo).to.have.length.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteChainableMethod.js\n ** module id = 169\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/utils/overwriteChainableMethod.js?");

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(151);\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * @api private\n   */\n\n  function Assertion (obj, msg, stack) {\n    flag(this, 'ssfi', stack || arguments.callee);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /**\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String|Function} message or function that returns message to display if expression fails\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (true !== showDiff) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      var msg = util.getMessage(this, arguments)\n        , actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/assertion.js\n ** module id = 170\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/assertion.js?");

/***/ },
/* 171 */
/***/ function(module, exports) {

	eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to\n   * improve the readability of your assertions. They\n   * do not provide testing capabilities unless they\n   * have been overwritten by a plugin.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   *\n   * @name language chains\n   * @api public\n   */\n\n  [ 'to', 'be', 'been'\n  , 'is', 'and', 'has', 'have'\n  , 'with', 'that', 'which', 'at'\n  , 'of', 'same' ].forEach(function (chain) {\n    Assertion.addProperty(chain, function () {\n      return this;\n    });\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates any of assertions following in the chain.\n   *\n   *     expect(foo).to.not.equal('bar');\n   *     expect(goodFn).to.not.throw(Error);\n   *     expect({ foo: 'baz' }).to.have.property('foo')\n   *       .and.not.equal('bar');\n   *\n   * @name not\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Sets the `deep` flag, later used by the `equal` and\n   * `property` assertions.\n   *\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\n   *     expect({ foo: { bar: { baz: 'quux' } } })\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\n   *\n   * `.deep.property` special characters can be escaped\n   * by adding two slashes before the `.` or `[]`.\n   *\n   *     var deepCss = { '.link': { '[target]': 42 }};\n   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n   *\n   * @name deep\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Sets the `any` flag, (opposite of the `all` flag)\n   * later used in the `keys` assertion.\n   *\n   *     expect(foo).to.have.any.keys('bar', 'baz');\n   *\n   * @name any\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false)\n  });\n\n\n  /**\n   * ### .all\n   *\n   * Sets the `all` flag (opposite of the `any` flag)\n   * later used by the `keys` assertion.\n   *\n   *     expect(foo).to.have.all.keys('bar', 'baz');\n   *\n   * @name all\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type)\n   *\n   * The `a` and `an` assertions are aliases that can be\n   * used either as language chains or to assert a value's\n   * type.\n   *\n   *     // typeof\n   *     expect('test').to.be.a('string');\n   *     expect({ foo: 'bar' }).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *     expect(new Error).to.be.an('error');\n   *     expect(new Promise).to.be.a('promise');\n   *     expect(new Float32Array()).to.be.a('float32array');\n   *     expect(Symbol()).to.be.a('symbol');\n   *\n   *     // es6 overrides\n   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');\n   *\n   *     // language chain\n   *     expect(foo).to.be.an.instanceof(Foo);\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj)\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(value)\n   *\n   * The `include` and `contain` assertions can be used as either property\n   * based language chains or as methods to assert the inclusion of an object\n   * in an array or a substring in a string. When used as language chains,\n   * they toggle the `contains` flag for the `keys` assertion.\n   *\n   *     expect([1,2,3]).to.include(2);\n   *     expect('foobar').to.contain('foo');\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Object|String|Number} obj\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    _.expectTypes(this, ['array', 'object', 'string']);\n\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var expected = false;\n\n    if (_.type(obj) === 'array' && _.type(val) === 'object') {\n      for (var i in obj) {\n        if (_.eql(obj[i], val)) {\n          expected = true;\n          break;\n        }\n      }\n    } else if (_.type(val) === 'object') {\n      if (!flag(this, 'negate')) {\n        for (var k in val) new Assertion(obj).property(k, val[k]);\n        return;\n      }\n      var subset = {};\n      for (var k in val) subset[k] = obj[k];\n      expected = _.eql(subset, val);\n    } else {\n      expected = (obj != undefined) && ~obj.indexOf(val);\n    }\n    this.assert(\n        expected\n      , 'expected #{this} to include ' + _.inspect(val)\n      , 'expected #{this} to not include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is truthy.\n   *\n   *     expect('everything').to.be.ok;\n   *     expect(1).to.be.ok;\n   *     expect(false).to.not.be.ok;\n   *     expect(undefined).to.not.be.ok;\n   *     expect(null).to.not.be.ok;\n   *\n   * @name ok\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is `true`.\n   *\n   *     expect(true).to.be.true;\n   *     expect(1).to.not.be.true;\n   *\n   * @name true\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , this.negate ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is `false`.\n   *\n   *     expect(false).to.be.false;\n   *     expect(0).to.not.be.false;\n   *\n   * @name false\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , this.negate ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is `null`.\n   *\n   *     expect(null).to.be.null;\n   *     expect(undefined).to.not.be.null;\n   *\n   * @name null\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *     expect(null).to.not.be.undefined;\n   *\n   * @name undefined\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .NaN\n   * Asserts that the target is `NaN`.\n   *\n   *     expect('foo').to.be.NaN;\n   *     expect(4).not.to.be.NaN;\n   *\n   * @name NaN\n   * @api public\n   */\n\n  Assertion.addProperty('NaN', function () {\n    this.assert(\n        isNaN(flag(this, 'object'))\n        , 'expected #{this} to be NaN'\n        , 'expected #{this} not to be NaN'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi'\n   *       , bar = null\n   *       , baz;\n   *\n   *     expect(foo).to.exist;\n   *     expect(bar).to.not.exist;\n   *     expect(baz).to.not.exist;\n   *\n   * @name exist\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    this.assert(\n        null != flag(this, 'object')\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n\n  /**\n   * ### .empty\n   *\n   * Asserts that the target's length is `0`. For arrays and strings, it checks\n   * the `length` property. For objects, it gets the count of\n   * enumerable keys.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *     expect({}).to.be.empty;\n   *\n   * @name empty\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var obj = flag(this, 'object')\n      , expected = obj;\n\n    if (Array.isArray(obj) || 'string' === typeof object) {\n      expected = obj.length;\n    } else if (typeof obj === 'object') {\n      expected = Object.keys(obj).length;\n    }\n\n    this.assert(\n        !expected\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an arguments object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   * @name arguments\n   * @alias Arguments\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = Object.prototype.toString.call(obj);\n    this.assert(\n        '[object Arguments]' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(value)\n   *\n   * Asserts that the target is strictly equal (`===`) to `value`.\n   * Alternately, if the `deep` flag is set, asserts that\n   * the target is deeply equal to `value`.\n   *\n   *     expect('hello').to.equal('hello');\n   *     expect(42).to.equal(42);\n   *     expect(1).to.not.equal(true);\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @alias deep.equal\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      return this.eql(val);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(value)\n   *\n   * Asserts that the target is deeply equal to `value`.\n   *\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(value)\n   *\n   * Asserts that the target is greater than `value`.\n   *\n   *     expect(10).to.be.above(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len > n\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\n        , 'expected #{this} to not have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above ' + n\n        , 'expected #{this} to be at most ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(value)\n   *\n   * Asserts that the target is greater than or equal to `value`.\n   *\n   *     expect(10).to.be.at.least(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.least(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= n\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n        , 'expected #{this} to have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least ' + n\n        , 'expected #{this} to be below ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(value)\n   *\n   * Asserts that the target is less than `value`.\n   *\n   *     expect(5).to.be.below(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len < n\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\n        , 'expected #{this} to not have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below ' + n\n        , 'expected #{this} to be at least ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(value)\n   *\n   * Asserts that the target is less than or equal to `value`.\n   *\n   *     expect(5).to.be.at.most(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.most(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len <= n\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n        , 'expected #{this} to have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most ' + n\n        , 'expected #{this} to be above ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish)\n   *\n   * Asserts that the target is within a range.\n   *\n   *     expect(7).to.be.within(5,10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a length range. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name within\n   * @param {Number} start lowerbound inclusive\n   * @param {Number} finish upperbound inclusive\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , range = start + '..' + finish;\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= start && len <= finish\n        , 'expected #{this} to have a length within ' + range\n        , 'expected #{this} to not have a length within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor)\n   *\n   * Asserts that the target is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , Chai = new Tea('chai');\n   *\n   *     expect(Chai).to.be.an.instanceof(Tea);\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} message _optional_\n   * @alias instanceOf\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n    var name = _.getName(constructor);\n    this.assert(\n        flag(this, 'object') instanceof constructor\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name, [value])\n   *\n   * Asserts that the target has a property `name`, optionally asserting that\n   * the value of that property is strictly equal to  `value`.\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n   * references into objects and arrays.\n   *\n   *     // simple referencing\n   *     var obj = { foo: 'bar' };\n   *     expect(obj).to.have.property('foo');\n   *     expect(obj).to.have.property('foo', 'bar');\n   *\n   *     // deep referencing\n   *     var deepObj = {\n   *         green: { tea: 'matcha' }\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n   *     };\n   *\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n   *\n   * You can also use an array as the starting point of a `deep.property`\n   * assertion, or traverse nested arrays.\n   *\n   *     var arr = [\n   *         [ 'chai', 'matcha', 'konacha' ]\n   *       , [ { tea: 'chai' }\n   *         , { tea: 'matcha' }\n   *         , { tea: 'konacha' } ]\n   *     ];\n   *\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n   *\n   * Furthermore, `property` changes the subject of the assertion\n   * to be the value of that property from the original object. This\n   * permits for further chainable assertions on that property.\n   *\n   *     expect(obj).to.have.property('foo')\n   *       .that.is.a('string');\n   *     expect(deepObj).to.have.property('green')\n   *       .that.is.an('object')\n   *       .that.deep.equals({ tea: 'matcha' });\n   *     expect(deepObj).to.have.property('teas')\n   *       .that.is.an('array')\n   *       .with.deep.property('[2]')\n   *         .that.deep.equals({ tea: 'konacha' });\n   *\n   * Note that dots and bracket in `name` must be backslash-escaped when\n   * the `deep` flag is set, while they must NOT be escaped when the `deep`\n   * flag is not set.\n   *\n   *     // simple referencing\n   *     var css = { '.link[target]': 42 };\n   *     expect(css).to.have.property('.link[target]', 42);\n   *\n   *     // deep referencing\n   *     var deepCss = { '.link': { '[target]': 42 }};\n   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n   *\n   * @name property\n   * @alias deep.property\n   * @param {String} name\n   * @param {Mixed} value (optional)\n   * @param {String} message _optional_\n   * @returns value of property for chaining\n   * @api public\n   */\n\n  Assertion.addMethod('property', function (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isDeep = !!flag(this, 'deep')\n      , descriptor = isDeep ? 'deep property ' : 'property '\n      , negate = flag(this, 'negate')\n      , obj = flag(this, 'object')\n      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n      , hasProperty = isDeep\n        ? pathInfo.exists\n        : _.hasProperty(name, obj)\n      , value = isDeep\n        ? pathInfo.value\n        : obj[name];\n\n    if (negate && arguments.length > 1) {\n      if (undefined === value) {\n        msg = (msg != null) ? msg + ': ' : '';\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n      }\n    } else {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (arguments.length > 1) {\n      this.assert(\n          val === value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  });\n\n\n  /**\n   * ### .ownProperty(name)\n   *\n   * Asserts that the target has an own property `name`.\n   *\n   *     expect('test').to.have.ownProperty('length');\n   *\n   * @name ownProperty\n   * @alias haveOwnProperty\n   * @param {String} name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnProperty (name, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        obj.hasOwnProperty(name)\n      , 'expected #{this} to have own property ' + _.inspect(name)\n      , 'expected #{this} to not have own property ' + _.inspect(name)\n    );\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .ownPropertyDescriptor(name[, descriptor[, message]])\n   *\n   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.\n   *\n   *     expect('test').to.have.ownPropertyDescriptor('length');\n   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });\n   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });\n   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);\n   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');\n   *\n   * @name ownPropertyDescriptor\n   * @alias haveOwnPropertyDescriptor\n   * @param {String} name\n   * @param {Object} descriptor _optional_\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n    if (typeof descriptor === 'string') {\n      msg = descriptor;\n      descriptor = null;\n    }\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n    if (actualDescriptor && descriptor) {\n      this.assert(\n          _.eql(descriptor, actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n        , descriptor\n        , actualDescriptor\n        , true\n      );\n    } else {\n      this.assert(\n          actualDescriptor\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n      );\n    }\n    flag(this, 'object', actualDescriptor);\n  }\n\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\n  /**\n   * ### .length\n   *\n   * Sets the `doLength` flag later used as a chain precursor to a value\n   * comparison for the `length` property.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * *Deprecation notice:* Using `length` as an assertion will be deprecated\n   * in version 2.4.0 and removed in 3.0.0. Code using the old style of\n   * asserting for `length` property value using `length(value)` should be\n   * switched to use `lengthOf(value)` instead.\n   *\n   * @name length\n   * @api public\n   */\n\n  /**\n   * ### .lengthOf(value[, message])\n   *\n   * Asserts that the target's `length` property has\n   * the expected value.\n   *\n   *     expect([ 1, 2, 3]).to.have.lengthOf(3);\n   *     expect('foobar').to.have.lengthOf(6);\n   *\n   * @name lengthOf\n   * @param {Number} length\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n\n    this.assert(\n        len == n\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\n      , 'expected #{this} to not have a length of #{act}'\n      , n\n      , len\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addMethod('lengthOf', assertLength);\n\n  /**\n   * ### .match(regexp)\n   *\n   * Asserts that the target matches a regular expression.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * @name match\n   * @alias matches\n   * @param {RegExp} RegularExpression\n   * @param {String} message _optional_\n   * @api public\n   */\n  function assertMatch(re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  }\n\n  Assertion.addMethod('match', assertMatch);\n  Assertion.addMethod('matches', assertMatch);\n\n  /**\n   * ### .string(string)\n   *\n   * Asserts that the string target contains another string.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * @name string\n   * @param {String} string\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n\n  /**\n   * ### .keys(key1, [key2], [...])\n   *\n   * Asserts that the target contains any or all of the passed-in keys.\n   * Use in combination with `any`, `all`, `contains`, or `have` will affect\n   * what will pass.\n   *\n   * When used in conjunction with `any`, at least one key that is passed\n   * in must exist in the target object. This is regardless whether or not\n   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n   * should be used in the assertion. If neither are used, the assertion is\n   * defaulted to `all`.\n   *\n   * When both `all` and `contain` are used, the target object must have at\n   * least all of the passed-in keys but may have more keys not listed.\n   *\n   * When both `all` and `have` are used, the target object must both contain\n   * all of the passed-in keys AND the number of keys in the target object must\n   * match the number of keys passed in (in other words, a target object must\n   * have all and only all of the passed-in keys).\n   *\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});\n   *\n   *\n   * @name keys\n   * @alias key\n   * @param {...String|Array|Object} keys\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , str\n      , ok = true\n      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n    switch (_.type(keys)) {\n      case \"array\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        break;\n      case \"object\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        keys = Object.keys(keys);\n        break;\n      default:\n        keys = Array.prototype.slice.call(arguments);\n    }\n\n    if (!keys.length) throw new Error('keys required');\n\n    var actual = Object.keys(obj)\n      , expected = keys\n      , len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all');\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      var intersection = expected.filter(function(key) {\n        return ~actual.indexOf(key);\n      });\n      ok = intersection.length > 0;\n    }\n\n    // Has all\n    if (all) {\n      ok = keys.every(function(key){\n        return ~actual.indexOf(key);\n      });\n      if (!flag(this, 'negate') && !flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key){\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + str\n      , 'expected #{this} to not ' + str\n      , expected.slice(0).sort()\n      , actual.sort()\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw(constructor)\n   *\n   * Asserts that the function target will throw a specific error, or specific type of error\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n   * for the error's message.\n   *\n   *     var err = new ReferenceError('This is a bad function.');\n   *     var fn = function () { throw err; }\n   *     expect(fn).to.throw(ReferenceError);\n   *     expect(fn).to.throw(Error);\n   *     expect(fn).to.throw(/bad function/);\n   *     expect(fn).to.not.throw('good function');\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\n   *     expect(fn).to.throw(err);\n   *\n   * Please note that when a throw expectation is negated, it will check each\n   * parameter independently, starting with error constructor type. The appropriate way\n   * to check for the existence of a type of error but for a message that does not match\n   * is to use `and`.\n   *\n   *     expect(fn).to.throw(ReferenceError)\n   *        .and.not.throw(/good function/);\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {ErrorConstructor} constructor\n   * @param {String|RegExp} expected error message\n   * @param {String} message _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @api public\n   */\n\n  function assertThrows (constructor, errMsg, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('function');\n\n    var thrown = false\n      , desiredError = null\n      , name = null\n      , thrownError = null;\n\n    if (arguments.length === 0) {\n      errMsg = null;\n      constructor = null;\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n      errMsg = constructor;\n      constructor = null;\n    } else if (constructor && constructor instanceof Error) {\n      desiredError = constructor;\n      constructor = null;\n      errMsg = null;\n    } else if (typeof constructor === 'function') {\n      name = constructor.prototype.name;\n      if (!name || (name === 'Error' && constructor !== Error)) {\n        name = constructor.name || (new constructor()).name;\n      }\n    } else {\n      constructor = null;\n    }\n\n    try {\n      obj();\n    } catch (err) {\n      // first, check desired error\n      if (desiredError) {\n        this.assert(\n            err === desiredError\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}'\n          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        flag(this, 'object', err);\n        return this;\n      }\n\n      // next, check constructor\n      if (constructor) {\n        this.assert(\n            err instanceof constructor\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n          , name\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        if (!errMsg) {\n          flag(this, 'object', err);\n          return this;\n        }\n      }\n\n      // next, check message\n      var message = 'error' === _.type(err) && \"message\" in err\n        ? err.message\n        : '' + err;\n\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n        this.assert(\n            errMsg.exec(message)\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n          , 'expected #{this} to throw error not matching #{exp}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n        this.assert(\n            ~message.indexOf(errMsg)\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\n          , 'expected #{this} to throw error not including #{act}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else {\n        thrown = true;\n        thrownError = err;\n      }\n    }\n\n    var actuallyGot = ''\n      , expectedThrown = name !== null\n        ? name\n        : desiredError\n          ? '#{exp}' //_.inspect(desiredError)\n          : 'an error';\n\n    if (thrown) {\n      actuallyGot = ' but #{act} was thrown'\n    }\n\n    this.assert(\n        thrown === true\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n    );\n\n    flag(this, 'object', thrownError);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method)\n   *\n   * Asserts that the object or class target will respond to a method.\n   *\n   *     Klass.prototype.bar = function(){};\n   *     expect(Klass).to.respondTo('bar');\n   *     expect(obj).to.respondTo('bar');\n   *\n   * To check if a constructor will respond to a static function,\n   * set the `itself` flag.\n   *\n   *     Klass.baz = function(){};\n   *     expect(Klass).itself.to.respondTo('baz');\n   *\n   * @name respondTo\n   * @alias respondsTo\n   * @param {String} method\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function respondTo (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === _.type(obj) && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  }\n\n  Assertion.addMethod('respondTo', respondTo);\n  Assertion.addMethod('respondsTo', respondTo);\n\n  /**\n   * ### .itself\n   *\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\n   *\n   *     function Foo() {}\n   *     Foo.bar = function() {}\n   *     Foo.prototype.baz = function() {}\n   *\n   *     expect(Foo).itself.to.respondTo('bar');\n   *     expect(Foo).itself.not.to.respondTo('baz');\n   *\n   * @name itself\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(method)\n   *\n   * Asserts that the target passes a given truth test.\n   *\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\n   *\n   * @name satisfy\n   * @alias satisfies\n   * @param {Function} matcher\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function satisfy (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , this.negate ? false : true\n      , result\n    );\n  }\n\n  Assertion.addMethod('satisfy', satisfy);\n  Assertion.addMethod('satisfies', satisfy);\n\n  /**\n   * ### .closeTo(expected, delta)\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *\n   * @name closeTo\n   * @alias approximately\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function closeTo(expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj, msg).is.a('number');\n    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n      throw new Error('the arguments to closeTo or approximately must be numbers');\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  }\n\n  Assertion.addMethod('closeTo', closeTo);\n  Assertion.addMethod('approximately', closeTo);\n\n  function isSubsetOf(subset, superset, cmp) {\n    return subset.every(function(elem) {\n      if (!cmp) return superset.indexOf(elem) !== -1;\n\n      return superset.some(function(elem2) {\n        return cmp(elem, elem2);\n      });\n    })\n  }\n\n  /**\n   * ### .members(set)\n   *\n   * Asserts that the target is a superset of `set`,\n   * or that the target and `set` have the same strictly-equal (===) members.\n   * Alternately, if the `deep` flag is set, set members are compared for deep\n   * equality.\n   *\n   *     expect([1, 2, 3]).to.include.members([3, 2]);\n   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n   *\n   *     expect([4, 2]).to.have.members([2, 4]);\n   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n   *\n   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj).to.be.an('array');\n    new Assertion(subset).to.be.an('array');\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    if (flag(this, 'contains')) {\n      return this.assert(\n          isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to be a superset of #{act}'\n        , 'expected #{this} to not be a superset of #{act}'\n        , obj\n        , subset\n      );\n    }\n\n    this.assert(\n        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to have the same members as #{act}'\n        , 'expected #{this} to not have the same members as #{act}'\n        , obj\n        , subset\n    );\n  });\n\n  /**\n   * ### .oneOf(list)\n   *\n   * Assert that a value appears somewhere in the top level of array `list`.\n   *\n   *     expect('a').to.be.oneOf(['a', 'b', 'c']);\n   *     expect(9).to.not.be.oneOf(['z']);\n   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);\n   *\n   *     var three = [3];\n   *     // for object-types, contents are not compared\n   *     expect(three).to.not.be.oneOf([1, 2, [3]]);\n   *     // comparing references works\n   *     expect(three).to.be.oneOf([1, 2, three]);\n   *\n   * @name oneOf\n   * @param {Array<*>} list\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function oneOf (list, msg) {\n    if (msg) flag(this, 'message', msg);\n    var expected = flag(this, 'object');\n    new Assertion(list).to.be.an('array');\n\n    this.assert(\n        list.indexOf(expected) > -1\n      , 'expected #{this} to be one of #{exp}'\n      , 'expected #{this} to not be one of #{exp}'\n      , list\n      , expected\n    );\n  }\n\n  Assertion.addMethod('oneOf', oneOf);\n\n\n  /**\n   * ### .change(function)\n   *\n   * Asserts that a function changes an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 3 };\n   *     var noChangeFn = function() { return 'foo' + 'bar'; }\n   *     expect(fn).to.change(obj, 'val');\n   *     expect(noChangFn).to.not.change(obj, 'val')\n   *\n   * @name change\n   * @alias changes\n   * @alias Change\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertChanges (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      initial !== object[prop]\n      , 'expected .' + prop + ' to change'\n      , 'expected .' + prop + ' to not change'\n    );\n  }\n\n  Assertion.addChainableMethod('change', assertChanges);\n  Assertion.addChainableMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(function)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     expect(fn).to.increase(obj, 'val');\n   *\n   * @name increase\n   * @alias increases\n   * @alias Increase\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertIncreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial > 0\n      , 'expected .' + prop + ' to increase'\n      , 'expected .' + prop + ' to not increase'\n    );\n  }\n\n  Assertion.addChainableMethod('increase', assertIncreases);\n  Assertion.addChainableMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(function)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     expect(fn).to.decrease(obj, 'val');\n   *\n   * @name decrease\n   * @alias decreases\n   * @alias Decrease\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertDecreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial < 0\n      , 'expected .' + prop + ' to decrease'\n      , 'expected .' + prop + ' to not decrease'\n    );\n  }\n\n  Assertion.addChainableMethod('decrease', assertDecreases);\n  Assertion.addChainableMethod('decreases', assertDecreases);\n\n  /**\n   * ### .extensible\n   *\n   * Asserts that the target is extensible (can have new properties added to\n   * it).\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect({}).to.be.extensible;\n   *     expect(nonExtensibleObject).to.not.be.extensible;\n   *     expect(sealedObject).to.not.be.extensible;\n   *     expect(frozenObject).to.not.be.extensible;\n   *\n   * @name extensible\n   * @api public\n   */\n\n  Assertion.addProperty('extensible', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isExtensible;\n\n    try {\n      isExtensible = Object.isExtensible(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isExtensible = false;\n      else throw err;\n    }\n\n    this.assert(\n      isExtensible\n      , 'expected #{this} to be extensible'\n      , 'expected #{this} to not be extensible'\n    );\n  });\n\n  /**\n   * ### .sealed\n   *\n   * Asserts that the target is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(sealedObject).to.be.sealed;\n   *     expect(frozenObject).to.be.sealed;\n   *     expect({}).to.not.be.sealed;\n   *\n   * @name sealed\n   * @api public\n   */\n\n  Assertion.addProperty('sealed', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isSealed;\n\n    try {\n      isSealed = Object.isSealed(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isSealed = true;\n      else throw err;\n    }\n\n    this.assert(\n      isSealed\n      , 'expected #{this} to be sealed'\n      , 'expected #{this} to not be sealed'\n    );\n  });\n\n  /**\n   * ### .frozen\n   *\n   * Asserts that the target is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(frozenObject).to.be.frozen;\n   *     expect({}).to.not.be.frozen;\n   *\n   * @name frozen\n   * @api public\n   */\n\n  Assertion.addProperty('frozen', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isFrozen;\n\n    try {\n      isFrozen = Object.isFrozen(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isFrozen = true;\n      else throw err;\n    }\n\n    this.assert(\n      isFrozen\n      , 'expected #{this} to be frozen'\n      , 'expected #{this} to not be frozen'\n    );\n  });\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/core/assertions.js\n ** module id = 171\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/core/assertions.js?");

/***/ },
/* 172 */
/***/ function(module, exports) {

	eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/expect.js\n ** module id = 172\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/interface/expect.js?");

/***/ },
/* 173 */
/***/ function(module, exports) {

	eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/should.js\n ** module id = 173\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/interface/should.js?");

/***/ },
/* 174 */
/***/ function(module, exports) {

	eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n\nmodule.exports = function (chai, util) {\n\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .isOk(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.isOk('everything', 'everything is ok');\n   *     assert.isOk(false, 'this will fail');\n   *\n   * @name isOk\n   * @alias ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isOk = function (val, msg) {\n    new Assertion(val, msg).is.ok;\n  };\n\n  /**\n   * ### .isNotOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.isNotOk('everything', 'this will fail');\n   *     assert.isNotOk(false, 'this will pass');\n   *\n   * @name isNotOk\n   * @alias notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotOk = function (val, msg) {\n    new Assertion(val, msg).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.eql(exp);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n   *\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`\n   *\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n   *\n   * @name isAtLeast\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtLeast\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAtLeast = function (val, atlst, msg) {\n    new Assertion(val, msg).to.be.least(atlst);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg).to.be.below(blw);\n  };\n\n   /**\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n   *\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`\n   *\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n   *\n   * @name isAtMost\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtMost\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAtMost = function (val, atmst, msg) {\n    new Assertion(val, msg).to.be.most(atmst);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg).is['true'];\n  };\n\n  /**\n   * ### .isNotTrue(value, [message])\n   *\n   * Asserts that `value` is not true.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotTrue(tea, 'great, time for tea!');\n   *\n   * @name isNotTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotTrue = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(true);\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg).is['false'];\n  };\n\n  /**\n   * ### .isNotFalse(value, [message])\n   *\n   * Asserts that `value` is not false.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotFalse(tea, 'great, time for tea!');\n   *\n   * @name isNotFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFalse = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(false);\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(null);\n  };\n\n  /**\n   * ### .isNaN\n   * Asserts that value is NaN\n   *\n   *    assert.isNaN('foo', 'foo is NaN');\n   *\n   * @name isNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNaN = function (val, msg) {\n    new Assertion(val, msg).to.be.NaN;\n  };\n\n  /**\n   * ### .isNotNaN\n   * Asserts that value is not NaN\n   *\n   *    assert.isNotNaN(4, '4 is not NaN');\n   *\n   * @name isNotNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n  assert.isNotNaN = function (val, msg) {\n    new Assertion(val, msg).not.to.be.NaN;\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object (as revealed by\n   * `Object.prototype.toString`).\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object.\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('number');\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude).not.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop);\n  };\n\n  /**\n   * ### .deepProperty(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`, which can be a\n   * string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name deepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop);\n  };\n\n  /**\n   * ### .notDeepProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notDeepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`.\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.property(prop, val);\n  };\n\n  /**\n   * ### .propertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`.\n   *\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n   *\n   * @name propertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for deep\n   * reference.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`. `property` can use dot- and\n   * bracket-notation for deep reference.\n   *\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *\n   * @name deepPropertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` property with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg).to.have.length(len);\n  };\n\n  /**\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n   *\n   * Asserts that `function` will throw an error that is an instance of\n   * `constructor`, or alternately that it will throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.throws(fn, 'function throws a reference error');\n   *     assert.throws(fn, /function throws a reference error/);\n   *     assert.throws(fn, ReferenceError);\n   *     assert.throws(fn, ReferenceError, 'function throws a reference error');\n   *     assert.throws(fn, ReferenceError, /function throws a reference error/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.throws = function (fn, errt, errs, msg) {\n    if ('string' === typeof errt || errt instanceof RegExp) {\n      errs = errt;\n      errt = null;\n    }\n\n    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\n   *\n   * Asserts that `function` will _not_ throw an error that is an instance of\n   * `constructor`, or alternately that it will not throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n   *\n   * @name doesNotThrow\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, type, msg) {\n    if ('string' === typeof type) {\n      msg = type;\n      type = null;\n    }\n\n    new Assertion(fn, msg).to.not.Throw(type);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    var ok;\n    switch(operator) {\n      case '==':\n        ok = val == val2;\n        break;\n      case '===':\n        ok = val === val2;\n        break;\n      case '>':\n        ok = val > val2;\n        break;\n      case '>=':\n        ok = val >= val2;\n        break;\n      case '<':\n        ok = val < val2;\n        break;\n      case '<=':\n        ok = val <= val2;\n        break;\n      case '!=':\n        ok = val != val2;\n        break;\n      case '!==':\n        ok = val !== val2;\n        break;\n      default:\n        throw new Error('Invalid operator \"' + operator + '\"');\n    }\n    var test = new Assertion(ok, msg);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .approximately(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name approximately\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.approximately = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.approximately(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members.\n   * Order is not taken into account.\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n   * Order is not taken into account.\n   *\n   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset`.\n   * Order is not taken into account.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg).to.include.members(subset);\n  }\n\n  /**\n   * ### .oneOf(inList, list, [message])\n   *\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n   *\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n   *\n   * @name oneOf\n   * @param {*} inList\n   * @param {Array<*>} list\n   * @param {String} message\n   * @api public\n   */\n\n  assert.oneOf = function (inList, list, msg) {\n    new Assertion(inList, msg).to.be.oneOf(list);\n  }\n\n   /**\n   * ### .changes(function, object, property)\n   *\n   * Asserts that a function changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop) {\n    new Assertion(fn).to.change(obj, prop);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property)\n   *\n   * Asserts that a function does not changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop) {\n    new Assertion(fn).to.not.change(obj, prop);\n  }\n\n   /**\n   * ### .increases(function, object, property)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop) {\n    new Assertion(fn).to.increase(obj, prop);\n  }\n\n   /**\n   * ### .doesNotIncrease(function, object, property)\n   *\n   * Asserts that a function does not increase object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.increase(obj, prop);\n  }\n\n   /**\n   * ### .decreases(function, object, property)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop) {\n    new Assertion(fn).to.decrease(obj, prop);\n  }\n\n   /**\n   * ### .doesNotDecrease(function, object, property)\n   *\n   * Asserts that a function does not decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.decrease(obj, prop);\n  }\n\n  /*!\n   * ### .ifError(object)\n   *\n   * Asserts if value is not a false value, and throws if it is a true value.\n   * This is added to allow for chai to be a drop-in replacement for Node's\n   * assert class.\n   *\n   *     var err = new Error('I am a custom error');\n   *     assert.ifError(err); // Rethrows err!\n   *\n   * @name ifError\n   * @param {Object} object\n   * @api public\n   */\n\n  assert.ifError = function (val) {\n    if (val) {\n      throw(val);\n    }\n  };\n\n  /**\n   * ### .isExtensible(object)\n   *\n   * Asserts that `object` is extensible (can have new properties added to it).\n   *\n   *     assert.isExtensible({});\n   *\n   * @name isExtensible\n   * @alias extensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isExtensible = function (obj, msg) {\n    new Assertion(obj, msg).to.be.extensible;\n  };\n\n  /**\n   * ### .isNotExtensible(object)\n   *\n   * Asserts that `object` is _not_ extensible.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freese({});\n   *\n   *     assert.isNotExtensible(nonExtensibleObject);\n   *     assert.isNotExtensible(sealedObject);\n   *     assert.isNotExtensible(frozenObject);\n   *\n   * @name isNotExtensible\n   * @alias notExtensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotExtensible = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.extensible;\n  };\n\n  /**\n   * ### .isSealed(object)\n   *\n   * Asserts that `object` is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.seal({});\n   *\n   *     assert.isSealed(sealedObject);\n   *     assert.isSealed(frozenObject);\n   *\n   * @name isSealed\n   * @alias sealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isSealed = function (obj, msg) {\n    new Assertion(obj, msg).to.be.sealed;\n  };\n\n  /**\n   * ### .isNotSealed(object)\n   *\n   * Asserts that `object` is _not_ sealed.\n   *\n   *     assert.isNotSealed({});\n   *\n   * @name isNotSealed\n   * @alias notSealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotSealed = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.sealed;\n  };\n\n  /**\n   * ### .isFrozen(object)\n   *\n   * Asserts that `object` is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *     assert.frozen(frozenObject);\n   *\n   * @name isFrozen\n   * @alias frozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isFrozen = function (obj, msg) {\n    new Assertion(obj, msg).to.be.frozen;\n  };\n\n  /**\n   * ### .isNotFrozen(object)\n   *\n   * Asserts that `object` is _not_ frozen.\n   *\n   *     assert.isNotFrozen({});\n   *\n   * @name isNotFrozen\n   * @alias notFrozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotFrozen = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.frozen;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('isOk', 'ok')\n  ('isNotOk', 'notOk')\n  ('throws', 'throw')\n  ('throws', 'Throw')\n  ('isExtensible', 'extensible')\n  ('isNotExtensible', 'notExtensible')\n  ('isSealed', 'sealed')\n  ('isNotSealed', 'notSealed')\n  ('isFrozen', 'frozen')\n  ('isNotFrozen', 'notFrozen');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/assert.js\n ** module id = 174\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/chai/lib/chai/interface/assert.js?");

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _index = __webpack_require__(12);\n\nvar _chai = __webpack_require__(135);\n\ndescribe('rlet', function () {\n  it('should not call subscribers without updates', function (done) {\n    var src = '\\n      rlet a;\\n      rlet b = subscribe(a) a;\\n      subscribe(a, b) { window.f(); }';\n    window.f = function () {\n      done(\"should not be called\");\n    };\n    (0, _index.evalR)(src);\n    setTimeout(function () {\n      return done();\n    }, 100);\n  });\n\n  it('should support imperative updates', function (done) {\n    var src = '\\n      rlet a;\\n      window.g = function() { a = true };\\n      subscribe(a) { window.f(a); }';\n    window.f = function (v) {\n      (0, _chai.expect)(v).to.be.equal(true);\n      done();\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('should support updates and references', function (done) {\n    var src = '\\n      rlet a;\\n      window.g = function() { a = a ? false : true };\\n      subscribe(a) { window.f(a); }';\n    var first = true;\n    window.f = function (v) {\n      if (first) {\n        (0, _chai.expect)(v).to.be.equal(true);\n        first = false;\n        window.g();\n      } else {\n        (0, _chai.expect)(v).to.be.equal(false);\n        done();\n      }\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('should support reactive updates', function (done) {\n    var src = '\\n      rlet a;\\n      rlet b = subscribe(a) a + 1;\\n      window.g = function() { a = 5 };\\n      subscribe(b) { window.f(b); }';\n    window.f = function (v) {\n      (0, _chai.expect)(v).to.be.equal(6);\n      done();\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('should set up dependencies automatically', function (done) {\n    var src = '\\n      rlet a = 3;\\n      rlet b = a + 1;\\n      window.g = function() { a = 5 };\\n      subscribe(b) { window.f(b); }';\n    window.f = function (v) {\n      (0, _chai.expect)(v).to.be.equal(6);\n      done();\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('should support subscriptions to other reactive variables', function (done) {\n    var src = '\\n      rlet a = 3;\\n      rlet b = subscribe(a) true;\\n      window.g = function() { a = 5 };\\n      subscribe(b) { window.f(b); }';\n    window.f = function (v) {\n      (0, _chai.expect)(v).to.be.equal(true);\n      done();\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('should support subscriptions with callbacks', function (done) {\n    var src = '\\n      window.f = null;\\n      window.g = function(cb) { window.f = cb; }\\n      rlet a = subscribe(window.g) true;\\n      subscribe(a) { window.h(a); }';\n    window.h = function (v) {\n      (0, _chai.expect)(v).to.be.equal(true);\n      done();\n    };\n    (0, _index.evalR)(src);\n    window.f();\n  });\n\n  it('should support folding', function (done) {\n    var src = '\\n      rlet a;\\n      rlet b = subscribe(a) initially(0) b + 1;\\n      window.g = function() { a = true; };\\n      subscribe(b) { window.f(b); }';\n    var first = true;\n    window.f = function (v) {\n      if (first) {\n        (0, _chai.expect)(v).to.be.equal(1);\n        first = false;\n        window.g();\n      } else {\n        (0, _chai.expect)(v).to.be.equal(2);\n        done();\n      }\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n\n  it('prevents glitches', function (done) {\n    var src = '\\n      rlet a;\\n      rlet b = subscribe(a) a + 1;\\n      window.g = function() { a = 1; };\\n      subscribe(a, b) { window.f(a + b); }';\n    var first = true;\n    window.f = function (v) {\n      (0, _chai.expect)(v).to.be.equal(3);\n      if (first) {\n        first = false;\n        done();\n      } else {\n        done(new Error(\"done called twice\"));\n      }\n    };\n    (0, _index.evalR)(src);\n    window.g();\n  });\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/simple.js\n ** module id = 175\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./test/simple.js?");

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {\r\n\tdelete __webpack_require__.c[module.id];\r\n\tif(typeof window !== \"undefined\" && window.mochaPhantomJS)\r\n\t\tmochaPhantomJS.run();\r\n\telse\r\n\t\tmocha.run();\r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mocha-loader/start.js\n ** module id = 176\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/mocha-loader/start.js?");

/***/ }
/******/ ]);